diff --git a/gcc/cp/cfns.gperf b/gcc/cp/cfns.gperf
index ef1ed083..ba0c487a 100644
--- a/gcc/cp/cfns.gperf
+++ b/gcc/cp/cfns.gperf
@@ -22,6 +22,9 @@ __inline
 static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
 #endif
 const char * libc_name_p (const char *, unsigned int);
 %}
diff --git a/gcc/cp/cfns.h b/gcc/cp/cfns.h
index 62cdfab9..2fb9b463 100644
--- a/gcc/cp/cfns.h
+++ b/gcc/cp/cfns.h
@@ -53,6 +53,9 @@ __inline
 static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
 #endif
 const char * libc_name_p (const char *, unsigned int);
 /* maximum key range = 391, duplicates = 0 */
diff --git a/gcc/doc/gcc.texi b/gcc/doc/gcc.texi
index 0e167bae..39c93754 100644
--- a/gcc/doc/gcc.texi
+++ b/gcc/doc/gcc.texi
@@ -86,9 +86,15 @@ Published by:
 @item GNU Press
 @tab Website: www.gnupress.org
 @item a division of the
-@tab General: @tex press@@gnu.org @end tex
+@tab General:
+@tex
+press@@gnu.org
+@end tex
 @item Free Software Foundation
-@tab Orders:  @tex sales@@gnu.org @end tex
+@tab Orders:
+@tex
+sales@@gnu.org
+@end tex
 @item 51 Franklin Street, Fifth Floor
 @tab Tel 617-542-5942
 @item Boston, MA 02110-1301 USA
diff --git a/gmp/doc/gmp.info b/gmp/doc/gmp.info
index 0a18319a..65411331 100644
--- a/gmp/doc/gmp.info
+++ b/gmp/doc/gmp.info
@@ -1,21 +1,19 @@
-This is ../../../gcc/gmp/doc/gmp.info, produced by makeinfo version
-4.13 from ../../../gcc/gmp/doc/gmp.texi.
+This is gmp.info, produced by makeinfo version 6.5 from gmp.texi.
 
 This manual describes how to install and use the GNU multiple precision
 arithmetic library, version 5.0.2.
 
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.3 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with the Front-Cover Texts being "A GNU
-Manual", and with the Back-Cover Texts being "You have freedom to copy
-and modify this GNU Manual, like GNU software".  A copy of the license
-is included in *note GNU Free Documentation License::.
-
+   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+Foundation, Inc.
+
+   Permission is granted to copy, distribute and/or modify this document
+under the terms of the GNU Free Documentation License, Version 1.3 or
+any later version published by the Free Software Foundation; with no
+Invariant Sections, with the Front-Cover Texts being "A GNU Manual", and
+with the Back-Cover Texts being "You have freedom to copy and modify
+this GNU Manual, like GNU software".  A copy of the license is included
+in *note GNU Free Documentation License::.
 INFO-DIR-SECTION GNU libraries
 START-INFO-DIR-ENTRY
 * gmp: (gmp).                   GNU Multiple Precision Arithmetic Library.
@@ -27,21 +25,20 @@ File: gmp.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)
 GNU MP
 ******
 
-   This manual describes how to install and use the GNU multiple
-precision arithmetic library, version 5.0.2.
-
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
+This manual describes how to install and use the GNU multiple precision
+arithmetic library, version 5.0.2.
 
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.3 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with the Front-Cover Texts being "A GNU
-Manual", and with the Back-Cover Texts being "You have freedom to copy
-and modify this GNU Manual, like GNU software".  A copy of the license
-is included in *note GNU Free Documentation License::.
+   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+Foundation, Inc.
 
+   Permission is granted to copy, distribute and/or modify this document
+under the terms of the GNU Free Documentation License, Version 1.3 or
+any later version published by the Free Software Foundation; with no
+Invariant Sections, with the Front-Cover Texts being "A GNU Manual", and
+with the Back-Cover Texts being "You have freedom to copy and modify
+this GNU Manual, like GNU software".  A copy of the license is included
+in *note GNU Free Documentation License::.
 
 * Menu:
 
@@ -55,8 +52,8 @@ is included in *note GNU Free Documentation License::.
 * Floating-point Functions::   Functions for arithmetic on floats.
 * Low-level Functions::        Fast functions for natural numbers.
 * Random Number Functions::    Functions for generating random numbers.
-* Formatted Output::           `printf' style output.
-* Formatted Input::            `scanf' style input.
+* Formatted Output::           'printf' style output.
+* Formatted Input::            'scanf' style input.
 * C++ Class Interface::        Class wrappers around GMP types.
 * BSD Compatible Functions::   All functions found in BSD MP.
 * Custom Allocation::          How to customize the internal allocation.
@@ -85,27 +82,27 @@ is to try to prevent others from further sharing any version of this
 library that they might get from you.
 
    Specifically, we want to make sure that you have the right to give
-away copies of the library, that you receive source code or else can
-get it if you want it, that you can change this library or use pieces
-of it in new free programs, and that you know you can do these things.
+away copies of the library, that you receive source code or else can get
+it if you want it, that you can change this library or use pieces of it
+in new free programs, and that you know you can do these things.
 
    To make sure that everyone has such rights, we have to forbid you to
 deprive anyone else of these rights.  For example, if you distribute
 copies of the GNU MP library, you must give the recipients all the
-rights that you have.  You must make sure that they, too, receive or
-can get the source code.  And you must tell them their rights.
+rights that you have.  You must make sure that they, too, receive or can
+get the source code.  And you must tell them their rights.
 
    Also, for our own protection, we must make certain that everyone
 finds out that there is no warranty for the GNU MP library.  If it is
-modified by someone else and passed on, we want their recipients to
-know that what they have is not what we distributed, so that any
-problems introduced by others will not reflect on our reputation.
+modified by someone else and passed on, we want their recipients to know
+that what they have is not what we distributed, so that any problems
+introduced by others will not reflect on our reputation.
 
    The precise conditions of the license for the GNU MP library are
 found in the Lesser General Public License version 3 that accompanies
-the source code, see `COPYING.LIB'.  Certain demonstration programs are
+the source code, see 'COPYING.LIB'.  Certain demonstration programs are
 provided under the terms of the plain General Public License version 3,
-see `COPYING'.
+see 'COPYING'.
 
 
 File: gmp.info,  Node: Introduction to GMP,  Next: Installing GMP,  Prev: Copying,  Up: Top
@@ -121,9 +118,9 @@ types.
 
    Many applications use just a few hundred bits of precision; but some
 applications may need thousands or even millions of bits.  GMP is
-designed to give good performance for both, by choosing algorithms
-based on the sizes of the operands, and by carefully keeping the
-overhead at a minimum.
+designed to give good performance for both, by choosing algorithms based
+on the sizes of the operands, and by carefully keeping the overhead at a
+minimum.
 
    The speed of GMP is achieved by using fullwords as the basic
 arithmetic type, by using sophisticated algorithms, by including
@@ -132,34 +129,33 @@ many different CPUs, and by a general emphasis on speed (as opposed to
 simplicity or elegance).
 
    There is assembly code for these CPUs: ARM, DEC Alpha 21064, 21164,
-and 21264, AMD 29000, AMD K6, K6-2, Athlon, and Athlon64, Hitachi
-SuperH and SH-2, HPPA 1.0, 1.1 and 2.0, Intel Pentium, Pentium
-Pro/II/III, Pentium 4, generic x86, Intel IA-64, i960, Motorola
-MC68000, MC68020, MC88100, and MC88110, Motorola/IBM PowerPC 32 and 64,
-National NS32000, IBM POWER, MIPS R3000, R4000, SPARCv7, SuperSPARC,
-generic SPARCv8, UltraSPARC, DEC VAX, and Zilog Z8000.  Some
-optimizations also for Cray vector systems, Clipper, IBM ROMP (RT), and
-Pyramid AP/XP.
+and 21264, AMD 29000, AMD K6, K6-2, Athlon, and Athlon64, Hitachi SuperH
+and SH-2, HPPA 1.0, 1.1 and 2.0, Intel Pentium, Pentium Pro/II/III,
+Pentium 4, generic x86, Intel IA-64, i960, Motorola MC68000, MC68020,
+MC88100, and MC88110, Motorola/IBM PowerPC 32 and 64, National NS32000,
+IBM POWER, MIPS R3000, R4000, SPARCv7, SuperSPARC, generic SPARCv8,
+UltraSPARC, DEC VAX, and Zilog Z8000.  Some optimizations also for Cray
+vector systems, Clipper, IBM ROMP (RT), and Pyramid AP/XP.
 
 For up-to-date information on GMP, please see the GMP web pages at
 
-     `http://gmplib.org/'
+     <http://gmplib.org/>
 
 The latest version of the library is available at
 
-     `ftp://ftp.gnu.org/gnu/gmp/'
+     <ftp://ftp.gnu.org/gnu/gmp/>
 
-   Many sites around the world mirror `ftp.gnu.org', please use a mirror
-near you, see `http://www.gnu.org/order/ftp.html' for a full list.
+   Many sites around the world mirror 'ftp.gnu.org', please use a mirror
+near you, see <http://www.gnu.org/order/ftp.html> for a full list.
 
    There are three public mailing lists of interest.  One for release
 announcements, one for general questions and discussions about usage of
 the GMP library and one for bug reports.  For more information, see
 
-     `http://gmplib.org/mailman/listinfo/'.
+     <http://gmplib.org/mailman/listinfo/>.
 
-   The proper place for bug reports is <gmp-bugs@gmplib.org>.  See
-*note Reporting Bugs:: for information about reporting bugs.
+   The proper place for bug reports is <gmp-bugs@gmplib.org>.  See *note
+Reporting Bugs:: for information about reporting bugs.
 
 
 1.1 How to use this Manual
@@ -189,7 +185,7 @@ Some self-tests can be run with
 
      make check
 
-And you can install (under `/usr/local' by default) with
+And you can install (under '/usr/local' by default) with
 
      make install
 
@@ -212,116 +208,115 @@ File: gmp.info,  Node: Build Options,  Next: ABI and ISA,  Prev: Installing GMP,
 2.1 Build Options
 =================
 
-All the usual autoconf configure options are available, run `./configure
---help' for a summary.  The file `INSTALL.autoconf' has some generic
+All the usual autoconf configure options are available, run './configure
+--help' for a summary.  The file 'INSTALL.autoconf' has some generic
 installation information too.
 
 Tools
-     `configure' requires various Unix-like tools.  See *note Notes for
+     'configure' requires various Unix-like tools.  See *note Notes for
      Particular Systems::, for some options on non-Unix systems.
 
-     It might be possible to build without the help of `configure',
+     It might be possible to build without the help of 'configure',
      certainly all the code is there, but unfortunately you'll be on
      your own.
 
 Build Directory
-     To compile in a separate build directory, `cd' to that directory,
+     To compile in a separate build directory, 'cd' to that directory,
      and prefix the configure command with the path to the GMP source
      directory.  For example
 
           cd /my/build/dir
           /my/sources/gmp-5.0.2/configure
 
-     Not all `make' programs have the necessary features (`VPATH') to
-     support this.  In particular, SunOS and Slowaris `make' have bugs
+     Not all 'make' programs have the necessary features ('VPATH') to
+     support this.  In particular, SunOS and Slowaris 'make' have bugs
      that make them unable to build in a separate directory.  Use GNU
-     `make' instead.
-
-`--prefix' and `--exec-prefix'
-     The `--prefix' option can be used in the normal way to direct GMP
-     to install under a particular tree.  The default is `/usr/local'.
-
-     `--exec-prefix' can be used to direct architecture-dependent files
-     like `libgmp.a' to a different location.  This can be used to share
-     architecture-independent parts like the documentation, but
-     separate the dependent parts.  Note however that `gmp.h' and
-     `mp.h' are architecture-dependent since they encode certain
-     aspects of `libgmp', so it will be necessary to ensure both
-     `$prefix/include' and `$exec_prefix/include' are available to the
-     compiler.
-
-`--disable-shared', `--disable-static'
+     'make' instead.
+
+'--prefix' and '--exec-prefix'
+     The '--prefix' option can be used in the normal way to direct GMP
+     to install under a particular tree.  The default is '/usr/local'.
+
+     '--exec-prefix' can be used to direct architecture-dependent files
+     like 'libgmp.a' to a different location.  This can be used to share
+     architecture-independent parts like the documentation, but separate
+     the dependent parts.  Note however that 'gmp.h' and 'mp.h' are
+     architecture-dependent since they encode certain aspects of
+     'libgmp', so it will be necessary to ensure both '$prefix/include'
+     and '$exec_prefix/include' are available to the compiler.
+
+'--disable-shared', '--disable-static'
      By default both shared and static libraries are built (where
      possible), but one or other can be disabled.  Shared libraries
      result in smaller executables and permit code sharing between
      separate running processes, but on some CPUs are slightly slower,
      having a small cost on each function call.
 
-Native Compilation, `--build=CPU-VENDOR-OS'
+Native Compilation, '--build=CPU-VENDOR-OS'
      For normal native compilation, the system can be specified with
-     `--build'.  By default `./configure' uses the output from running
-     `./config.guess'.  On some systems `./config.guess' can determine
+     '--build'.  By default './configure' uses the output from running
+     './config.guess'.  On some systems './config.guess' can determine
      the exact CPU type, on others it will be necessary to give it
      explicitly.  For example,
 
           ./configure --build=ultrasparc-sun-solaris2.7
 
-     In all cases the `OS' part is important, since it controls how
-     libtool generates shared libraries.  Running `./config.guess' is
+     In all cases the 'OS' part is important, since it controls how
+     libtool generates shared libraries.  Running './config.guess' is
      the simplest way to see what it should be, if you don't know
      already.
 
-Cross Compilation, `--host=CPU-VENDOR-OS'
+Cross Compilation, '--host=CPU-VENDOR-OS'
      When cross-compiling, the system used for compiling is given by
-     `--build' and the system where the library will run is given by
-     `--host'.  For example when using a FreeBSD Athlon system to build
+     '--build' and the system where the library will run is given by
+     '--host'.  For example when using a FreeBSD Athlon system to build
      GNU/Linux m68k binaries,
 
           ./configure --build=athlon-pc-freebsd3.5 --host=m68k-mac-linux-gnu
 
      Compiler tools are sought first with the host system type as a
-     prefix.  For example `m68k-mac-linux-gnu-ranlib' is tried, then
-     plain `ranlib'.  This makes it possible for a set of
-     cross-compiling tools to co-exist with native tools.  The prefix
-     is the argument to `--host', and this can be an alias, such as
-     `m68k-linux'.  But note that tools don't have to be setup this
-     way, it's enough to just have a `PATH' with a suitable
-     cross-compiling `cc' etc.
+     prefix.  For example 'm68k-mac-linux-gnu-ranlib' is tried, then
+     plain 'ranlib'.  This makes it possible for a set of
+     cross-compiling tools to co-exist with native tools.  The prefix is
+     the argument to '--host', and this can be an alias, such as
+     'm68k-linux'.  But note that tools don't have to be setup this way,
+     it's enough to just have a 'PATH' with a suitable cross-compiling
+     'cc' etc.
 
      Compiling for a different CPU in the same family as the build
      system is a form of cross-compilation, though very possibly this
      would merely be special options on a native compiler.  In any case
-     `./configure' avoids depending on being able to run code on the
-     build system, which is important when creating binaries for a
-     newer CPU since they very possibly won't run on the build system.
+     './configure' avoids depending on being able to run code on the
+     build system, which is important when creating binaries for a newer
+     CPU since they very possibly won't run on the build system.
 
-     In all cases the compiler must be able to produce an executable
-     (of whatever format) from a standard C `main'.  Although only
-     object files will go to make up `libgmp', `./configure' uses
-     linking tests for various purposes, such as determining what
-     functions are available on the host system.
+     In all cases the compiler must be able to produce an executable (of
+     whatever format) from a standard C 'main'.  Although only object
+     files will go to make up 'libgmp', './configure' uses linking tests
+     for various purposes, such as determining what functions are
+     available on the host system.
 
-     Currently a warning is given unless an explicit `--build' is used
+     Currently a warning is given unless an explicit '--build' is used
      when cross-compiling, because it may not be possible to correctly
-     guess the build system type if the `PATH' has only a
-     cross-compiling `cc'.
+     guess the build system type if the 'PATH' has only a
+     cross-compiling 'cc'.
 
-     Note that the `--target' option is not appropriate for GMP.  It's
-     for use when building compiler tools, with `--host' being where
-     they will run, and `--target' what they'll produce code for.
+     Note that the '--target' option is not appropriate for GMP.  It's
+     for use when building compiler tools, with '--host' being where
+     they will run, and '--target' what they'll produce code for.
      Ordinary programs or libraries like GMP are only interested in the
-     `--host' part, being where they'll run.  (Some past versions of
-     GMP used `--target' incorrectly.)
+     '--host' part, being where they'll run.  (Some past versions of GMP
+     used '--target' incorrectly.)
 
 CPU types
      In general, if you want a library that runs as fast as possible,
      you should configure GMP for the exact CPU type your system uses.
      However, this may mean the binaries won't run on older members of
      the family, and might run slower on other members, older or newer.
-     The best idea is always to build GMP for the exact machine type
-     you intend to run it on.
+     The best idea is always to build GMP for the exact machine type you
+     intend to run it on.
 
-     The following CPUs have specific support.  See `configure.in' for
+     The following CPUs have specific support.  See 'configure.in' for
      details of what code and compiler options they select.
 
         * Alpha: alpha, alphaev5, alphaev56, alphapca56, alphapca57,
@@ -360,23 +355,23 @@ CPU types
 
 Generic C Build
      If some of the assembly code causes problems, or if otherwise
-     desired, the generic C code can be selected with CPU `none'.  For
+     desired, the generic C code can be selected with CPU 'none'.  For
      example,
 
           ./configure --host=none-unknown-freebsd3.5
 
-     Note that this will run quite slowly, but it should be portable
-     and should at least make it possible to get something running if
-     all else fails.
+     Note that this will run quite slowly, but it should be portable and
+     should at least make it possible to get something running if all
+     else fails.
 
-Fat binary, `--enable-fat'
-     Using `--enable-fat' selects a "fat binary" build on x86, where
+Fat binary, '--enable-fat'
+     Using '--enable-fat' selects a "fat binary" build on x86, where
      optimized low level subroutines are chosen at runtime according to
-     the CPU detected.  This means more code, but gives good
-     performance on all x86 chips.  (This option might become available
-     for more architectures in the future.)
+     the CPU detected.  This means more code, but gives good performance
+     on all x86 chips.  (This option might become available for more
+     architectures in the future.)
 
-`ABI'
+'ABI'
      On some systems GMP supports multiple ABIs (application binary
      interfaces), meaning data type sizes and calling conventions.  By
      default GMP chooses the best ABI available, but a particular ABI
@@ -387,163 +382,158 @@ Fat binary, `--enable-fat'
      See *note ABI and ISA::, for the available choices on relevant
      CPUs, and what applications need to do.
 
-`CC', `CFLAGS'
+'CC', 'CFLAGS'
      By default the C compiler used is chosen from among some likely
-     candidates, with `gcc' normally preferred if it's present.  The
-     usual `CC=whatever' can be passed to `./configure' to choose
+     candidates, with 'gcc' normally preferred if it's present.  The
+     usual 'CC=whatever' can be passed to './configure' to choose
      something different.
 
      For various systems, default compiler flags are set based on the
-     CPU and compiler.  The usual `CFLAGS="-whatever"' can be passed to
-     `./configure' to use something different or to set good flags for
+     CPU and compiler.  The usual 'CFLAGS="-whatever"' can be passed to
+     './configure' to use something different or to set good flags for
      systems GMP doesn't otherwise know.
 
-     The `CC' and `CFLAGS' used are printed during `./configure', and
-     can be found in each generated `Makefile'.  This is the easiest way
+     The 'CC' and 'CFLAGS' used are printed during './configure', and
+     can be found in each generated 'Makefile'.  This is the easiest way
      to check the defaults when considering changing or adding
      something.
 
-     Note that when `CC' and `CFLAGS' are specified on a system
+     Note that when 'CC' and 'CFLAGS' are specified on a system
      supporting multiple ABIs it's important to give an explicit
-     `ABI=whatever', since GMP can't determine the ABI just from the
+     'ABI=whatever', since GMP can't determine the ABI just from the
      flags and won't be able to select the correct assembly code.
 
-     If just `CC' is selected then normal default `CFLAGS' for that
-     compiler will be used (if GMP recognises it).  For example
-     `CC=gcc' can be used to force the use of GCC, with default flags
-     (and default ABI).
+     If just 'CC' is selected then normal default 'CFLAGS' for that
+     compiler will be used (if GMP recognises it).  For example 'CC=gcc'
+     can be used to force the use of GCC, with default flags (and
+     default ABI).
 
-`CPPFLAGS'
-     Any flags like `-D' defines or `-I' includes required by the
-     preprocessor should be set in `CPPFLAGS' rather than `CFLAGS'.
-     Compiling is done with both `CPPFLAGS' and `CFLAGS', but
-     preprocessing uses just `CPPFLAGS'.  This distinction is because
+'CPPFLAGS'
+     Any flags like '-D' defines or '-I' includes required by the
+     preprocessor should be set in 'CPPFLAGS' rather than 'CFLAGS'.
+     Compiling is done with both 'CPPFLAGS' and 'CFLAGS', but
+     preprocessing uses just 'CPPFLAGS'.  This distinction is because
      most preprocessors won't accept all the flags the compiler does.
      Preprocessing is done separately in some configure tests, and in
-     the `ansi2knr' support for K&R compilers.
+     the 'ansi2knr' support for K&R compilers.
 
-`CC_FOR_BUILD'
+'CC_FOR_BUILD'
      Some build-time programs are compiled and run to generate
-     host-specific data tables.  `CC_FOR_BUILD' is the compiler used
-     for this.  It doesn't need to be in any particular ABI or mode, it
+     host-specific data tables.  'CC_FOR_BUILD' is the compiler used for
+     this.  It doesn't need to be in any particular ABI or mode, it
      merely needs to generate executables that can run.  The default is
-     to try the selected `CC' and some likely candidates such as `cc'
-     and `gcc', looking for something that works.
+     to try the selected 'CC' and some likely candidates such as 'cc'
+     and 'gcc', looking for something that works.
 
-     No flags are used with `CC_FOR_BUILD' because a simple invocation
-     like `cc foo.c' should be enough.  If some particular options are
-     required they can be included as for instance `CC_FOR_BUILD="cc
+     No flags are used with 'CC_FOR_BUILD' because a simple invocation
+     like 'cc foo.c' should be enough.  If some particular options are
+     required they can be included as for instance 'CC_FOR_BUILD="cc
      -whatever"'.
 
-C++ Support, `--enable-cxx'
-     C++ support in GMP can be enabled with `--enable-cxx', in which
+C++ Support, '--enable-cxx'
+     C++ support in GMP can be enabled with '--enable-cxx', in which
      case a C++ compiler will be required.  As a convenience
-     `--enable-cxx=detect' can be used to enable C++ support only if a
+     '--enable-cxx=detect' can be used to enable C++ support only if a
      compiler can be found.  The C++ support consists of a library
-     `libgmpxx.la' and header file `gmpxx.h' (*note Headers and
+     'libgmpxx.la' and header file 'gmpxx.h' (*note Headers and
      Libraries::).
 
-     A separate `libgmpxx.la' has been adopted rather than having C++
-     objects within `libgmp.la' in order to ensure dynamic linked C
+     A separate 'libgmpxx.la' has been adopted rather than having C++
+     objects within 'libgmp.la' in order to ensure dynamic linked C
      programs aren't bloated by a dependency on the C++ standard
      library, and to avoid any chance that the C++ compiler could be
      required when linking plain C programs.
 
-     `libgmpxx.la' will use certain internals from `libgmp.la' and can
-     only be expected to work with `libgmp.la' from the same GMP
+     'libgmpxx.la' will use certain internals from 'libgmp.la' and can
+     only be expected to work with 'libgmp.la' from the same GMP
      version.  Future changes to the relevant internals will be
      accompanied by renaming, so a mismatch will cause unresolved
      symbols rather than perhaps mysterious misbehaviour.
 
-     In general `libgmpxx.la' will be usable only with the C++ compiler
+     In general 'libgmpxx.la' will be usable only with the C++ compiler
      that built it, since name mangling and runtime support are usually
      incompatible between different compilers.
 
-`CXX', `CXXFLAGS'
+'CXX', 'CXXFLAGS'
      When C++ support is enabled, the C++ compiler and its flags can be
-     set with variables `CXX' and `CXXFLAGS' in the usual way.  The
-     default for `CXX' is the first compiler that works from a list of
-     likely candidates, with `g++' normally preferred when available.
-     The default for `CXXFLAGS' is to try `CFLAGS', `CFLAGS' without
-     `-g', then for `g++' either `-g -O2' or `-O2', or for other
-     compilers `-g' or nothing.  Trying `CFLAGS' this way is convenient
-     when using `gcc' and `g++' together, since the flags for `gcc' will
-     usually suit `g++'.
+     set with variables 'CXX' and 'CXXFLAGS' in the usual way.  The
+     default for 'CXX' is the first compiler that works from a list of
+     likely candidates, with 'g++' normally preferred when available.
+     The default for 'CXXFLAGS' is to try 'CFLAGS', 'CFLAGS' without
+     '-g', then for 'g++' either '-g -O2' or '-O2', or for other
+     compilers '-g' or nothing.  Trying 'CFLAGS' this way is convenient
+     when using 'gcc' and 'g++' together, since the flags for 'gcc' will
+     usually suit 'g++'.
 
      It's important that the C and C++ compilers match, meaning their
      startup and runtime support routines are compatible and that they
      generate code in the same ABI (if there's a choice of ABIs on the
-     system).  `./configure' isn't currently able to check these things
-     very well itself, so for that reason `--disable-cxx' is the
+     system).  './configure' isn't currently able to check these things
+     very well itself, so for that reason '--disable-cxx' is the
      default, to avoid a build failure due to a compiler mismatch.
      Perhaps this will change in the future.
 
-     Incidentally, it's normally not good enough to set `CXX' to the
-     same as `CC'.  Although `gcc' for instance recognises `foo.cc' as
-     C++ code, only `g++' will invoke the linker the right way when
+     Incidentally, it's normally not good enough to set 'CXX' to the
+     same as 'CC'.  Although 'gcc' for instance recognises 'foo.cc' as
+     C++ code, only 'g++' will invoke the linker the right way when
      building an executable or shared library from C++ object files.
 
-Temporary Memory, `--enable-alloca=<choice>'
+Temporary Memory, '--enable-alloca=<choice>'
      GMP allocates temporary workspace using one of the following three
      methods, which can be selected with for instance
-     `--enable-alloca=malloc-reentrant'.
+     '--enable-alloca=malloc-reentrant'.
 
-        * `alloca' - C library or compiler builtin.
-
-        * `malloc-reentrant' - the heap, in a re-entrant fashion.
-
-        * `malloc-notreentrant' - the heap, with global variables.
+        * 'alloca' - C library or compiler builtin.
+        * 'malloc-reentrant' - the heap, in a re-entrant fashion.
+        * 'malloc-notreentrant' - the heap, with global variables.
 
      For convenience, the following choices are also available.
-     `--disable-alloca' is the same as `no'.
-
-        * `yes' - a synonym for `alloca'.
-
-        * `no' - a synonym for `malloc-reentrant'.
+     '--disable-alloca' is the same as 'no'.
 
-        * `reentrant' - `alloca' if available, otherwise
-          `malloc-reentrant'.  This is the default.
+        * 'yes' - a synonym for 'alloca'.
+        * 'no' - a synonym for 'malloc-reentrant'.
+        * 'reentrant' - 'alloca' if available, otherwise
+          'malloc-reentrant'.  This is the default.
+        * 'notreentrant' - 'alloca' if available, otherwise
+          'malloc-notreentrant'.
 
-        * `notreentrant' - `alloca' if available, otherwise
-          `malloc-notreentrant'.
-
-     `alloca' is reentrant and fast, and is recommended.  It actually
+     'alloca' is reentrant and fast, and is recommended.  It actually
      allocates just small blocks on the stack; larger ones use
      malloc-reentrant.
 
-     `malloc-reentrant' is, as the name suggests, reentrant and thread
-     safe, but `malloc-notreentrant' is faster and should be used if
+     'malloc-reentrant' is, as the name suggests, reentrant and thread
+     safe, but 'malloc-notreentrant' is faster and should be used if
      reentrancy is not required.
 
      The two malloc methods in fact use the memory allocation functions
-     selected by `mp_set_memory_functions', these being `malloc' and
+     selected by 'mp_set_memory_functions', these being 'malloc' and
      friends by default.  *Note Custom Allocation::.
 
-     An additional choice `--enable-alloca=debug' is available, to help
+     An additional choice '--enable-alloca=debug' is available, to help
      when debugging memory related problems (*note Debugging::).
 
-FFT Multiplication, `--disable-fft'
+FFT Multiplication, '--disable-fft'
      By default multiplications are done using Karatsuba, 3-way Toom,
      and Fermat FFT.  The FFT is only used on large to very large
      operands and can be disabled to save code size if desired.
 
-Berkeley MP, `--enable-mpbsd'
-     The Berkeley MP compatibility library (`libmp') and header file
-     (`mp.h') are built and installed only if `--enable-mpbsd' is used.
+Berkeley MP, '--enable-mpbsd'
+     The Berkeley MP compatibility library ('libmp') and header file
+     ('mp.h') are built and installed only if '--enable-mpbsd' is used.
      *Note BSD Compatible Functions::.
 
-Assertion Checking, `--enable-assert'
+Assertion Checking, '--enable-assert'
      This option enables some consistency checking within the library.
      This can be of use while debugging, *note Debugging::.
 
-Execution Profiling, `--enable-profiling=prof/gprof/instrument'
+Execution Profiling, '--enable-profiling=prof/gprof/instrument'
      Enable profiling support, in one of various styles, *note
      Profiling::.
 
-`MPN_PATH'
+'MPN_PATH'
      Various assembly versions of each mpn subroutines are provided.
-     For a given CPU, a search is made though a path to choose a
-     version of each.  For example `sparcv8' has
+     For a given CPU, a search is made though a path to choose a version
+     of each.  For example 'sparcv8' has
 
           MPN_PATH="sparc32/v8 sparc32 generic"
 
@@ -553,20 +543,19 @@ Execution Profiling, `--enable-profiling=prof/gprof/instrument'
      is completely unnecessary.
 
 Documentation
-     The source for the document you're now reading is `doc/gmp.texi',
+     The source for the document you're now reading is 'doc/gmp.texi',
      in Texinfo format, see *note Texinfo: (texinfo)Top.
 
-     Info format `doc/gmp.info' is included in the distribution.  The
+     Info format 'doc/gmp.info' is included in the distribution.  The
      usual automake targets are available to make PostScript, DVI, PDF
      and HTML (these will require various TeX and Texinfo tools).
 
-     DocBook and XML can be generated by the Texinfo `makeinfo' program
-     too, see *note Options for `makeinfo': (texinfo)makeinfo options.
+     DocBook and XML can be generated by the Texinfo 'makeinfo' program
+     too, see *note Options for 'makeinfo': (texinfo)makeinfo options.
 
-     Some supplementary notes can also be found in the `doc'
+     Some supplementary notes can also be found in the 'doc'
      subdirectory.
 
-
 
 File: gmp.info,  Node: ABI and ISA,  Next: Notes for Package Builds,  Prev: Build Options,  Up: Installing GMP
 
@@ -578,16 +567,16 @@ between functions, meaning what registers are used and what sizes the
 various C data types are.  ISA (Instruction Set Architecture) refers to
 the instructions and registers a CPU has available.
 
-   Some 64-bit ISA CPUs have both a 64-bit ABI and a 32-bit ABI
-defined, the latter for compatibility with older CPUs in the family.
-GMP supports some CPUs like this in both ABIs.  In fact within GMP
-`ABI' means a combination of chip ABI, plus how GMP chooses to use it.
-For example in some 32-bit ABIs, GMP may support a limb as either a
-32-bit `long' or a 64-bit `long long'.
+   Some 64-bit ISA CPUs have both a 64-bit ABI and a 32-bit ABI defined,
+the latter for compatibility with older CPUs in the family.  GMP
+supports some CPUs like this in both ABIs.  In fact within GMP 'ABI'
+means a combination of chip ABI, plus how GMP chooses to use it.  For
+example in some 32-bit ABIs, GMP may support a limb as either a 32-bit
+'long' or a 64-bit 'long long'.
 
-   By default GMP chooses the best ABI available for a given system,
-and this generally gives significantly greater speed.  But an ABI can
-be chosen explicitly to make GMP compatible with other libraries, or
+   By default GMP chooses the best ABI available for a given system, and
+this generally gives significantly greater speed.  But an ABI can be
+chosen explicitly to make GMP compatible with other libraries, or
 particular application requirements.  For example,
 
      ./configure ABI=32
@@ -595,58 +584,57 @@ particular application requirements.  For example,
    In all cases it's vital that all object code used in a given program
 is compiled for the same ABI.
 
-   Usually a limb is implemented as a `long'.  When a `long long' limb
-is used this is encoded in the generated `gmp.h'.  This is convenient
-for applications, but it does mean that `gmp.h' will vary, and can't be
-just copied around.  `gmp.h' remains compiler independent though, since
-all compilers for a particular ABI will be expected to use the same
-limb type.
+   Usually a limb is implemented as a 'long'.  When a 'long long' limb
+is used this is encoded in the generated 'gmp.h'.  This is convenient
+for applications, but it does mean that 'gmp.h' will vary, and can't be
+just copied around.  'gmp.h' remains compiler independent though, since
+all compilers for a particular ABI will be expected to use the same limb
+type.
 
    Currently no attempt is made to follow whatever conventions a system
 has for installing library or header files built for a particular ABI.
 This will probably only matter when installing multiple builds of GMP,
-and it might be as simple as configuring with a special `libdir', or it
+and it might be as simple as configuring with a special 'libdir', or it
 might require more than that.  Note that builds for different ABIs need
-to done separately, with a fresh `./configure' and `make' each.
+to done separately, with a fresh './configure' and 'make' each.
 
 
-AMD64 (`x86_64')
+AMD64 ('x86_64')
      On AMD64 systems supporting both 32-bit and 64-bit modes for
      applications, the following ABI choices are available.
 
-    `ABI=64'
+     'ABI=64'
           The 64-bit ABI uses 64-bit limbs and pointers and makes full
           use of the chip architecture.  This is the default.
-          Applications will usually not need special compiler flags,
-          but for reference the option is
+          Applications will usually not need special compiler flags, but
+          for reference the option is
 
                gcc  -m64
 
-    `ABI=32'
+     'ABI=32'
           The 32-bit ABI is the usual i386 conventions.  This will be
-          slower, and is not recommended except for inter-operating
-          with other code not yet 64-bit capable.  Applications must be
+          slower, and is not recommended except for inter-operating with
+          other code not yet 64-bit capable.  Applications must be
           compiled with
 
                gcc  -m32
 
-          (In GCC 2.95 and earlier there's no `-m32' option, it's the
+          (In GCC 2.95 and earlier there's no '-m32' option, it's the
           only mode.)
 
 
-HPPA 2.0 (`hppa2.0*', `hppa64')
-
-    `ABI=2.0w'
+HPPA 2.0 ('hppa2.0*', 'hppa64')
+     'ABI=2.0w'
           The 2.0w ABI uses 64-bit limbs and pointers and is available
           on HP-UX 11 or up.  Applications must be compiled with
 
                gcc [built for 2.0w]
                cc  +DD64
 
-    `ABI=2.0n'
+     'ABI=2.0n'
           The 2.0n ABI means the 32-bit HPPA 1.0 ABI and all its normal
           calling conventions, but with 64-bit instructions permitted
-          within functions.  GMP uses a 64-bit `long long' for a limb.
+          within functions.  GMP uses a 64-bit 'long long' for a limb.
           This ABI is available on hppa64 GNU/Linux and on HP-UX 10 or
           higher.  Applications must be compiled with
 
@@ -654,32 +642,32 @@ HPPA 2.0 (`hppa2.0*', `hppa64')
                cc  +DA2.0 +e
 
           Note that current versions of GCC (eg. 3.2) don't generate
-          64-bit instructions for `long long' operations and so may be
+          64-bit instructions for 'long long' operations and so may be
           slower than for 2.0w.  (The GMP assembly code is the same
           though.)
 
-    `ABI=1.0'
+     'ABI=1.0'
           HPPA 2.0 CPUs can run all HPPA 1.0 and 1.1 code in the 32-bit
           HPPA 1.0 ABI.  No special compiler options are needed for
           applications.
 
-     All three ABIs are available for CPU types `hppa2.0w', `hppa2.0'
-     and `hppa64', but for CPU type `hppa2.0n' only 2.0n or 1.0 are
+     All three ABIs are available for CPU types 'hppa2.0w', 'hppa2.0'
+     and 'hppa64', but for CPU type 'hppa2.0n' only 2.0n or 1.0 are
      considered.
 
      Note that GCC on HP-UX has no options to choose between 2.0n and
-     2.0w modes, unlike HP `cc'.  Instead it must be built for one or
+     2.0w modes, unlike HP 'cc'.  Instead it must be built for one or
      the other ABI.  GMP will detect how it was built, and skip to the
-     corresponding `ABI'.
+     corresponding 'ABI'.
 
 
-IA-64 under HP-UX (`ia64*-*-hpux*', `itanium*-*-hpux*')
+IA-64 under HP-UX ('ia64*-*-hpux*', 'itanium*-*-hpux*')
      HP-UX supports two ABIs for IA-64.  GMP performance is the same in
      both.
 
-    `ABI=32'
-          In the 32-bit ABI, pointers, `int's and `long's are 32 bits
-          and GMP uses a 64 bit `long long' for a limb.  Applications
+     'ABI=32'
+          In the 32-bit ABI, pointers, 'int's and 'long's are 32 bits
+          and GMP uses a 64 bit 'long long' for a limb.  Applications
           can be compiled without any special flags since this ABI is
           the default in both HP C and GCC, but for reference the flags
           are
@@ -687,41 +675,40 @@ IA-64 under HP-UX (`ia64*-*-hpux*', `itanium*-*-hpux*')
                gcc  -milp32
                cc   +DD32
 
-    `ABI=64'
-          In the 64-bit ABI, `long's and pointers are 64 bits and GMP
-          uses a `long' for a limb.  Applications must be compiled with
+     'ABI=64'
+          In the 64-bit ABI, 'long's and pointers are 64 bits and GMP
+          uses a 'long' for a limb.  Applications must be compiled with
 
                gcc  -mlp64
                cc   +DD64
 
-     On other IA-64 systems, GNU/Linux for instance, `ABI=64' is the
+     On other IA-64 systems, GNU/Linux for instance, 'ABI=64' is the
      only choice.
 
 
-MIPS under IRIX 6 (`mips*-*-irix[6789]')
+MIPS under IRIX 6 ('mips*-*-irix[6789]')
      IRIX 6 always has a 64-bit MIPS 3 or better CPU, and supports ABIs
      o32, n32, and 64.  n32 or 64 are recommended, and GMP performance
      will be the same in each.  The default is n32.
 
-    `ABI=o32'
+     'ABI=o32'
           The o32 ABI is 32-bit pointers and integers, and no 64-bit
-          operations.  GMP will be slower than in n32 or 64, this
-          option only exists to support old compilers, eg. GCC 2.7.2.
+          operations.  GMP will be slower than in n32 or 64, this option
+          only exists to support old compilers, eg. GCC 2.7.2.
           Applications can be compiled with no special flags on an old
           compiler, or on a newer compiler with
 
                gcc  -mabi=32
                cc   -32
 
-    `ABI=n32'
-          The n32 ABI is 32-bit pointers and integers, but with a
-          64-bit limb using a `long long'.  Applications must be
-          compiled with
+     'ABI=n32'
+          The n32 ABI is 32-bit pointers and integers, but with a 64-bit
+          limb using a 'long long'.  Applications must be compiled with
 
                gcc  -mabi=n32
                cc   -n32
 
-    `ABI=64'
+     'ABI=64'
           The 64-bit ABI is 64-bit pointers and integers.  Applications
           must be compiled with
 
@@ -733,48 +720,46 @@ MIPS under IRIX 6 (`mips*-*-irix[6789]')
      and the MIPS 2 code.
 
 
-PowerPC 64 (`powerpc64', `powerpc620', `powerpc630', `powerpc970', `power4', `power5')
-
-    `ABI=aix64'
+PowerPC 64 ('powerpc64', 'powerpc620', 'powerpc630', 'powerpc970', 'power4', 'power5')
+     'ABI=aix64'
           The AIX 64 ABI uses 64-bit limbs and pointers and is the
-          default on PowerPC 64 `*-*-aix*' systems.  Applications must
+          default on PowerPC 64 '*-*-aix*' systems.  Applications must
           be compiled with
 
                gcc  -maix64
                xlc  -q64
 
-    `ABI=mode64'
-          The `mode64' ABI uses 64-bit limbs and pointers, and is the
-          default on 64-bit GNU/Linux, BSD, and Mac OS X/Darwin
-          systems.  Applications must be compiled with
+     'ABI=mode64'
+          The 'mode64' ABI uses 64-bit limbs and pointers, and is the
+          default on 64-bit GNU/Linux, BSD, and Mac OS X/Darwin systems.
+          Applications must be compiled with
 
                gcc  -m64
 
-    `ABI=mode32'
-          The `mode32' ABI uses a 64-bit `long long' limb but with the
+     'ABI=mode32'
+          The 'mode32' ABI uses a 64-bit 'long long' limb but with the
           chip still in 32-bit mode and using 32-bit calling
           conventions.  This is the default for systems where the true
           64-bit ABI is unavailable.  No special compiler options are
           typically needed for applications.
 
-    `ABI=32'
+     'ABI=32'
           This is the basic 32-bit PowerPC ABI, with a 32-bit limb.  No
           special compiler options are needed for applications.
 
-     GMP's speed is greatest for `aix64' and `mode64'.  In `ABI=32'
-     only the 32-bit ISA is used and this doesn't make full use of a
-     64-bit chip.  On a suitable system we could perhaps use more of
-     the ISA, but there are no plans to do so.
-
+     GMP's speed is greatest for 'aix64' and 'mode64'.  In 'ABI=32' only
+     the 32-bit ISA is used and this doesn't make full use of a 64-bit
+     chip.  On a suitable system we could perhaps use more of the ISA,
+     but there are no plans to do so.
 
-Sparc V9 (`sparc64', `sparcv9', `ultrasparc*')
 
-    `ABI=64'
+Sparc V9 ('sparc64', 'sparcv9', 'ultrasparc*')
+     'ABI=64'
           The 64-bit V9 ABI is available on the various BSD sparc64
           ports, recent versions of Sparc64 GNU/Linux, and Solaris 2.7
           and up (when the kernel is in 64-bit mode).  GCC 3.2 or
-          higher, or Sun `cc' is required.  On GNU/Linux, depending on
-          the default `gcc' mode, applications must be compiled with
+          higher, or Sun 'cc' is required.  On GNU/Linux, depending on
+          the default 'gcc' mode, applications must be compiled with
 
                gcc  -m64
 
@@ -786,38 +771,38 @@ Sparc V9 (`sparc64', `sparcv9', `ultrasparc*')
           On the BSD sparc64 systems no special options are required,
           since 64-bits is the only ABI available.
 
-    `ABI=32'
-          For the basic 32-bit ABI, GMP still uses as much of the V9
-          ISA as it can.  In the Sun documentation this combination is
-          known as "v8plus".  On GNU/Linux, depending on the default
-          `gcc' mode, applications may need to be compiled with
+     'ABI=32'
+          For the basic 32-bit ABI, GMP still uses as much of the V9 ISA
+          as it can.  In the Sun documentation this combination is known
+          as "v8plus".  On GNU/Linux, depending on the default 'gcc'
+          mode, applications may need to be compiled with
 
                gcc  -m32
 
           On Solaris, no special compiler options are required for
           applications, though using something like the following is
-          recommended.  (`gcc' 2.8 and earlier only support `-mv8'
+          recommended.  ('gcc' 2.8 and earlier only support '-mv8'
           though.)
 
                gcc  -mv8plus
                cc   -xarch=v8plus
 
-     GMP speed is greatest in `ABI=64', so it's the default where
+     GMP speed is greatest in 'ABI=64', so it's the default where
      available.  The speed is partly because there are extra registers
      available and partly because 64-bits is considered the more
      important case and has therefore had better code written for it.
 
-     Don't be confused by the names of the `-m' and `-x' compiler
-     options, they're called `arch' but effectively control both ABI
-     and ISA.
+     Don't be confused by the names of the '-m' and '-x' compiler
+     options, they're called 'arch' but effectively control both ABI and
+     ISA.
 
-     On Solaris 2.6 and earlier, only `ABI=32' is available since the
+     On Solaris 2.6 and earlier, only 'ABI=32' is available since the
      kernel doesn't save all registers.
 
      On Solaris 2.7 with the kernel in 32-bit mode, a normal native
-     build will reject `ABI=64' because the resulting executables won't
-     run.  `ABI=64' can still be built if desired by making it look
-     like a cross-compile, for example
+     build will reject 'ABI=64' because the resulting executables won't
+     run.  'ABI=64' can still be built if desired by making it look like
+     a cross-compile, for example
 
           ./configure --build=none --host=sparcv9-sun-solaris2.7 ABI=64
 
@@ -830,8 +815,8 @@ File: gmp.info,  Node: Notes for Package Builds,  Next: Notes for Particular Sys
 GMP should present no great difficulties for packaging in a binary
 distribution.
 
-   Libtool is used to build the library and `-version-info' is set
-appropriately, having started from `3:0:0' in GMP 3.0 (*note Library
+   Libtool is used to build the library and '-version-info' is set
+appropriately, having started from '3:0:0' in GMP 3.0 (*note Library
 interface versions: (libtool)Versioning.).
 
    The GMP 4 series will be upwardly binary compatible in each release
@@ -842,45 +827,45 @@ auxiliary mechanism may be needed to express that a dynamic linked
 application depends on a new enough GMP.
 
    An auxiliary mechanism may also be needed to express that
-`libgmpxx.la' (from `--enable-cxx', *note Build Options::) requires
-`libgmp.la' from the same GMP version, since this is not done by the
-libtool versioning, nor otherwise.  A mismatch will result in
-unresolved symbols from the linker, or perhaps the loader.
+'libgmpxx.la' (from '--enable-cxx', *note Build Options::) requires
+'libgmp.la' from the same GMP version, since this is not done by the
+libtool versioning, nor otherwise.  A mismatch will result in unresolved
+symbols from the linker, or perhaps the loader.
 
    When building a package for a CPU family, care should be taken to use
-`--host' (or `--build') to choose the least common denominator among
-the CPUs which might use the package.  For example this might mean plain
-`sparc' (meaning V7) for SPARCs.
+'--host' (or '--build') to choose the least common denominator among the
+CPUs which might use the package.  For example this might mean plain
+'sparc' (meaning V7) for SPARCs.
 
-   For x86s, `--enable-fat' sets things up for a fat binary build,
+   For x86s, '--enable-fat' sets things up for a fat binary build,
 making a runtime selection of optimized low level routines.  This is a
 good choice for packaging to run on a range of x86 chips.
 
    Users who care about speed will want GMP built for their exact CPU
 type, to make best use of the available optimizations.  Providing a way
-to suitably rebuild a package may be useful.  This could be as simple
-as making it possible for a user to omit `--build' (and `--host') so
-`./config.guess' will detect the CPU.  But a way to manually specify a
-`--build' will be wanted for systems where `./config.guess' is inexact.
+to suitably rebuild a package may be useful.  This could be as simple as
+making it possible for a user to omit '--build' (and '--host') so
+'./config.guess' will detect the CPU.  But a way to manually specify a
+'--build' will be wanted for systems where './config.guess' is inexact.
 
    On systems with multiple ABIs, a packaged build will need to decide
 which among the choices is to be provided, see *note ABI and ISA::.  A
-given run of `./configure' etc will only build one ABI.  If a second
-ABI is also required then a second run of `./configure' etc must be
-made, starting from a clean directory tree (`make distclean').
+given run of './configure' etc will only build one ABI.  If a second ABI
+is also required then a second run of './configure' etc must be made,
+starting from a clean directory tree ('make distclean').
 
    As noted under "ABI and ISA", currently no attempt is made to follow
 system conventions for install locations that vary with ABI, such as
-`/usr/lib/sparcv9' for `ABI=64' as opposed to `/usr/lib' for `ABI=32'.
-A package build can override `libdir' and other standard variables as
+'/usr/lib/sparcv9' for 'ABI=64' as opposed to '/usr/lib' for 'ABI=32'.
+A package build can override 'libdir' and other standard variables as
 necessary.
 
-   Note that `gmp.h' is a generated file, and will be architecture and
+   Note that 'gmp.h' is a generated file, and will be architecture and
 ABI dependent.  When attempting to install two ABIs simultaneously it
-will be important that an application compile gets the correct `gmp.h'
+will be important that an application compile gets the correct 'gmp.h'
 for its desired ABI.  If compiler include paths don't vary with ABI
-options then it might be necessary to create a `/usr/include/gmp.h'
-which tests preprocessor symbols and chooses the correct actual `gmp.h'.
+options then it might be necessary to create a '/usr/include/gmp.h'
+which tests preprocessor symbols and chooses the correct actual 'gmp.h'.
 
 
 File: gmp.info,  Node: Notes for Particular Systems,  Next: Known Build Problems,  Prev: Notes for Package Builds,  Up: Installing GMP
@@ -889,28 +874,28 @@ File: gmp.info,  Node: Notes for Particular Systems,  Next: Known Build Problems
 ================================
 
 AIX 3 and 4
-     On systems `*-*-aix[34]*' shared libraries are disabled by
-     default, since some versions of the native `ar' fail on the
-     convenience libraries used.  A shared build can be attempted with
+     On systems '*-*-aix[34]*' shared libraries are disabled by default,
+     since some versions of the native 'ar' fail on the convenience
+     libraries used.  A shared build can be attempted with
 
           ./configure --enable-shared --disable-static
 
-     Note that the `--disable-static' is necessary because in a shared
-     build libtool makes `libgmp.a' a symlink to `libgmp.so',
-     apparently for the benefit of old versions of `ld' which only
-     recognise `.a', but unfortunately this is done even if a fully
-     functional `ld' is available.
+     Note that the '--disable-static' is necessary because in a shared
+     build libtool makes 'libgmp.a' a symlink to 'libgmp.so', apparently
+     for the benefit of old versions of 'ld' which only recognise '.a',
+     but unfortunately this is done even if a fully functional 'ld' is
+     available.
 
 ARM
-     On systems `arm*-*-*', versions of GCC up to and including 2.95.3
+     On systems 'arm*-*-*', versions of GCC up to and including 2.95.3
      have a bug in unsigned division, giving wrong results for some
-     operands.  GMP `./configure' will demand GCC 2.95.4 or later.
+     operands.  GMP './configure' will demand GCC 2.95.4 or later.
 
 Compaq C++
-     Compaq C++ on OSF 5.1 has two flavours of `iostream', a standard
-     one and an old pre-standard one (see `man iostream_intro').  GMP
+     Compaq C++ on OSF 5.1 has two flavours of 'iostream', a standard
+     one and an old pre-standard one (see 'man iostream_intro').  GMP
      can only use the standard one, which unfortunately is not the
-     default but must be selected by defining `__USE_STD_IOSTREAM'.
+     default but must be selected by defining '__USE_STD_IOSTREAM'.
      Configure with for instance
 
           ./configure --enable-cxx CPPFLAGS=-D__USE_STD_IOSTREAM
@@ -919,114 +904,114 @@ Floating Point Mode
      On some systems, the hardware floating point has a control mode
      which can set all operations to be done in a particular precision,
      for instance single, double or extended on x86 systems (x87
-     floating point).  The GMP functions involving a `double' cannot be
-     expected to operate to their full precision when the hardware is
-     in single precision mode.  Of course this affects all code,
-     including application code, not just GMP.
+     floating point).  The GMP functions involving a 'double' cannot be
+     expected to operate to their full precision when the hardware is in
+     single precision mode.  Of course this affects all code, including
+     application code, not just GMP.
 
 MS-DOS and MS Windows
      On an MS-DOS system DJGPP can be used to build GMP, and on an MS
      Windows system Cygwin, DJGPP and MINGW can be used.  All three are
      excellent ports of GCC and the various GNU tools.
 
-          `http://www.cygwin.com/'
-          `http://www.delorie.com/djgpp/'
-          `http://www.mingw.org/'
+          <http://www.cygwin.com/>
+          <http://www.delorie.com/djgpp/>
+          <http://www.mingw.org/>
 
      Microsoft also publishes an Interix "Services for Unix" which can
-     be used to build GMP on Windows (with a normal `./configure'), but
+     be used to build GMP on Windows (with a normal './configure'), but
      it's not free software.
 
 MS Windows DLLs
-     On systems `*-*-cygwin*', `*-*-mingw*' and `*-*-pw32*' by default
+     On systems '*-*-cygwin*', '*-*-mingw*' and '*-*-pw32*' by default
      GMP builds only a static library, but a DLL can be built instead
      using
 
           ./configure --disable-static --enable-shared
 
      Static and DLL libraries can't both be built, since certain export
-     directives in `gmp.h' must be different.
+     directives in 'gmp.h' must be different.
 
      A MINGW DLL build of GMP can be used with Microsoft C.  Libtool
-     doesn't install a `.lib' format import library, but it can be
-     created with MS `lib' as follows, and copied to the install
-     directory.  Similarly for `libmp' and `libgmpxx'.
+     doesn't install a '.lib' format import library, but it can be
+     created with MS 'lib' as follows, and copied to the install
+     directory.  Similarly for 'libmp' and 'libgmpxx'.
 
           cd .libs
           lib /def:libgmp-3.dll.def /out:libgmp-3.lib
 
-     MINGW uses the C runtime library `msvcrt.dll' for I/O, so
+     MINGW uses the C runtime library 'msvcrt.dll' for I/O, so
      applications wanting to use the GMP I/O routines must be compiled
-     with `cl /MD' to do the same.  If one of the other C runtime
+     with 'cl /MD' to do the same.  If one of the other C runtime
      library choices provided by MS C is desired then the suggestion is
      to use the GMP string functions and confine I/O to the application.
 
 Motorola 68k CPU Types
-     `m68k' is taken to mean 68000.  `m68020' or higher will give a
-     performance boost on applicable CPUs.  `m68360' can be used for
-     CPU32 series chips.  `m68302' can be used for "Dragonball" series
-     chips, though this is merely a synonym for `m68000'.
+     'm68k' is taken to mean 68000.  'm68020' or higher will give a
+     performance boost on applicable CPUs.  'm68360' can be used for
+     CPU32 series chips.  'm68302' can be used for "Dragonball" series
+     chips, though this is merely a synonym for 'm68000'.
 
 OpenBSD 2.6
-     `m4' in this release of OpenBSD has a bug in `eval' that makes it
-     unsuitable for `.asm' file processing.  `./configure' will detect
-     the problem and either abort or choose another m4 in the `PATH'.
+     'm4' in this release of OpenBSD has a bug in 'eval' that makes it
+     unsuitable for '.asm' file processing.  './configure' will detect
+     the problem and either abort or choose another m4 in the 'PATH'.
      The bug is fixed in OpenBSD 2.7, so either upgrade or use GNU m4.
 
 Power CPU Types
-     In GMP, CPU types `power*' and `powerpc*' will each use
+     In GMP, CPU types 'power*' and 'powerpc*' will each use
      instructions not available on the other, so it's important to
      choose the right one for the CPU that will be used.  Currently GMP
      has no assembly code support for using just the common instruction
      subset.  To get executables that run on both, the current
-     suggestion is to use the generic C code (CPU `none'), possibly
-     with appropriate compiler options (like `-mcpu=common' for `gcc').
-     CPU `rs6000' (which is not a CPU but a family of workstations) is
-     accepted by `config.sub', but is currently equivalent to `none'.
+     suggestion is to use the generic C code (CPU 'none'), possibly with
+     appropriate compiler options (like '-mcpu=common' for 'gcc').  CPU
+     'rs6000' (which is not a CPU but a family of workstations) is
+     accepted by 'config.sub', but is currently equivalent to 'none'.
 
 Sparc CPU Types
-     `sparcv8' or `supersparc' on relevant systems will give a
+     'sparcv8' or 'supersparc' on relevant systems will give a
      significant performance increase over the V7 code selected by plain
-     `sparc'.
+     'sparc'.
 
 Sparc App Regs
      The GMP assembly code for both 32-bit and 64-bit Sparc clobbers the
-     "application registers" `g2', `g3' and `g4', the same way that the
-     GCC default `-mapp-regs' does (*note SPARC Options: (gcc)SPARC
+     "application registers" 'g2', 'g3' and 'g4', the same way that the
+     GCC default '-mapp-regs' does (*note SPARC Options: (gcc)SPARC
      Options.).
 
      This makes that code unsuitable for use with the special V9
-     `-mcmodel=embmedany' (which uses `g4' as a data segment pointer),
+     '-mcmodel=embmedany' (which uses 'g4' as a data segment pointer),
      and for applications wanting to use those registers for special
-     purposes.  In these cases the only suggestion currently is to
-     build GMP with CPU `none' to avoid the assembly code.
+     purposes.  In these cases the only suggestion currently is to build
+     GMP with CPU 'none' to avoid the assembly code.
 
 SunOS 4
-     `/usr/bin/m4' lacks various features needed to process `.asm'
-     files, and instead `./configure' will automatically use
-     `/usr/5bin/m4', which we believe is always available (if not then
+     '/usr/bin/m4' lacks various features needed to process '.asm'
+     files, and instead './configure' will automatically use
+     '/usr/5bin/m4', which we believe is always available (if not then
      use GNU m4).
 
 x86 CPU Types
-     `i586', `pentium' or `pentiummmx' code is good for its intended P5
+     'i586', 'pentium' or 'pentiummmx' code is good for its intended P5
      Pentium chips, but quite slow when run on Intel P6 class chips
-     (PPro, P-II, P-III).  `i386' is a better choice when making
+     (PPro, P-II, P-III).  'i386' is a better choice when making
      binaries that must run on both.
 
 x86 MMX and SSE2 Code
      If the CPU selected has MMX code but the assembler doesn't support
-     it, a warning is given and non-MMX code is used instead.  This
-     will be an inferior build, since the MMX code that's present is
-     there because it's faster than the corresponding plain integer
-     code.  The same applies to SSE2.
+     it, a warning is given and non-MMX code is used instead.  This will
+     be an inferior build, since the MMX code that's present is there
+     because it's faster than the corresponding plain integer code.  The
+     same applies to SSE2.
 
-     Old versions of `gas' don't support MMX instructions, in particular
+     Old versions of 'gas' don't support MMX instructions, in particular
      version 1.92.3 that comes with FreeBSD 2.2.8 or the more recent
      OpenBSD 3.1 doesn't.
 
-     Solaris 2.6 and 2.7 `as' generate incorrect object code for
-     register to register `movq' instructions, and so can't be used for
-     MMX code.  Install a recent `gas' if MMX code is wanted on these
+     Solaris 2.6 and 2.7 'as' generate incorrect object code for
+     register to register 'movq' instructions, and so can't be used for
+     MMX code.  Install a recent 'gas' if MMX code is wanted on these
      systems.
 
 
@@ -1035,7 +1020,7 @@ File: gmp.info,  Node: Known Build Problems,  Next: Performance optimization,  P
 2.5 Known Build Problems
 ========================
 
-You might find more up-to-date information at `http://gmplib.org/'.
+You might find more up-to-date information at <http://gmplib.org/>.
 
 Compiler link options
      The version of libtool currently in use rather aggressively strips
@@ -1046,50 +1031,50 @@ Compiler link options
 
           ./configure CC=gcc-with-my-options
 
-DJGPP (`*-*-msdosdjgpp*')
-     The DJGPP port of `bash' 2.03 is unable to run the `configure'
+DJGPP ('*-*-msdosdjgpp*')
+     The DJGPP port of 'bash' 2.03 is unable to run the 'configure'
      script, it exits silently, having died writing a preamble to
-     `config.log'.  Use `bash' 2.04 or higher.
+     'config.log'.  Use 'bash' 2.04 or higher.
 
-     `make all' was found to run out of memory during the final
-     `libgmp.la' link on one system tested, despite having 64Mb
-     available.  Running `make libgmp.la' directly helped, perhaps
+     'make all' was found to run out of memory during the final
+     'libgmp.la' link on one system tested, despite having 64Mb
+     available.  Running 'make libgmp.la' directly helped, perhaps
      recursing into the various subdirectories uses up memory.
 
-GNU binutils `strip' prior to 2.12
-     `strip' from GNU binutils 2.11 and earlier should not be used on
-     the static libraries `libgmp.a' and `libmp.a' since it will
-     discard all but the last of multiple archive members with the same
-     name, like the three versions of `init.o' in `libgmp.a'.  Binutils
-     2.12 or higher can be used successfully.
+GNU binutils 'strip' prior to 2.12
+     'strip' from GNU binutils 2.11 and earlier should not be used on
+     the static libraries 'libgmp.a' and 'libmp.a' since it will discard
+     all but the last of multiple archive members with the same name,
+     like the three versions of 'init.o' in 'libgmp.a'.  Binutils 2.12
+     or higher can be used successfully.
 
-     The shared libraries `libgmp.so' and `libmp.so' are not affected by
-     this and any version of `strip' can be used on them.
+     The shared libraries 'libgmp.so' and 'libmp.so' are not affected by
+     this and any version of 'strip' can be used on them.
 
-`make' syntax error
+'make' syntax error
      On certain versions of SCO OpenServer 5 and IRIX 6.5 the native
-     `make' is unable to handle the long dependencies list for
-     `libgmp.la'.  The symptom is a "syntax error" on the following
-     line of the top-level `Makefile'.
+     'make' is unable to handle the long dependencies list for
+     'libgmp.la'.  The symptom is a "syntax error" on the following line
+     of the top-level 'Makefile'.
 
           libgmp.la: $(libgmp_la_OBJECTS) $(libgmp_la_DEPENDENCIES)
 
      Either use GNU Make, or as a workaround remove
-     `$(libgmp_la_DEPENDENCIES)' from that line (which will make the
-     initial build work, but if any recompiling is done `libgmp.la'
+     '$(libgmp_la_DEPENDENCIES)' from that line (which will make the
+     initial build work, but if any recompiling is done 'libgmp.la'
      might not be rebuilt).
 
-MacOS X (`*-*-darwin*')
+MacOS X ('*-*-darwin*')
      Libtool currently only knows how to create shared libraries on
-     MacOS X using the native `cc' (which is a modified GCC), not a
+     MacOS X using the native 'cc' (which is a modified GCC), not a
      plain GCC.  A static-only build should work though
-     (`--disable-shared').
+     ('--disable-shared').
 
 NeXT prior to 3.3
-     The system compiler on old versions of NeXT was a massacred and
-     old GCC, even if it called itself `cc'.  This compiler cannot be
-     used to build GMP, you need to get a real GCC, and install that.
-     (NeXT may have fixed this in release 3.3 of their system.)
+     The system compiler on old versions of NeXT was a massacred and old
+     GCC, even if it called itself 'cc'.  This compiler cannot be used
+     to build GMP, you need to get a real GCC, and install that.  (NeXT
+     may have fixed this in release 3.3 of their system.)
 
 POWER and PowerPC
      Bugs in GCC 2.7.2 (and 2.6.3) mean it can't be used to compile GMP
@@ -1101,16 +1086,15 @@ Sequent Symmetry
      latter has serious bugs.
 
 Solaris 2.6
-     The system `sed' prints an error "Output line too long" when
-     libtool builds `libgmp.la'.  This doesn't seem to cause any
-     obvious ill effects, but GNU `sed' is recommended, to avoid any
-     doubt.
+     The system 'sed' prints an error "Output line too long" when
+     libtool builds 'libgmp.la'.  This doesn't seem to cause any obvious
+     ill effects, but GNU 'sed' is recommended, to avoid any doubt.
 
-Sparc Solaris 2.7 with gcc 2.95.2 in `ABI=32'
-     A shared library build of GMP seems to fail in this combination,
-     it builds but then fails the tests, apparently due to some
-     incorrect data relocations within `gmp_randinit_lc_2exp_size'.
-     The exact cause is unknown, `--disable-shared' is recommended.
+Sparc Solaris 2.7 with gcc 2.95.2 in 'ABI=32'
+     A shared library build of GMP seems to fail in this combination, it
+     builds but then fails the tests, apparently due to some incorrect
+     data relocations within 'gmp_randinit_lc_2exp_size'.  The exact
+     cause is unknown, '--disable-shared' is recommended.
 
 
 File: gmp.info,  Node: Performance optimization,  Prev: Known Build Problems,  Up: Installing GMP
@@ -1126,22 +1110,22 @@ typically doesn't matter much, since GMP uses assembly language for the
 most critical operation.
 
    In particular for long-running GMP applications, and applications
-demanding extremely large numbers, building and running the `tuneup'
-program in the `tune' subdirectory, can be important.  For example,
+demanding extremely large numbers, building and running the 'tuneup'
+program in the 'tune' subdirectory, can be important.  For example,
 
      cd tune
      make tuneup
      ./tuneup
 
-   will generate better contents for the `gmp-mparam.h' parameter file.
+   will generate better contents for the 'gmp-mparam.h' parameter file.
 
    To use the results, put the output in the file indicated in the
-`Parameters for ...' header.  Then recompile from scratch.
+'Parameters for ...' header.  Then recompile from scratch.
 
-   The `tuneup' program takes one useful parameter, `-f NNN', which
+   The 'tuneup' program takes one useful parameter, '-f NNN', which
 instructs the program how long to check FFT multiply parameters.  If
-you're going to use GMP for extremely large numbers, you may want to
-run `tuneup' with a large NNN value.
+you're going to use GMP for extremely large numbers, you may want to run
+'tuneup' with a large NNN value.
 
 
 File: gmp.info,  Node: GMP Basics,  Next: Reporting Bugs,  Prev: Installing GMP,  Up: Top
@@ -1149,9 +1133,9 @@ File: gmp.info,  Node: GMP Basics,  Next: Reporting Bugs,  Prev: Installing GMP,
 3 GMP Basics
 ************
 
-*Using functions, macros, data types, etc. not documented in this
-manual is strongly discouraged.  If you do so your application is
-guaranteed to be incompatible with future versions of GMP.*
+*Using functions, macros, data types, etc. not documented in this manual
+is strongly discouraged.  If you do so your application is guaranteed to
+be incompatible with future versions of GMP.*
 
 * Menu:
 
@@ -1178,37 +1162,37 @@ File: gmp.info,  Node: Headers and Libraries,  Next: Nomenclature and Types,  Pr
 =========================
 
 All declarations needed to use GMP are collected in the include file
-`gmp.h'.  It is designed to work with both C and C++ compilers.
+'gmp.h'.  It is designed to work with both C and C++ compilers.
 
      #include <gmp.h>
 
-   Note however that prototypes for GMP functions with `FILE *'
-parameters are only provided if `<stdio.h>' is included too.
+   Note however that prototypes for GMP functions with 'FILE *'
+parameters are only provided if '<stdio.h>' is included too.
 
      #include <stdio.h>
      #include <gmp.h>
 
-   Likewise `<stdarg.h>' (or `<varargs.h>') is required for prototypes
-with `va_list' parameters, such as `gmp_vprintf'.  And `<obstack.h>'
-for prototypes with `struct obstack' parameters, such as
-`gmp_obstack_printf', when available.
+   Likewise '<stdarg.h>' (or '<varargs.h>') is required for prototypes
+with 'va_list' parameters, such as 'gmp_vprintf'.  And '<obstack.h>' for
+prototypes with 'struct obstack' parameters, such as
+'gmp_obstack_printf', when available.
 
-   All programs using GMP must link against the `libgmp' library.  On a
-typical Unix-like system this can be done with `-lgmp', for example
+   All programs using GMP must link against the 'libgmp' library.  On a
+typical Unix-like system this can be done with '-lgmp', for example
 
      gcc myprogram.c -lgmp
 
-   GMP C++ functions are in a separate `libgmpxx' library.  This is
+   GMP C++ functions are in a separate 'libgmpxx' library.  This is
 built and installed if C++ support has been enabled (*note Build
 Options::).  For example,
 
      g++ mycxxprog.cc -lgmpxx -lgmp
 
-   GMP is built using Libtool and an application can use that to link
-if desired, *note GNU Libtool: (libtool)Top.
+   GMP is built using Libtool and an application can use that to link if
+desired, *note GNU Libtool: (libtool)Top.
 
    If GMP has been installed to a non-standard location then it may be
-necessary to use `-I' and `-L' compiler options to point to the right
+necessary to use '-I' and '-L' compiler options to point to the right
 directories, and some sort of run-time path for a shared library.
 
 
@@ -1219,7 +1203,7 @@ File: gmp.info,  Node: Nomenclature and Types,  Next: Function Classes,  Prev: H
 
 In this manual, "integer" usually means a multiple precision integer, as
 defined by the GMP library.  The C data type for such integers is
-`mpz_t'.  Here are some examples of how to declare such integers:
+'mpz_t'.  Here are some examples of how to declare such integers:
 
      mpz_t sum;
 
@@ -1228,42 +1212,42 @@ defined by the GMP library.  The C data type for such integers is
      mpz_t vec[20];
 
    "Rational number" means a multiple precision fraction.  The C data
-type for these fractions is `mpq_t'.  For example:
+type for these fractions is 'mpq_t'.  For example:
 
      mpq_t quotient;
 
    "Floating point number" or "Float" for short, is an arbitrary
 precision mantissa with a limited precision exponent.  The C data type
-for such objects is `mpf_t'.  For example:
+for such objects is 'mpf_t'.  For example:
 
      mpf_t fp;
 
    The floating point functions accept and return exponents in the C
-type `mp_exp_t'.  Currently this is usually a `long', but on some
-systems it's an `int' for efficiency.
+type 'mp_exp_t'.  Currently this is usually a 'long', but on some
+systems it's an 'int' for efficiency.
 
    A "limb" means the part of a multi-precision number that fits in a
 single machine word.  (We chose this word because a limb of the human
 body is analogous to a digit, only larger, and containing several
 digits.)  Normally a limb is 32 or 64 bits.  The C data type for a limb
-is `mp_limb_t'.
+is 'mp_limb_t'.
 
    Counts of limbs of a multi-precision number represented in the C type
-`mp_size_t'.  Currently this is normally a `long', but on some systems
-it's an `int' for efficiency, and on some systems it will be `long
-long' in the future.
+'mp_size_t'.  Currently this is normally a 'long', but on some systems
+it's an 'int' for efficiency, and on some systems it will be 'long long'
+in the future.
 
    Counts of bits of a multi-precision number are represented in the C
-type `mp_bitcnt_t'.  Currently this is always an `unsigned long', but on
-some systems it will be an `unsigned long long' in the future .
+type 'mp_bitcnt_t'.  Currently this is always an 'unsigned long', but on
+some systems it will be an 'unsigned long long' in the future .
 
    "Random state" means an algorithm selection and current state data.
-The C data type for such objects is `gmp_randstate_t'.  For example:
+The C data type for such objects is 'gmp_randstate_t'.  For example:
 
      gmp_randstate_t rstate;
 
-   Also, in general `mp_bitcnt_t' is used for bit counts and ranges, and
-`size_t' is used for byte or character counts.
+   Also, in general 'mp_bitcnt_t' is used for bit counts and ranges, and
+'size_t' is used for byte or character counts.
 
 
 File: gmp.info,  Node: Function Classes,  Next: Variable Conventions,  Prev: Nomenclature and Types,  Up: GMP Basics
@@ -1274,29 +1258,29 @@ File: gmp.info,  Node: Function Classes,  Next: Variable Conventions,  Prev: Nom
 There are six classes of functions in the GMP library:
 
   1. Functions for signed integer arithmetic, with names beginning with
-     `mpz_'.  The associated type is `mpz_t'.  There are about 150
+     'mpz_'.  The associated type is 'mpz_t'.  There are about 150
      functions in this class.  (*note Integer Functions::)
 
   2. Functions for rational number arithmetic, with names beginning with
-     `mpq_'.  The associated type is `mpq_t'.  There are about 40
+     'mpq_'.  The associated type is 'mpq_t'.  There are about 40
      functions in this class, but the integer functions can be used for
      arithmetic on the numerator and denominator separately.  (*note
      Rational Number Functions::)
 
   3. Functions for floating-point arithmetic, with names beginning with
-     `mpf_'.  The associated type is `mpf_t'.  There are about 60
+     'mpf_'.  The associated type is 'mpf_t'.  There are about 60
      functions is this class.  (*note Floating-point Functions::)
 
-  4. Functions compatible with Berkeley MP, such as `itom', `madd', and
-     `mult'.  The associated type is `MINT'.  (*note BSD Compatible
+  4. Functions compatible with Berkeley MP, such as 'itom', 'madd', and
+     'mult'.  The associated type is 'MINT'.  (*note BSD Compatible
      Functions::)
 
   5. Fast low-level functions that operate on natural numbers.  These
-     are used by the functions in the preceding groups, and you can
-     also call them directly from very time-critical user programs.
-     These functions' names begin with `mpn_'.  The associated type is
-     array of `mp_limb_t'.  There are about 30 (hard-to-use) functions
-     in this class.  (*note Low-level Functions::)
+     are used by the functions in the preceding groups, and you can also
+     call them directly from very time-critical user programs.  These
+     functions' names begin with 'mpn_'.  The associated type is array
+     of 'mp_limb_t'.  There are about 30 (hard-to-use) functions in this
+     class.  (*note Low-level Functions::)
 
   6. Miscellaneous functions.  Functions for setting up custom
      allocation and functions for generating random numbers.  (*note
@@ -1315,15 +1299,15 @@ last.
 
    GMP lets you use the same variable for both input and output in one
 call.  For example, the main function for integer multiplication,
-`mpz_mul', can be used to square `x' and put the result back in `x' with
+'mpz_mul', can be used to square 'x' and put the result back in 'x' with
 
      mpz_mul (x, x, x);
 
-   Before you can assign to a GMP variable, you need to initialize it
-by calling one of the special initialization functions.  When you're
-done with a variable, you need to clear it out, using one of the
-functions for that purpose.  Which function to use depends on the type
-of variable.  See the chapters on integer functions, rational number
+   Before you can assign to a GMP variable, you need to initialize it by
+calling one of the special initialization functions.  When you're done
+with a variable, you need to clear it out, using one of the functions
+for that purpose.  Which function to use depends on the type of
+variable.  See the chapters on integer functions, rational number
 functions, and floating-point functions for details.
 
    A variable should only be initialized once, or at least cleared
@@ -1358,17 +1342,17 @@ File: gmp.info,  Node: Parameter Conventions,  Next: Memory Management,  Prev: V
 When a GMP variable is used as a function parameter, it's effectively a
 call-by-reference, meaning if the function stores a value there it will
 change the original in the caller.  Parameters which are input-only can
-be designated `const' to provoke a compiler error or warning on
+be designated 'const' to provoke a compiler error or warning on
 attempting to modify them.
 
    When a function is going to return a GMP result, it should designate
 a parameter that it sets, like the library functions do.  More than one
 value can be returned by having more than one output parameter, again
-like the library functions.  A `return' of an `mpz_t' etc doesn't
-return the object, only a pointer, and this is almost certainly not
-what's wanted.
+like the library functions.  A 'return' of an 'mpz_t' etc doesn't return
+the object, only a pointer, and this is almost certainly not what's
+wanted.
 
-   Here's an example accepting an `mpz_t' parameter, doing a
+   Here's an example accepting an 'mpz_t' parameter, doing a
 calculation, and storing the result to the indicated parameter.
 
      void
@@ -1391,16 +1375,16 @@ calculation, and storing the result to the indicated parameter.
        return 0;
      }
 
-   `foo' works even if the mainline passes the same variable for
-`param' and `result', just like the library functions.  But sometimes
-it's tricky to make that work, and an application might not want to
-bother supporting that sort of thing.
+   'foo' works even if the mainline passes the same variable for 'param'
+and 'result', just like the library functions.  But sometimes it's
+tricky to make that work, and an application might not want to bother
+supporting that sort of thing.
 
-   For interest, the GMP types `mpz_t' etc are implemented as
+   For interest, the GMP types 'mpz_t' etc are implemented as
 one-element arrays of certain structures.  This is why declaring a
 variable creates an object with the fields GMP needs, but then using it
 as a parameter passes a pointer to the object.  Note that the actual
-fields in each `mpz_t' etc are for internal use only and should not be
+fields in each 'mpz_t' etc are for internal use only and should not be
 accessed directly by code that expects to be compatible with future GMP
 releases.
 
@@ -1410,23 +1394,23 @@ File: gmp.info,  Node: Memory Management,  Next: Reentrancy,  Prev: Parameter Co
 3.6 Memory Management
 =====================
 
-The GMP types like `mpz_t' are small, containing only a couple of sizes,
+The GMP types like 'mpz_t' are small, containing only a couple of sizes,
 and pointers to allocated data.  Once a variable is initialized, GMP
 takes care of all space allocation.  Additional space is allocated
 whenever a variable doesn't have enough.
 
-   `mpz_t' and `mpq_t' variables never reduce their allocated space.
+   'mpz_t' and 'mpq_t' variables never reduce their allocated space.
 Normally this is the best policy, since it avoids frequent reallocation.
 Applications that need to return memory to the heap at some particular
-point can use `mpz_realloc2', or clear variables no longer needed.
+point can use 'mpz_realloc2', or clear variables no longer needed.
 
-   `mpf_t' variables, in the current implementation, use a fixed amount
+   'mpf_t' variables, in the current implementation, use a fixed amount
 of space, determined by the chosen precision and allocated at
 initialization, so their size doesn't change.
 
-   All memory is allocated using `malloc' and friends by default, but
-this can be changed, see *note Custom Allocation::.  Temporary memory
-on the stack is also used (via `alloca'), but this can be changed at
+   All memory is allocated using 'malloc' and friends by default, but
+this can be changed, see *note Custom Allocation::.  Temporary memory on
+the stack is also used (via 'alloca'), but this can be changed at
 build-time if desired, see *note Build Options::.
 
 
@@ -1437,40 +1421,40 @@ File: gmp.info,  Node: Reentrancy,  Next: Useful Macros and Constants,  Prev: Me
 
 GMP is reentrant and thread-safe, with some exceptions:
 
-   * If configured with `--enable-alloca=malloc-notreentrant' (or with
-     `--enable-alloca=notreentrant' when `alloca' is not available),
+   * If configured with '--enable-alloca=malloc-notreentrant' (or with
+     '--enable-alloca=notreentrant' when 'alloca' is not available),
      then naturally GMP is not reentrant.
 
-   * `mpf_set_default_prec' and `mpf_init' use a global variable for the
-     selected precision.  `mpf_init2' can be used instead, and in the
-     C++ interface an explicit precision to the `mpf_class' constructor.
+   * 'mpf_set_default_prec' and 'mpf_init' use a global variable for the
+     selected precision.  'mpf_init2' can be used instead, and in the
+     C++ interface an explicit precision to the 'mpf_class' constructor.
 
-   * `mpz_random' and the other old random number functions use a global
+   * 'mpz_random' and the other old random number functions use a global
      random state and are hence not reentrant.  The newer random number
-     functions that accept a `gmp_randstate_t' parameter can be used
+     functions that accept a 'gmp_randstate_t' parameter can be used
      instead.
 
-   * `gmp_randinit' (obsolete) returns an error indication through a
+   * 'gmp_randinit' (obsolete) returns an error indication through a
      global variable, which is not thread safe.  Applications are
-     advised to use `gmp_randinit_default' or `gmp_randinit_lc_2exp'
+     advised to use 'gmp_randinit_default' or 'gmp_randinit_lc_2exp'
      instead.
 
-   * `mp_set_memory_functions' uses global variables to store the
+   * 'mp_set_memory_functions' uses global variables to store the
      selected memory allocation functions.
 
    * If the memory allocation functions set by a call to
-     `mp_set_memory_functions' (or `malloc' and friends by default) are
+     'mp_set_memory_functions' (or 'malloc' and friends by default) are
      not reentrant, then GMP will not be reentrant either.
 
-   * If the standard I/O functions such as `fwrite' are not reentrant
+   * If the standard I/O functions such as 'fwrite' are not reentrant
      then the GMP I/O functions using them will not be reentrant either.
 
    * It's safe for two threads to read from the same GMP variable
-     simultaneously, but it's not safe for one to read while the
-     another might be writing, nor for two threads to write
-     simultaneously.  It's not safe for two threads to generate a
-     random number from the same `gmp_randstate_t' simultaneously,
-     since this involves an update of that variable.
+     simultaneously, but it's not safe for one to read while the another
+     might be writing, nor for two threads to write simultaneously.
+     It's not safe for two threads to generate a random number from the
+     same 'gmp_randstate_t' simultaneously, since this involves an
+     update of that variable.
 
 
 File: gmp.info,  Node: Useful Macros and Constants,  Next: Compatibility with older versions,  Prev: Reentrancy,  Up: GMP Basics
@@ -1509,18 +1493,18 @@ This version of GMP is upwardly binary compatible with all 4.x and 3.x
 versions, and upwardly compatible at the source level with all 2.x
 versions, with the following exceptions.
 
-   * `mpn_gcd' had its source arguments swapped as of GMP 3.0, for
-     consistency with other `mpn' functions.
+   * 'mpn_gcd' had its source arguments swapped as of GMP 3.0, for
+     consistency with other 'mpn' functions.
 
-   * `mpf_get_prec' counted precision slightly differently in GMP 3.0
+   * 'mpf_get_prec' counted precision slightly differently in GMP 3.0
      and 3.0.1, but in 3.1 reverted to the 2.x style.
 
    There are a number of compatibility issues between GMP 1 and GMP 2
-that of course also apply when porting applications from GMP 1 to GMP
-4.  Please see the GMP 2 manual for details.
+that of course also apply when porting applications from GMP 1 to GMP 4.
+Please see the GMP 2 manual for details.
 
    The Berkeley MP compatibility library (*note BSD Compatible
-Functions::) is source and binary compatible with the standard `libmp'.
+Functions::) is source and binary compatible with the standard 'libmp'.
 
 
 File: gmp.info,  Node: Demonstration Programs,  Next: Efficiency,  Prev: Compatibility with older versions,  Up: GMP Basics
@@ -1528,8 +1512,8 @@ File: gmp.info,  Node: Demonstration Programs,  Next: Efficiency,  Prev: Compati
 3.10 Demonstration programs
 ===========================
 
-The `demos' subdirectory has some sample programs using GMP.  These
-aren't built or installed, but there's a `Makefile' with rules for them.
+The 'demos' subdirectory has some sample programs using GMP.  These
+aren't built or installed, but there's a 'Makefile' with rules for them.
 For instance,
 
      make pexpr
@@ -1537,39 +1521,32 @@ For instance,
 
 The following programs are provided
 
-   * `pexpr' is an expression evaluator, the program used on the GMP
-     web page.
-
-   * The `calc' subdirectory has a similar but simpler evaluator using
-     `lex' and `yacc'.
-
-   * The `expr' subdirectory is yet another expression evaluator, a
+   * 'pexpr' is an expression evaluator, the program used on the GMP web
+     page.
+   * The 'calc' subdirectory has a similar but simpler evaluator using
+     'lex' and 'yacc'.
+   * The 'expr' subdirectory is yet another expression evaluator, a
      library designed for ease of use within a C program.  See
-     `demos/expr/README' for more information.
-
-   * `factorize' is a Pollard-Rho factorization program.
-
-   * `isprime' is a command-line interface to the `mpz_probab_prime_p'
+     'demos/expr/README' for more information.
+   * 'factorize' is a Pollard-Rho factorization program.
+   * 'isprime' is a command-line interface to the 'mpz_probab_prime_p'
      function.
-
-   * `primes' counts or lists primes in an interval, using a sieve.
-
-   * `qcn' is an example use of `mpz_kronecker_ui' to estimate quadratic
+   * 'primes' counts or lists primes in an interval, using a sieve.
+   * 'qcn' is an example use of 'mpz_kronecker_ui' to estimate quadratic
      class numbers.
-
-   * The `perl' subdirectory is a comprehensive perl interface to GMP.
-     See `demos/perl/INSTALL' for more information.  Documentation is
-     in POD format in `demos/perl/GMP.pm'.
+   * The 'perl' subdirectory is a comprehensive perl interface to GMP.
+     See 'demos/perl/INSTALL' for more information.  Documentation is in
+     POD format in 'demos/perl/GMP.pm'.
 
    As an aside, consideration has been given at various times to some
-sort of expression evaluation within the main GMP library.  Going
-beyond something minimal quickly leads to matters like user-defined
-functions, looping, fixnums for control variables, etc, which are
-considered outside the scope of GMP (much closer to language
-interpreters or compilers, *Note Language Bindings::.)  Something
-simple for program input convenience may yet be a possibility, a
-combination of the `expr' demo and the `pexpr' tree back-end perhaps.
-But for now the above evaluators are offered as illustrations.
+sort of expression evaluation within the main GMP library.  Going beyond
+something minimal quickly leads to matters like user-defined functions,
+looping, fixnums for control variables, etc, which are considered
+outside the scope of GMP (much closer to language interpreters or
+compilers, *Note Language Bindings::.)  Something simple for program
+input convenience may yet be a possibility, a combination of the 'expr'
+demo and the 'pexpr' tree back-end perhaps.  But for now the above
+evaluators are offered as illustrations.
 
 
 File: gmp.info,  Node: Efficiency,  Next: Debugging,  Prev: Demonstration Programs,  Up: GMP Basics
@@ -1581,15 +1558,15 @@ Small Operands
      On small operands, the time for function call overheads and memory
      allocation can be significant in comparison to actual calculation.
      This is unavoidable in a general purpose variable precision
-     library, although GMP attempts to be as efficient as it can on
-     both large and small operands.
+     library, although GMP attempts to be as efficient as it can on both
+     large and small operands.
 
 Static Linking
-     On some CPUs, in particular the x86s, the static `libgmp.a' should
+     On some CPUs, in particular the x86s, the static 'libgmp.a' should
      be used for maximum speed, since the PIC code in the shared
-     `libgmp.so' will have a small overhead on each function call and
-     global data address.  For many programs this will be
-     insignificant, but for long calculations there's a gain to be had.
+     'libgmp.so' will have a small overhead on each function call and
+     global data address.  For many programs this will be insignificant,
+     but for long calculations there's a gain to be had.
 
 Initializing and Clearing
      Avoid excessive initializing and clearing of variables, since this
@@ -1601,73 +1578,72 @@ Initializing and Clearing
      integrate something like that with a garbage collector too.
 
 Reallocations
-     An `mpz_t' or `mpq_t' variable used to hold successively increasing
-     values will have its memory repeatedly `realloc'ed, which could be
+     An 'mpz_t' or 'mpq_t' variable used to hold successively increasing
+     values will have its memory repeatedly 'realloc'ed, which could be
      quite slow or could fragment memory, depending on the C library.
-     If an application can estimate the final size then `mpz_init2' or
-     `mpz_realloc2' can be called to allocate the necessary space from
+     If an application can estimate the final size then 'mpz_init2' or
+     'mpz_realloc2' can be called to allocate the necessary space from
      the beginning (*note Initializing Integers::).
 
-     It doesn't matter if a size set with `mpz_init2' or `mpz_realloc2'
-     is too small, since all functions will do a further reallocation
-     if necessary.  Badly overestimating memory required will waste
-     space though.
+     It doesn't matter if a size set with 'mpz_init2' or 'mpz_realloc2'
+     is too small, since all functions will do a further reallocation if
+     necessary.  Badly overestimating memory required will waste space
+     though.
 
-`2exp' Functions
-     It's up to an application to call functions like `mpz_mul_2exp'
-     when appropriate.  General purpose functions like `mpz_mul' make
-     no attempt to identify powers of two or other special forms,
-     because such inputs will usually be very rare and testing every
-     time would be wasteful.
+'2exp' Functions
+     It's up to an application to call functions like 'mpz_mul_2exp'
+     when appropriate.  General purpose functions like 'mpz_mul' make no
+     attempt to identify powers of two or other special forms, because
+     such inputs will usually be very rare and testing every time would
+     be wasteful.
 
-`ui' and `si' Functions
-     The `ui' functions and the small number of `si' functions exist for
+'ui' and 'si' Functions
+     The 'ui' functions and the small number of 'si' functions exist for
      convenience and should be used where applicable.  But if for
-     example an `mpz_t' contains a value that fits in an `unsigned
-     long' there's no need extract it and call a `ui' function, just
-     use the regular `mpz' function.
+     example an 'mpz_t' contains a value that fits in an 'unsigned long'
+     there's no need extract it and call a 'ui' function, just use the
+     regular 'mpz' function.
 
 In-Place Operations
-     `mpz_abs', `mpq_abs', `mpf_abs', `mpz_neg', `mpq_neg' and
-     `mpf_neg' are fast when used for in-place operations like
-     `mpz_abs(x,x)', since in the current implementation only a single
-     field of `x' needs changing.  On suitable compilers (GCC for
-     instance) this is inlined too.
-
-     `mpz_add_ui', `mpz_sub_ui', `mpf_add_ui' and `mpf_sub_ui' benefit
-     from an in-place operation like `mpz_add_ui(x,x,y)', since usually
-     only one or two limbs of `x' will need to be changed.  The same
-     applies to the full precision `mpz_add' etc if `y' is small.  If
-     `y' is big then cache locality may be helped, but that's all.
-
-     `mpz_mul' is currently the opposite, a separate destination is
-     slightly better.  A call like `mpz_mul(x,x,y)' will, unless `y' is
-     only one limb, make a temporary copy of `x' before forming the
+     'mpz_abs', 'mpq_abs', 'mpf_abs', 'mpz_neg', 'mpq_neg' and 'mpf_neg'
+     are fast when used for in-place operations like 'mpz_abs(x,x)',
+     since in the current implementation only a single field of 'x'
+     needs changing.  On suitable compilers (GCC for instance) this is
+     inlined too.
+
+     'mpz_add_ui', 'mpz_sub_ui', 'mpf_add_ui' and 'mpf_sub_ui' benefit
+     from an in-place operation like 'mpz_add_ui(x,x,y)', since usually
+     only one or two limbs of 'x' will need to be changed.  The same
+     applies to the full precision 'mpz_add' etc if 'y' is small.  If
+     'y' is big then cache locality may be helped, but that's all.
+
+     'mpz_mul' is currently the opposite, a separate destination is
+     slightly better.  A call like 'mpz_mul(x,x,y)' will, unless 'y' is
+     only one limb, make a temporary copy of 'x' before forming the
      result.  Normally that copying will only be a tiny fraction of the
      time for the multiply, so this is not a particularly important
      consideration.
 
-     `mpz_set', `mpq_set', `mpq_set_num', `mpf_set', etc, make no
+     'mpz_set', 'mpq_set', 'mpq_set_num', 'mpf_set', etc, make no
      attempt to recognise a copy of something to itself, so a call like
-     `mpz_set(x,x)' will be wasteful.  Naturally that would never be
+     'mpz_set(x,x)' will be wasteful.  Naturally that would never be
      written deliberately, but if it might arise from two pointers to
      the same object then a test to avoid it might be desirable.
 
           if (x != y)
             mpz_set (x, y);
 
-     Note that it's never worth introducing extra `mpz_set' calls just
+     Note that it's never worth introducing extra 'mpz_set' calls just
      to get in-place operations.  If a result should go to a particular
      variable then just direct it there and let GMP take care of data
      movement.
 
 Divisibility Testing (Small Integers)
-     `mpz_divisible_ui_p' and `mpz_congruent_ui_p' are the best
-     functions for testing whether an `mpz_t' is divisible by an
+     'mpz_divisible_ui_p' and 'mpz_congruent_ui_p' are the best
+     functions for testing whether an 'mpz_t' is divisible by an
      individual small integer.  They use an algorithm which is faster
-     than `mpz_tdiv_ui', but which gives no useful information about
-     the actual remainder, only whether it's zero (or a particular
-     value).
+     than 'mpz_tdiv_ui', but which gives no useful information about the
+     actual remainder, only whether it's zero (or a particular value).
 
      However when testing divisibility by several small integers, it's
      best to take a remainder modulo their product, to save
@@ -1675,16 +1651,15 @@ Divisibility Testing (Small Integers)
      is divisible by any of 23, 29 or 31 take a remainder modulo
      23*29*31 = 20677 and then test that.
 
-     The division functions like `mpz_tdiv_q_ui' which give a quotient
+     The division functions like 'mpz_tdiv_q_ui' which give a quotient
      as well as a remainder are generally a little slower than the
-     remainder-only functions like `mpz_tdiv_ui'.  If the quotient is
-     only rarely wanted then it's probably best to just take a
-     remainder and then go back and calculate the quotient if and when
-     it's wanted (`mpz_divexact_ui' can be used if the remainder is
-     zero).
+     remainder-only functions like 'mpz_tdiv_ui'.  If the quotient is
+     only rarely wanted then it's probably best to just take a remainder
+     and then go back and calculate the quotient if and when it's wanted
+     ('mpz_divexact_ui' can be used if the remainder is zero).
 
 Rational Arithmetic
-     The `mpq' functions operate on `mpq_t' values with no common
+     The 'mpq' functions operate on 'mpq_t' values with no common
      factors in the numerator and denominator.  Common factors are
      checked-for and cast out as necessary.  In general, cancelling
      factors every time is the best approach since it minimizes the
@@ -1699,14 +1674,14 @@ Rational Arithmetic
      cancellation will be possible, and so canonicalization can be left
      to the end.
 
-     The `mpq_numref' and `mpq_denref' macros give access to the
+     The 'mpq_numref' and 'mpq_denref' macros give access to the
      numerator and denominator to do things outside the scope of the
-     supplied `mpq' functions.  *Note Applying Integer Functions::.
+     supplied 'mpq' functions.  *Note Applying Integer Functions::.
 
-     The canonical form for rationals allows mixed-type `mpq_t' and
+     The canonical form for rationals allows mixed-type 'mpq_t' and
      integer additions or subtractions to be done directly with
      multiples of the denominator.  This will be somewhat faster than
-     `mpq_add'.  For example,
+     'mpq_add'.  For example,
 
           /* mpq increment */
           mpz_add (mpq_numref(q), mpq_numref(q), mpq_denref(q));
@@ -1718,7 +1693,7 @@ Rational Arithmetic
           mpz_submul (mpq_numref(q), mpq_denref(q), z);
 
 Number Sequences
-     Functions like `mpz_fac_ui', `mpz_fib_ui' and `mpz_bin_uiui' are
+     Functions like 'mpz_fac_ui', 'mpz_fib_ui' and 'mpz_bin_uiui' are
      designed for calculating isolated values.  If a range of values is
      wanted it's probably best to call to get a starting point and
      iterate from there.
@@ -1743,113 +1718,112 @@ File: gmp.info,  Node: Debugging,  Next: Profiling,  Prev: Efficiency,  Up: GMP
 Stack Overflow
      Depending on the system, a segmentation violation or bus error
      might be the only indication of stack overflow.  See
-     `--enable-alloca' choices in *note Build Options::, for how to
+     '--enable-alloca' choices in *note Build Options::, for how to
      address this.
 
-     In new enough versions of GCC, `-fstack-check' may be able to
+     In new enough versions of GCC, '-fstack-check' may be able to
      ensure an overflow is recognised by the system before too much
-     damage is done, or `-fstack-limit-symbol' or
-     `-fstack-limit-register' may be able to add checking if the system
-     itself doesn't do any (*note Options for Code Generation:
-     (gcc)Code Gen Options.).  These options must be added to the
-     `CFLAGS' used in the GMP build (*note Build Options::), adding
-     them just to an application will have no effect.  Note also
-     they're a slowdown, adding overhead to each function call and each
-     stack allocation.
+     damage is done, or '-fstack-limit-symbol' or
+     '-fstack-limit-register' may be able to add checking if the system
+     itself doesn't do any (*note Options for Code Generation: (gcc)Code
+     Gen Options.).  These options must be added to the 'CFLAGS' used in
+     the GMP build (*note Build Options::), adding them just to an
+     application will have no effect.  Note also they're a slowdown,
+     adding overhead to each function call and each stack allocation.
 
 Heap Problems
      The most likely cause of application problems with GMP is heap
-     corruption.  Failing to `init' GMP variables will have
+     corruption.  Failing to 'init' GMP variables will have
      unpredictable effects, and corruption arising elsewhere in a
      program may well affect GMP.  Initializing GMP variables more than
      once or failing to clear them will cause memory leaks.
 
-     In all such cases a `malloc' debugger is recommended.  On a GNU or
-     BSD system the standard C library `malloc' has some diagnostic
+     In all such cases a 'malloc' debugger is recommended.  On a GNU or
+     BSD system the standard C library 'malloc' has some diagnostic
      facilities, see *note Allocation Debugging: (libc)Allocation
-     Debugging, or `man 3 malloc'.  Other possibilities, in no
+     Debugging, or 'man 3 malloc'.  Other possibilities, in no
      particular order, include
 
-          `http://www.inf.ethz.ch/personal/biere/projects/ccmalloc/'
-          `http://dmalloc.com/'
-          `http://www.perens.com/FreeSoftware/'  (electric fence)
-          `http://packages.debian.org/stable/devel/fda'
-          `http://www.gnupdate.org/components/leakbug/'
-          `http://people.redhat.com/~otaylor/memprof/'
-          `http://www.cbmamiga.demon.co.uk/mpatrol/'
+          <http://www.inf.ethz.ch/personal/biere/projects/ccmalloc/>
+          <http://dmalloc.com/>
+          <http://www.perens.com/FreeSoftware/>  (electric fence)
+          <http://packages.debian.org/stable/devel/fda>
+          <http://www.gnupdate.org/components/leakbug/>
+          <http://people.redhat.com/~otaylor/memprof/>
+          <http://www.cbmamiga.demon.co.uk/mpatrol/>
 
-     The GMP default allocation routines in `memory.c' also have a
-     simple sentinel scheme which can be enabled with `#define DEBUG'
-     in that file.  This is mainly designed for detecting buffer
-     overruns during GMP development, but might find other uses.
+     The GMP default allocation routines in 'memory.c' also have a
+     simple sentinel scheme which can be enabled with '#define DEBUG' in
+     that file.  This is mainly designed for detecting buffer overruns
+     during GMP development, but might find other uses.
 
 Stack Backtraces
      On some systems the compiler options GMP uses by default can
      interfere with debugging.  In particular on x86 and 68k systems
-     `-fomit-frame-pointer' is used and this generally inhibits stack
+     '-fomit-frame-pointer' is used and this generally inhibits stack
      backtracing.  Recompiling without such options may help while
      debugging, though the usual caveats about it potentially moving a
      memory problem or hiding a compiler bug will apply.
 
 GDB, the GNU Debugger
-     A sample `.gdbinit' is included in the distribution, showing how
-     to call some undocumented dump functions to print GMP variables
-     from within GDB.  Note that these functions shouldn't be used in
-     final application code since they're undocumented and may be
-     subject to incompatible changes in future versions of GMP.
+     A sample '.gdbinit' is included in the distribution, showing how to
+     call some undocumented dump functions to print GMP variables from
+     within GDB.  Note that these functions shouldn't be used in final
+     application code since they're undocumented and may be subject to
+     incompatible changes in future versions of GMP.
 
 Source File Paths
      GMP has multiple source files with the same name, in different
-     directories.  For example `mpz', `mpq' and `mpf' each have an
-     `init.c'.  If the debugger can't already determine the right one
-     it may help to build with absolute paths on each C file.  One way
-     to do that is to use a separate object directory with an absolute
-     path to the source directory.
+     directories.  For example 'mpz', 'mpq' and 'mpf' each have an
+     'init.c'.  If the debugger can't already determine the right one it
+     may help to build with absolute paths on each C file.  One way to
+     do that is to use a separate object directory with an absolute path
+     to the source directory.
 
           cd /my/build/dir
           /my/source/dir/gmp-5.0.2/configure
 
-     This works via `VPATH', and might require GNU `make'.  Alternately
-     it might be possible to change the `.c.lo' rules appropriately.
+     This works via 'VPATH', and might require GNU 'make'.  Alternately
+     it might be possible to change the '.c.lo' rules appropriately.
 
 Assertion Checking
-     The build option `--enable-assert' is available to add some
+     The build option '--enable-assert' is available to add some
      consistency checks to the library (see *note Build Options::).
      These are likely to be of limited value to most applications.
-     Assertion failures are just as likely to indicate memory
-     corruption as a library or compiler bug.
+     Assertion failures are just as likely to indicate memory corruption
+     as a library or compiler bug.
 
-     Applications using the low-level `mpn' functions, however, will
-     benefit from `--enable-assert' since it adds checks on the
+     Applications using the low-level 'mpn' functions, however, will
+     benefit from '--enable-assert' since it adds checks on the
      parameters of most such functions, many of which have subtle
      restrictions on their usage.  Note however that only the generic C
-     code has checks, not the assembly code, so CPU `none' should be
+     code has checks, not the assembly code, so CPU 'none' should be
      used for maximum checking.
 
 Temporary Memory Checking
-     The build option `--enable-alloca=debug' arranges that each block
+     The build option '--enable-alloca=debug' arranges that each block
      of temporary memory in GMP is allocated with a separate call to
-     `malloc' (or the allocation function set with
-     `mp_set_memory_functions').
+     'malloc' (or the allocation function set with
+     'mp_set_memory_functions').
 
      This can help a malloc debugger detect accesses outside the
-     intended bounds, or detect memory not released.  In a normal
-     build, on the other hand, temporary memory is allocated in blocks
-     which GMP divides up for its own use, or may be allocated with a
-     compiler builtin `alloca' which will go nowhere near any malloc
-     debugger hooks.
+     intended bounds, or detect memory not released.  In a normal build,
+     on the other hand, temporary memory is allocated in blocks which
+     GMP divides up for its own use, or may be allocated with a compiler
+     builtin 'alloca' which will go nowhere near any malloc debugger
+     hooks.
 
 Maximum Debuggability
-     To summarize the above, a GMP build for maximum debuggability
-     would be
+     To summarize the above, a GMP build for maximum debuggability would
+     be
 
           ./configure --disable-shared --enable-assert \
             --enable-alloca=debug --host=none CFLAGS=-g
 
-     For C++, add `--enable-cxx CXXFLAGS=-g'.
+     For C++, add '--enable-cxx CXXFLAGS=-g'.
 
 Checker
-     The GCC checker (`http://savannah.nongnu.org/projects/checker/')
+     The GCC checker (<http://savannah.nongnu.org/projects/checker/>)
      can be used with GMP.  It contains a stub library which means GMP
      applications compiled with checker can use a normal GMP build.
 
@@ -1858,13 +1832,13 @@ Checker
 
           ./configure --host=none-pc-linux-gnu CC=checkergcc
 
-     `--host=none' must be used, since the GMP assembly code doesn't
+     '--host=none' must be used, since the GMP assembly code doesn't
      support the checking scheme.  The GMP C++ features cannot be used,
      since current versions of checker (0.9.9.1) don't yet support the
      standard C++ library.
 
 Valgrind
-     The valgrind program (`http://valgrind.org/') is a memory checker
+     The valgrind program (<http://valgrind.org/>) is a memory checker
      for x86s.  It translates and emulates machine instructions to do
      strong checks for uninitialized data (at the level of individual
      bits), memory accesses through bad pointers, and memory leaks.
@@ -1872,7 +1846,7 @@ Valgrind
      Recent versions of Valgrind are getting support for MMX and
      SSE/SSE2 instructions, for past versions GMP will need to be
      configured not to use those, ie. for an x86 without them (for
-     instance plain `i486').
+     instance plain 'i486').
 
 Other Problems
      Any suspected bug in GMP itself should be isolated to make sure
@@ -1888,22 +1862,22 @@ Running a program under a profiler is a good way to find where it's
 spending most time and where improvements can be best sought.  The
 profiling choices for a GMP build are as follows.
 
-`--disable-profiling'
+'--disable-profiling'
      The default is to add nothing special for profiling.
 
      It should be possible to just compile the mainline of a program
-     with `-p' and use `prof' to get a profile consisting of
-     timer-based sampling of the program counter.  Most of the GMP
-     assembly code has the necessary symbol information.
+     with '-p' and use 'prof' to get a profile consisting of timer-based
+     sampling of the program counter.  Most of the GMP assembly code has
+     the necessary symbol information.
 
      This approach has the advantage of minimizing interference with
-     normal program operation, but on most systems the resolution of
-     the sampling is quite low (10 milliseconds for instance),
-     requiring long runs to get accurate information.
+     normal program operation, but on most systems the resolution of the
+     sampling is quite low (10 milliseconds for instance), requiring
+     long runs to get accurate information.
 
-`--enable-profiling=prof'
-     Build with support for the system `prof', which means `-p' added
-     to the `CFLAGS'.
+'--enable-profiling=prof'
+     Build with support for the system 'prof', which means '-p' added to
+     the 'CFLAGS'.
 
      This provides call counting in addition to program counter
      sampling, which allows the most frequently called routines to be
@@ -1912,40 +1886,40 @@ profiling choices for a GMP build are as follows.
 
      The x86 assembly code has support for this option, but on other
      processors the assembly routines will be as if compiled without
-     `-p' and therefore won't appear in the call counts.
+     '-p' and therefore won't appear in the call counts.
 
-     On some systems, such as GNU/Linux, `-p' in fact means `-pg' and in
-     this case `--enable-profiling=gprof' described below should be used
+     On some systems, such as GNU/Linux, '-p' in fact means '-pg' and in
+     this case '--enable-profiling=gprof' described below should be used
      instead.
 
-`--enable-profiling=gprof'
-     Build with support for `gprof', which means `-pg' added to the
-     `CFLAGS'.
+'--enable-profiling=gprof'
+     Build with support for 'gprof', which means '-pg' added to the
+     'CFLAGS'.
 
      This provides call graph construction in addition to call counting
      and program counter sampling, which makes it possible to count
      calls coming from different locations.  For example the number of
-     calls to `mpn_mul' from `mpz_mul' versus the number from
-     `mpf_mul'.  The program counter sampling is still flat though, so
-     only a total time in `mpn_mul' would be accumulated, not a
-     separate amount for each call site.
+     calls to 'mpn_mul' from 'mpz_mul' versus the number from 'mpf_mul'.
+     The program counter sampling is still flat though, so only a total
+     time in 'mpn_mul' would be accumulated, not a separate amount for
+     each call site.
 
      The x86 assembly code has support for this option, but on other
      processors the assembly routines will be as if compiled without
-     `-pg' and therefore not be included in the call counts.
+     '-pg' and therefore not be included in the call counts.
 
-     On x86 and m68k systems `-pg' and `-fomit-frame-pointer' are
+     On x86 and m68k systems '-pg' and '-fomit-frame-pointer' are
      incompatible, so the latter is omitted from the default flags in
      that case, which might result in poorer code generation.
 
-     Incidentally, it should be possible to use the `gprof' program
-     with a plain `--enable-profiling=prof' build.  But in that case
-     only the `gprof -p' flat profile and call counts can be expected
-     to be valid, not the `gprof -q' call graph.
+     Incidentally, it should be possible to use the 'gprof' program with
+     a plain '--enable-profiling=prof' build.  But in that case only the
+     'gprof -p' flat profile and call counts can be expected to be
+     valid, not the 'gprof -q' call graph.
 
-`--enable-profiling=instrument'
-     Build with the GCC option `-finstrument-functions' added to the
-     `CFLAGS' (*note Options for Code Generation: (gcc)Code Gen
+'--enable-profiling=instrument'
+     Build with the GCC option '-finstrument-functions' added to the
+     'CFLAGS' (*note Options for Code Generation: (gcc)Code Gen
      Options.).
 
      This inserts special instrumenting calls at the start and end of
@@ -1955,9 +1929,9 @@ profiling choices for a GMP build are as follows.
      This instrumenting is not normally a standard system feature and
      will require support from an external library, such as
 
-          `http://sourceforge.net/projects/fnccheck/'
+          <http://sourceforge.net/projects/fnccheck/>
 
-     This should be included in `LIBS' during the GMP configure so that
+     This should be included in 'LIBS' during the GMP configure so that
      test programs will link.  For example,
 
           ./configure --enable-profiling=instrument LIBS=-lfc
@@ -1967,9 +1941,9 @@ profiling choices for a GMP build are as follows.
      this case it's only necessary to ensure the correct library is
      added when linking an application.
 
-     The x86 assembly code supports this option, but on other
-     processors the assembly routines will be as if compiled without
-     `-finstrument-functions' meaning time spent in them will
+     The x86 assembly code supports this option, but on other processors
+     the assembly routines will be as if compiled without
+     '-finstrument-functions' meaning time spent in them will
      effectively be attributed to their caller.
 
 
@@ -1980,12 +1954,12 @@ File: gmp.info,  Node: Autoconf,  Next: Emacs,  Prev: Profiling,  Up: GMP Basics
 
 Autoconf based applications can easily check whether GMP is installed.
 The only thing to be noted is that GMP library symbols from version 3
-onwards have prefixes like `__gmpz'.  The following therefore would be
-a simple test,
+onwards have prefixes like '__gmpz'.  The following therefore would be a
+simple test,
 
      AC_CHECK_LIB(gmp, __gmpz_init)
 
-   This just uses the default `AC_CHECK_LIB' actions for found or not
+   This just uses the default 'AC_CHECK_LIB' actions for found or not
 found, but an application that must have GMP would want to generate an
 error if not found.  For example,
 
@@ -1993,15 +1967,15 @@ error if not found.  For example,
        [AC_MSG_ERROR([GNU MP not found, see http://gmplib.org/])])
 
    If functions added in some particular version of GMP are required,
-then one of those can be used when checking.  For example `mpz_mul_si'
+then one of those can be used when checking.  For example 'mpz_mul_si'
 was added in GMP 3.1,
 
      AC_CHECK_LIB(gmp, __gmpz_mul_si, ,
        [AC_MSG_ERROR(
        [GNU MP not found, or not 3.1 or up, see http://gmplib.org/])])
 
-   An alternative would be to test the version number in `gmp.h' using
-say `AC_EGREP_CPP'.  That would make it possible to test the exact
+   An alternative would be to test the version number in 'gmp.h' using
+say 'AC_EGREP_CPP'.  That would make it possible to test the exact
 version, if some particular sub-minor release is known to be necessary.
 
    In general it's recommended that applications should simply demand a
@@ -2009,11 +1983,11 @@ new enough GMP rather than trying to provide supplements for features
 not available in past versions.
 
    Occasionally an application will need or want to know the size of a
-type at configuration or preprocessing time, not just with `sizeof' in
-the code.  This can be done in the normal way with `mp_limb_t' etc, but
-GMP 4.0 or up is best for this, since prior versions needed certain
-`-D' defines on systems using a `long long' limb.  The following would
-suit Autoconf 2.50 or up,
+type at configuration or preprocessing time, not just with 'sizeof' in
+the code.  This can be done in the normal way with 'mp_limb_t' etc, but
+GMP 4.0 or up is best for this, since prior versions needed certain '-D'
+defines on systems using a 'long long' limb.  The following would suit
+Autoconf 2.50 or up,
 
      AC_CHECK_SIZEOF(mp_limb_t, , [#include <gmp.h>])
 
@@ -2023,12 +1997,12 @@ File: gmp.info,  Node: Emacs,  Prev: Autoconf,  Up: GMP Basics
 3.15 Emacs
 ==========
 
-<C-h C-i> (`info-lookup-symbol') is a good way to find documentation on
+<C-h C-i> ('info-lookup-symbol') is a good way to find documentation on
 C functions while editing (*note Info Documentation Lookup: (emacs)Info
 Lookup.).
 
    The GMP manual can be included in such lookups by putting the
-following in your `.emacs',
+following in your '.emacs',
 
      (eval-after-load "info-look"
        '(let ((mode-value (assoc 'c-mode (assoc 'symbol info-lookup-alist))))
@@ -2042,14 +2016,14 @@ File: gmp.info,  Node: Reporting Bugs,  Next: Integer Functions,  Prev: GMP Basi
 4 Reporting Bugs
 ****************
 
-If you think you have found a bug in the GMP library, please
-investigate it and report it.  We have made this library available to
-you, and it is not too much to ask you to report the bugs you find.
+If you think you have found a bug in the GMP library, please investigate
+it and report it.  We have made this library available to you, and it is
+not too much to ask you to report the bugs you find.
 
    Before you report a bug, check it's not already addressed in *note
-Known Build Problems::, or perhaps *note Notes for Particular
-Systems::.  You may also want to check `http://gmplib.org/' for patches
-for this release.
+Known Build Problems::, or perhaps *note Notes for Particular Systems::.
+You may also want to check <http://gmplib.org/> for patches for this
+release.
 
    Please include the following in any report,
 
@@ -2062,27 +2036,27 @@ for this release.
      what way.  If you get a crash, say so.
 
    * If you get a crash, include a stack backtrace from the debugger if
-     it's informative (`where' in `gdb', or `$C' in `adb').
+     it's informative ('where' in 'gdb', or '$C' in 'adb').
 
-   * Please do not send core dumps, executables or `strace's.
+   * Please do not send core dumps, executables or 'strace's.
 
    * The configuration options you used when building GMP, if any.
 
-   * The name of the compiler and its version.  For `gcc', get the
-     version with `gcc -v', otherwise perhaps `what `which cc`', or
+   * The name of the compiler and its version.  For 'gcc', get the
+     version with 'gcc -v', otherwise perhaps 'what `which cc`', or
      similar.
 
-   * The output from running `uname -a'.
+   * The output from running 'uname -a'.
 
-   * The output from running `./config.guess', and from running
-     `./configfsf.guess' (might be the same).
+   * The output from running './config.guess', and from running
+     './configfsf.guess' (might be the same).
 
-   * If the bug is related to `configure', then the compressed contents
-     of `config.log'.
+   * If the bug is related to 'configure', then the compressed contents
+     of 'config.log'.
 
-   * If the bug is related to an `asm' file not assembling, then the
-     contents of `config.m4' and the offending line or lines from the
-     temporary `mpn/tmp-<file>.s'.
+   * If the bug is related to an 'asm' file not assembling, then the
+     contents of 'config.m4' and the offending line or lines from the
+     temporary 'mpn/tmp-<file>.s'.
 
    Please make an effort to produce a self-contained report, with
 something definite that can be tested or debugged.  Vague queries or
@@ -2094,8 +2068,8 @@ in the compiler; the GMP code tends to explore interesting corners in
 compilers.
 
    If your bug report is good, we will do our best to help you get a
-corrected version of the library; if the bug report is poor, we won't
-do anything about it (except maybe ask you to send a better report).
+corrected version of the library; if the bug report is poor, we won't do
+anything about it (except maybe ask you to send a better report).
 
    Send your report to: <gmp-bugs@gmplib.org>.
 
@@ -2110,9 +2084,9 @@ File: gmp.info,  Node: Integer Functions,  Next: Rational Number Functions,  Pre
 *******************
 
 This chapter describes the GMP functions for performing integer
-arithmetic.  These functions start with the prefix `mpz_'.
+arithmetic.  These functions start with the prefix 'mpz_'.
 
-   GMP integers are stored in objects of type `mpz_t'.
+   GMP integers are stored in objects of type 'mpz_t'.
 
 * Menu:
 
@@ -2140,7 +2114,7 @@ File: gmp.info,  Node: Initializing Integers,  Next: Assigning Integers,  Prev:
 ============================
 
 The functions for integer arithmetic assume that all integer objects are
-initialized.  You do that by calling the function `mpz_init'.  For
+initialized.  You do that by calling the function 'mpz_init'.  For
 example,
 
      {
@@ -2162,26 +2136,26 @@ object is initialized.
      Initialize X, and set its value to 0.
 
  -- Function: void mpz_inits (mpz_t X, ...)
-     Initialize a NULL-terminated list of `mpz_t' variables, and set
+     Initialize a NULL-terminated list of 'mpz_t' variables, and set
      their values to 0.
 
  -- Function: void mpz_init2 (mpz_t X, mp_bitcnt_t N)
      Initialize X, with space for N-bit numbers, and set its value to 0.
-     Calling this function instead of `mpz_init' or `mpz_inits' is never
+     Calling this function instead of 'mpz_init' or 'mpz_inits' is never
      necessary; reallocation is handled automatically by GMP when
      needed.
 
      N is only the initial space, X will grow automatically in the
      normal way, if necessary, for subsequent values stored.
-     `mpz_init2' makes it possible to avoid such reallocations if a
+     'mpz_init2' makes it possible to avoid such reallocations if a
      maximum size is known in advance.
 
  -- Function: void mpz_clear (mpz_t X)
-     Free the space occupied by X.  Call this function for all `mpz_t'
+     Free the space occupied by X.  Call this function for all 'mpz_t'
      variables when you are done with them.
 
  -- Function: void mpz_clears (mpz_t X, ...)
-     Free the space occupied by a NULL-terminated list of `mpz_t'
+     Free the space occupied by a NULL-terminated list of 'mpz_t'
      variables.
 
  -- Function: void mpz_realloc2 (mpz_t X, mp_bitcnt_t N)
@@ -2189,8 +2163,8 @@ object is initialized.
      preserved if it fits, or is set to 0 if not.
 
      Calling this function is never necessary; reallocation is handled
-     automatically by GMP when needed.  But this function can be used
-     to increase the space for a variable in order to avoid repeated
+     automatically by GMP when needed.  But this function can be used to
+     increase the space for a variable in order to avoid repeated
      automatic reallocations, or to decrease it to give memory back to
      the heap.
 
@@ -2200,8 +2174,8 @@ File: gmp.info,  Node: Assigning Integers,  Next: Simultaneous Integer Init & As
 5.2 Assignment Functions
 ========================
 
-These functions assign new values to already initialized integers
-(*note Initializing Integers::).
+These functions assign new values to already initialized integers (*note
+Initializing Integers::).
 
  -- Function: void mpz_set (mpz_t ROP, mpz_t OP)
  -- Function: void mpz_set_ui (mpz_t ROP, unsigned long int OP)
@@ -2211,7 +2185,7 @@ These functions assign new values to already initialized integers
  -- Function: void mpz_set_f (mpz_t ROP, mpf_t OP)
      Set the value of ROP from OP.
 
-     `mpz_set_d', `mpz_set_q' and `mpz_set_f' truncate OP to make it an
+     'mpz_set_d', 'mpz_set_q' and 'mpz_set_f' truncate OP to make it an
      integer.
 
  -- Function: int mpz_set_str (mpz_t ROP, char *STR, int BASE)
@@ -2219,13 +2193,13 @@ These functions assign new values to already initialized integers
      BASE.  White space is allowed in the string, and is simply ignored.
 
      The BASE may vary from 2 to 62, or if BASE is 0, then the leading
-     characters are used: `0x' and `0X' for hexadecimal, `0b' and `0B'
-     for binary, `0' for octal, or decimal otherwise.
+     characters are used: '0x' and '0X' for hexadecimal, '0b' and '0B'
+     for binary, '0' for octal, or decimal otherwise.
 
      For bases up to 36, case is ignored; upper-case and lower-case
-     letters have the same value.  For bases 37 to 62, upper-case
-     letter represent the usual 10..35 while lower-case letter
-     represent 36..61.
+     letters have the same value.  For bases 37 to 62, upper-case letter
+     represent the usual 10..35 while lower-case letter represent
+     36..61.
 
      This function returns 0 if the entire string is a valid number in
      base BASE.  Otherwise it returns -1.
@@ -2241,7 +2215,7 @@ File: gmp.info,  Node: Simultaneous Integer Init & Assign,  Next: Converting Int
 
 For convenience, GMP provides a parallel series of initialize-and-set
 functions which initialize the output and then store the value there.
-These functions' names have the form `mpz_init_set...'
+These functions' names have the form 'mpz_init_set...'
 
    Here is an example of using one:
 
@@ -2254,10 +2228,10 @@ These functions' names have the form `mpz_init_set...'
        mpz_clear (pie);
      }
 
-Once the integer has been initialized by any of the `mpz_init_set...'
+Once the integer has been initialized by any of the 'mpz_init_set...'
 functions, it can be used as the source or destination operand for the
-ordinary integer functions.  Don't use an initialize-and-set function
-on a variable already initialized!
+ordinary integer functions.  Don't use an initialize-and-set function on
+a variable already initialized!
 
  -- Function: void mpz_init_set (mpz_t ROP, mpz_t OP)
  -- Function: void mpz_init_set_ui (mpz_t ROP, unsigned long int OP)
@@ -2267,12 +2241,12 @@ on a variable already initialized!
      from OP.
 
  -- Function: int mpz_init_set_str (mpz_t ROP, char *STR, int BASE)
-     Initialize ROP and set its value like `mpz_set_str' (see its
+     Initialize ROP and set its value like 'mpz_set_str' (see its
      documentation above for details).
 
      If the string is a correct base BASE number, the function returns
-     0; if an error occurs it returns -1.  ROP is initialized even if
-     an error occurs.  (I.e., you have to call `mpz_clear' for it.)
+     0; if an error occurs it returns -1.  ROP is initialized even if an
+     error occurs.  (I.e., you have to call 'mpz_clear' for it.)
 
 
 File: gmp.info,  Node: Converting Integers,  Next: Integer Arithmetic,  Prev: Simultaneous Integer Init & Assign,  Up: Integer Functions
@@ -2280,28 +2254,28 @@ File: gmp.info,  Node: Converting Integers,  Next: Integer Arithmetic,  Prev: Si
 5.4 Conversion Functions
 ========================
 
-This section describes functions for converting GMP integers to
-standard C types.  Functions for converting _to_ GMP integers are
-described in *note Assigning Integers:: and *note I/O of Integers::.
+This section describes functions for converting GMP integers to standard
+C types.  Functions for converting _to_ GMP integers are described in
+*note Assigning Integers:: and *note I/O of Integers::.
 
  -- Function: unsigned long int mpz_get_ui (mpz_t OP)
-     Return the value of OP as an `unsigned long'.
+     Return the value of OP as an 'unsigned long'.
 
-     If OP is too big to fit an `unsigned long' then just the least
+     If OP is too big to fit an 'unsigned long' then just the least
      significant bits that do fit are returned.  The sign of OP is
      ignored, only the absolute value is used.
 
  -- Function: signed long int mpz_get_si (mpz_t OP)
-     If OP fits into a `signed long int' return the value of OP.
+     If OP fits into a 'signed long int' return the value of OP.
      Otherwise return the least significant part of OP, with the same
      sign as OP.
 
-     If OP is too big to fit in a `signed long int', the returned
-     result is probably not very useful.  To find out if the value will
-     fit, use the function `mpz_fits_slong_p'.
+     If OP is too big to fit in a 'signed long int', the returned result
+     is probably not very useful.  To find out if the value will fit,
+     use the function 'mpz_fits_slong_p'.
 
  -- Function: double mpz_get_d (mpz_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
+     Convert OP to a 'double', truncating if necessary (ie. rounding
      towards zero).
 
      If the exponent from the conversion is too big, the result is
@@ -2309,15 +2283,15 @@ described in *note Assigning Integers:: and *note I/O of Integers::.
      hardware overflow trap may or may not occur.
 
  -- Function: double mpz_get_d_2exp (signed long int *EXP, mpz_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
+     Convert OP to a 'double', truncating if necessary (ie. rounding
      towards zero), and returning the exponent separately.
 
      The return value is in the range 0.5<=abs(D)<1 and the exponent is
-     stored to `*EXP'.  D * 2^EXP is the (truncated) OP value.  If OP
-     is zero, the return is 0.0 and 0 is stored to `*EXP'.
+     stored to '*EXP'.  D * 2^EXP is the (truncated) OP value.  If OP is
+     zero, the return is 0.0 and 0 is stored to '*EXP'.
 
-     This is similar to the standard C `frexp' function (*note
-     Normalization Functions: (libc)Normalization Functions.).
+     This is similar to the standard C 'frexp' function (*note
+     (libc)Normalization Functions::).
 
  -- Function: char * mpz_get_str (char *STR, int BASE, mpz_t OP)
      Convert OP to a string of digits in base BASE.  The base argument
@@ -2325,16 +2299,16 @@ described in *note Assigning Integers:: and *note I/O of Integers::.
 
      For BASE in the range 2..36, digits and lower-case letters are
      used; for -2..-36, digits and upper-case letters are used; for
-     37..62, digits, upper-case letters, and lower-case letters (in
-     that significance order) are used.
+     37..62, digits, upper-case letters, and lower-case letters (in that
+     significance order) are used.
 
-     If STR is `NULL', the result string is allocated using the current
+     If STR is 'NULL', the result string is allocated using the current
      allocation function (*note Custom Allocation::).  The block will be
-     `strlen(str)+1' bytes, that being exactly enough for the string and
+     'strlen(str)+1' bytes, that being exactly enough for the string and
      null-terminator.
 
-     If STR is not `NULL', it should point to a block of storage large
-     enough for the result, that being `mpz_sizeinbase (OP, BASE) + 2'.
+     If STR is not 'NULL', it should point to a block of storage large
+     enough for the result, that being 'mpz_sizeinbase (OP, BASE) + 2'.
      The two extra bytes are for a possible minus sign, and the
      null-terminator.
 
@@ -2391,15 +2365,16 @@ File: gmp.info,  Node: Integer Division,  Next: Integer Exponentiation,  Prev: I
 5.6 Division Functions
 ======================
 
-Division is undefined if the divisor is zero.  Passing a zero divisor
-to the division or modulo functions (including the modular powering
-functions `mpz_powm' and `mpz_powm_ui'), will cause an intentional
+Division is undefined if the divisor is zero.  Passing a zero divisor to
+the division or modulo functions (including the modular powering
+functions 'mpz_powm' and 'mpz_powm_ui'), will cause an intentional
 division by zero.  This lets a program handle arithmetic exceptions in
-these functions the same way as for normal C `int' arithmetic.
+these functions the same way as for normal C 'int' arithmetic.
 
  -- Function: void mpz_cdiv_q (mpz_t Q, mpz_t N, mpz_t D)
  -- Function: void mpz_cdiv_r (mpz_t R, mpz_t N, mpz_t D)
  -- Function: void mpz_cdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
+
  -- Function: unsigned long int mpz_cdiv_q_ui (mpz_t Q, mpz_t N,
           unsigned long int D)
  -- Function: unsigned long int mpz_cdiv_r_ui (mpz_t R, mpz_t N,
@@ -2408,12 +2383,14 @@ these functions the same way as for normal C `int' arithmetic.
           mpz_t N, unsigned long int D)
  -- Function: unsigned long int mpz_cdiv_ui (mpz_t N,
           unsigned long int D)
+
  -- Function: void mpz_cdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
  -- Function: void mpz_cdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)
 
  -- Function: void mpz_fdiv_q (mpz_t Q, mpz_t N, mpz_t D)
  -- Function: void mpz_fdiv_r (mpz_t R, mpz_t N, mpz_t D)
  -- Function: void mpz_fdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
+
  -- Function: unsigned long int mpz_fdiv_q_ui (mpz_t Q, mpz_t N,
           unsigned long int D)
  -- Function: unsigned long int mpz_fdiv_r_ui (mpz_t R, mpz_t N,
@@ -2422,12 +2399,14 @@ these functions the same way as for normal C `int' arithmetic.
           mpz_t N, unsigned long int D)
  -- Function: unsigned long int mpz_fdiv_ui (mpz_t N,
           unsigned long int D)
+
  -- Function: void mpz_fdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
  -- Function: void mpz_fdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)
 
  -- Function: void mpz_tdiv_q (mpz_t Q, mpz_t N, mpz_t D)
  -- Function: void mpz_tdiv_r (mpz_t R, mpz_t N, mpz_t D)
  -- Function: void mpz_tdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
+
  -- Function: unsigned long int mpz_tdiv_q_ui (mpz_t Q, mpz_t N,
           unsigned long int D)
  -- Function: unsigned long int mpz_tdiv_r_ui (mpz_t R, mpz_t N,
@@ -2436,59 +2415,61 @@ these functions the same way as for normal C `int' arithmetic.
           mpz_t N, unsigned long int D)
  -- Function: unsigned long int mpz_tdiv_ui (mpz_t N,
           unsigned long int D)
+
  -- Function: void mpz_tdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
  -- Function: void mpz_tdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)
 
+
      Divide N by D, forming a quotient Q and/or remainder R.  For the
-     `2exp' functions, D=2^B.  The rounding is in three styles, each
+     '2exp' functions, D=2^B.  The rounding is in three styles, each
      suiting different applications.
 
-        * `cdiv' rounds Q up towards +infinity, and R will have the
-          opposite sign to D.  The `c' stands for "ceil".
+        * 'cdiv' rounds Q up towards +infinity, and R will have the
+          opposite sign to D.  The 'c' stands for "ceil".
 
-        * `fdiv' rounds Q down towards -infinity, and R will have the
-          same sign as D.  The `f' stands for "floor".
+        * 'fdiv' rounds Q down towards -infinity, and R will have the
+          same sign as D.  The 'f' stands for "floor".
 
-        * `tdiv' rounds Q towards zero, and R will have the same sign
-          as N.  The `t' stands for "truncate".
+        * 'tdiv' rounds Q towards zero, and R will have the same sign as
+          N.  The 't' stands for "truncate".
 
      In all cases Q and R will satisfy N=Q*D+R, and R will satisfy
      0<=abs(R)<abs(D).
 
-     The `q' functions calculate only the quotient, the `r' functions
-     only the remainder, and the `qr' functions calculate both.  Note
-     that for `qr' the same variable cannot be passed for both Q and R,
+     The 'q' functions calculate only the quotient, the 'r' functions
+     only the remainder, and the 'qr' functions calculate both.  Note
+     that for 'qr' the same variable cannot be passed for both Q and R,
      or results will be unpredictable.
 
-     For the `ui' variants the return value is the remainder, and in
-     fact returning the remainder is all the `div_ui' functions do.  For
-     `tdiv' and `cdiv' the remainder can be negative, so for those the
+     For the 'ui' variants the return value is the remainder, and in
+     fact returning the remainder is all the 'div_ui' functions do.  For
+     'tdiv' and 'cdiv' the remainder can be negative, so for those the
      return value is the absolute value of the remainder.
 
-     For the `2exp' variants the divisor is 2^B.  These functions are
-     implemented as right shifts and bit masks, but of course they
-     round the same as the other functions.
+     For the '2exp' variants the divisor is 2^B.  These functions are
+     implemented as right shifts and bit masks, but of course they round
+     the same as the other functions.
 
-     For positive N both `mpz_fdiv_q_2exp' and `mpz_tdiv_q_2exp' are
-     simple bitwise right shifts.  For negative N, `mpz_fdiv_q_2exp' is
+     For positive N both 'mpz_fdiv_q_2exp' and 'mpz_tdiv_q_2exp' are
+     simple bitwise right shifts.  For negative N, 'mpz_fdiv_q_2exp' is
      effectively an arithmetic right shift treating N as twos complement
      the same as the bitwise logical functions do, whereas
-     `mpz_tdiv_q_2exp' effectively treats N as sign and magnitude.
+     'mpz_tdiv_q_2exp' effectively treats N as sign and magnitude.
 
  -- Function: void mpz_mod (mpz_t R, mpz_t N, mpz_t D)
  -- Function: unsigned long int mpz_mod_ui (mpz_t R, mpz_t N,
           unsigned long int D)
-     Set R to N `mod' D.  The sign of the divisor is ignored; the
-     result is always non-negative.
+     Set R to N 'mod' D.  The sign of the divisor is ignored; the result
+     is always non-negative.
 
-     `mpz_mod_ui' is identical to `mpz_fdiv_r_ui' above, returning the
-     remainder as well as setting R.  See `mpz_fdiv_ui' above if only
+     'mpz_mod_ui' is identical to 'mpz_fdiv_r_ui' above, returning the
+     remainder as well as setting R.  See 'mpz_fdiv_ui' above if only
      the return value is wanted.
 
  -- Function: void mpz_divexact (mpz_t Q, mpz_t N, mpz_t D)
  -- Function: void mpz_divexact_ui (mpz_t Q, mpz_t N, unsigned long D)
-     Set Q to N/D.  These functions produce correct results only when
-     it is known in advance that D divides N.
+     Set Q to N/D.  These functions produce correct results only when it
+     is known in advance that D divides N.
 
      These routines are much faster than the other division functions,
      and are the best choice when exact division is known to occur, for
@@ -2498,7 +2479,7 @@ these functions the same way as for normal C `int' arithmetic.
  -- Function: int mpz_divisible_ui_p (mpz_t N, unsigned long int D)
  -- Function: int mpz_divisible_2exp_p (mpz_t N, mp_bitcnt_t B)
      Return non-zero if N is exactly divisible by D, or in the case of
-     `mpz_divisible_2exp_p' by 2^B.
+     'mpz_divisible_2exp_p' by 2^B.
 
      N is divisible by D if there exists an integer Q satisfying N =
      Q*D.  Unlike the other division functions, D=0 is accepted and
@@ -2510,10 +2491,10 @@ these functions the same way as for normal C `int' arithmetic.
           unsigned long int D)
  -- Function: int mpz_congruent_2exp_p (mpz_t N, mpz_t C, mp_bitcnt_t B)
      Return non-zero if N is congruent to C modulo D, or in the case of
-     `mpz_congruent_2exp_p' modulo 2^B.
+     'mpz_congruent_2exp_p' modulo 2^B.
 
-     N is congruent to C mod D if there exists an integer Q satisfying
-     N = C + Q*D.  Unlike the other division functions, D=0 is accepted
+     N is congruent to C mod D if there exists an integer Q satisfying N
+     = C + Q*D.  Unlike the other division functions, D=0 is accepted
      and following the rule it can be seen that N and C are considered
      congruent mod 0 only when exactly equal.
 
@@ -2525,16 +2506,16 @@ File: gmp.info,  Node: Integer Exponentiation,  Next: Integer Roots,  Prev: Inte
 
  -- Function: void mpz_powm (mpz_t ROP, mpz_t BASE, mpz_t EXP, mpz_t
           MOD)
- -- Function: void mpz_powm_ui (mpz_t ROP, mpz_t BASE, unsigned long
-          int EXP, mpz_t MOD)
+ -- Function: void mpz_powm_ui (mpz_t ROP, mpz_t BASE, unsigned long int
+          EXP, mpz_t MOD)
      Set ROP to (BASE raised to EXP) modulo MOD.
 
-     Negative EXP is supported if an inverse BASE^-1 mod MOD exists
-     (see `mpz_invert' in *note Number Theoretic Functions::).  If an
-     inverse doesn't exist then a divide by zero is raised.
+     Negative EXP is supported if an inverse BASE^-1 mod MOD exists (see
+     'mpz_invert' in *note Number Theoretic Functions::).  If an inverse
+     doesn't exist then a divide by zero is raised.
 
- -- Function: void mpz_powm_sec (mpz_t ROP, mpz_t BASE, mpz_t EXP,
-          mpz_t MOD)
+ -- Function: void mpz_powm_sec (mpz_t ROP, mpz_t BASE, mpz_t EXP, mpz_t
+          MOD)
      Set ROP to (BASE raised to EXP) modulo MOD.
 
      It is required that EXP > 0 and that MOD is odd.
@@ -2559,21 +2540,21 @@ File: gmp.info,  Node: Integer Roots,  Next: Number Theoretic Functions,  Prev:
 =============================
 
  -- Function: int mpz_root (mpz_t ROP, mpz_t OP, unsigned long int N)
-     Set ROP to  the truncated integer part of the Nth root of OP.
-     Return non-zero if the computation was exact, i.e., if OP is ROP
-     to the Nth power.
+     Set ROP to the truncated integer part of the Nth root of OP.
+     Return non-zero if the computation was exact, i.e., if OP is ROP to
+     the Nth power.
 
- -- Function: void mpz_rootrem (mpz_t ROOT, mpz_t REM, mpz_t U,
-          unsigned long int N)
-     Set ROOT to  the truncated integer part of the Nth root of U.  Set
+ -- Function: void mpz_rootrem (mpz_t ROOT, mpz_t REM, mpz_t U, unsigned
+          long int N)
+     Set ROOT to the truncated integer part of the Nth root of U.  Set
      REM to the remainder, U-ROOT**N.
 
  -- Function: void mpz_sqrt (mpz_t ROP, mpz_t OP)
-     Set ROP to  the truncated integer part of the square root of OP.
+     Set ROP to the truncated integer part of the square root of OP.
 
  -- Function: void mpz_sqrtrem (mpz_t ROP1, mpz_t ROP2, mpz_t OP)
      Set ROP1 to the truncated integer part of the square root of OP,
-     like `mpz_sqrt'.  Set ROP2 to the remainder OP-ROP1*ROP1, which
+     like 'mpz_sqrt'.  Set ROP2 to the remainder OP-ROP1*ROP1, which
      will be zero if OP is a perfect square.
 
      If ROP1 and ROP2 are the same variable, the results are undefined.
@@ -2584,12 +2565,12 @@ File: gmp.info,  Node: Integer Roots,  Next: Number Theoretic Functions,  Prev:
      power B.
 
      Under this definition both 0 and 1 are considered to be perfect
-     powers.  Negative values of OP are accepted, but of course can
-     only be odd perfect powers.
+     powers.  Negative values of OP are accepted, but of course can only
+     be odd perfect powers.
 
  -- Function: int mpz_perfect_square_p (mpz_t OP)
-     Return non-zero if OP is a perfect square, i.e., if the square
-     root of OP is an integer.  Under this definition both 0 and 1 are
+     Return non-zero if OP is a perfect square, i.e., if the square root
+     of OP is an integer.  Under this definition both 0 and 1 are
      considered to be perfect squares.
 
 
@@ -2611,8 +2592,8 @@ File: gmp.info,  Node: Number Theoretic Functions,  Next: Integer Comparisons,
      Miller-Rabin and similar tests can be more properly called
      compositeness tests.  Numbers which fail are known to be composite
      but those which pass might be prime or might be composite.  Only a
-     few composites pass, hence those which pass are considered
-     probably prime.
+     few composites pass, hence those which pass are considered probably
+     prime.
 
  -- Function: void mpz_nextprime (mpz_t ROP, mpz_t OP)
      Set ROP to the next prime greater than OP.
@@ -2628,28 +2609,28 @@ File: gmp.info,  Node: Number Theoretic Functions,  Next: Integer Comparisons,
  -- Function: unsigned long int mpz_gcd_ui (mpz_t ROP, mpz_t OP1,
           unsigned long int OP2)
      Compute the greatest common divisor of OP1 and OP2.  If ROP is not
-     `NULL', store the result there.
+     'NULL', store the result there.
 
-     If the result is small enough to fit in an `unsigned long int', it
+     If the result is small enough to fit in an 'unsigned long int', it
      is returned.  If the result does not fit, 0 is returned, and the
      result is equal to the argument OP1.  Note that the result will
      always fit if OP2 is non-zero.
 
- -- Function: void mpz_gcdext (mpz_t G, mpz_t S, mpz_t T, mpz_t A,
-          mpz_t B)
+ -- Function: void mpz_gcdext (mpz_t G, mpz_t S, mpz_t T, mpz_t A, mpz_t
+          B)
      Set G to the greatest common divisor of A and B, and in addition
-     set S and T to coefficients satisfying A*S + B*T = G.  The value
-     in G is always positive, even if one or both of A and B are
-     negative.  The values in S and T are chosen such that abs(S) <=
-     abs(B) and abs(T) <= abs(A).
+     set S and T to coefficients satisfying A*S + B*T = G.  The value in
+     G is always positive, even if one or both of A and B are negative.
+     The values in S and T are chosen such that abs(S) <= abs(B) and
+     abs(T) <= abs(A).
 
-     If T is `NULL' then that value is not computed.
+     If T is 'NULL' then that value is not computed.
 
  -- Function: void mpz_lcm (mpz_t ROP, mpz_t OP1, mpz_t OP2)
  -- Function: void mpz_lcm_ui (mpz_t ROP, mpz_t OP1, unsigned long OP2)
-     Set ROP to the least common multiple of OP1 and OP2.  ROP is
-     always positive, irrespective of the signs of OP1 and OP2.  ROP
-     will be zero if either OP1 or OP2 is zero.
+     Set ROP to the least common multiple of OP1 and OP2.  ROP is always
+     positive, irrespective of the signs of OP1 and OP2.  ROP will be
+     zero if either OP1 or OP2 is zero.
 
  -- Function: int mpz_invert (mpz_t ROP, mpz_t OP1, mpz_t OP2)
      Compute the inverse of OP1 modulo OP2 and put the result in ROP.
@@ -2661,8 +2642,8 @@ File: gmp.info,  Node: Number Theoretic Functions,  Next: Integer Comparisons,
      Calculate the Jacobi symbol (A/B).  This is defined only for B odd.
 
  -- Function: int mpz_legendre (mpz_t A, mpz_t P)
-     Calculate the Legendre symbol (A/P).  This is defined only for P
-     an odd positive prime, and for such P it's identical to the Jacobi
+     Calculate the Legendre symbol (A/P).  This is defined only for P an
+     odd positive prime, and for such P it's identical to the Jacobi
      symbol.
 
  -- Function: int mpz_kronecker (mpz_t A, mpz_t B)
@@ -2673,17 +2654,17 @@ File: gmp.info,  Node: Number Theoretic Functions,  Next: Integer Comparisons,
      Calculate the Jacobi symbol (A/B) with the Kronecker extension
      (a/2)=(2/a) when a odd, or (a/2)=0 when a even.
 
-     When B is odd the Jacobi symbol and Kronecker symbol are
-     identical, so `mpz_kronecker_ui' etc can be used for mixed
-     precision Jacobi symbols too.
+     When B is odd the Jacobi symbol and Kronecker symbol are identical,
+     so 'mpz_kronecker_ui' etc can be used for mixed precision Jacobi
+     symbols too.
 
      For more information see Henri Cohen section 1.4.2 (*note
-     References::), or any number theory textbook.  See also the
-     example program `demos/qcn.c' which uses `mpz_kronecker_ui'.
+     References::), or any number theory textbook.  See also the example
+     program 'demos/qcn.c' which uses 'mpz_kronecker_ui'.
 
  -- Function: mp_bitcnt_t mpz_remove (mpz_t ROP, mpz_t OP, mpz_t F)
-     Remove all occurrences of the factor F from OP and store the
-     result in ROP.  The return value is how many such occurrences were
+     Remove all occurrences of the factor F from OP and store the result
+     in ROP.  The return value is how many such occurrences were
      removed.
 
  -- Function: void mpz_fac_ui (mpz_t ROP, unsigned long int OP)
@@ -2693,35 +2674,35 @@ File: gmp.info,  Node: Number Theoretic Functions,  Next: Integer Comparisons,
  -- Function: void mpz_bin_uiui (mpz_t ROP, unsigned long int N,
           unsigned long int K)
      Compute the binomial coefficient N over K and store the result in
-     ROP.  Negative values of N are supported by `mpz_bin_ui', using
-     the identity bin(-n,k) = (-1)^k * bin(n+k-1,k), see Knuth volume 1
+     ROP.  Negative values of N are supported by 'mpz_bin_ui', using the
+     identity bin(-n,k) = (-1)^k * bin(n+k-1,k), see Knuth volume 1
      section 1.2.6 part G.
 
  -- Function: void mpz_fib_ui (mpz_t FN, unsigned long int N)
  -- Function: void mpz_fib2_ui (mpz_t FN, mpz_t FNSUB1, unsigned long
           int N)
-     `mpz_fib_ui' sets FN to to F[n], the N'th Fibonacci number.
-     `mpz_fib2_ui' sets FN to F[n], and FNSUB1 to F[n-1].
+     'mpz_fib_ui' sets FN to to F[n], the N'th Fibonacci number.
+     'mpz_fib2_ui' sets FN to F[n], and FNSUB1 to F[n-1].
 
      These functions are designed for calculating isolated Fibonacci
      numbers.  When a sequence of values is wanted it's best to start
-     with `mpz_fib2_ui' and iterate the defining F[n+1]=F[n]+F[n-1] or
+     with 'mpz_fib2_ui' and iterate the defining F[n+1]=F[n]+F[n-1] or
      similar.
 
  -- Function: void mpz_lucnum_ui (mpz_t LN, unsigned long int N)
- -- Function: void mpz_lucnum2_ui (mpz_t LN, mpz_t LNSUB1, unsigned
-          long int N)
-     `mpz_lucnum_ui' sets LN to to L[n], the N'th Lucas number.
-     `mpz_lucnum2_ui' sets LN to L[n], and LNSUB1 to L[n-1].
+ -- Function: void mpz_lucnum2_ui (mpz_t LN, mpz_t LNSUB1, unsigned long
+          int N)
+     'mpz_lucnum_ui' sets LN to to L[n], the N'th Lucas number.
+     'mpz_lucnum2_ui' sets LN to L[n], and LNSUB1 to L[n-1].
 
      These functions are designed for calculating isolated Lucas
      numbers.  When a sequence of values is wanted it's best to start
-     with `mpz_lucnum2_ui' and iterate the defining L[n+1]=L[n]+L[n-1]
+     with 'mpz_lucnum2_ui' and iterate the defining L[n+1]=L[n]+L[n-1]
      or similar.
 
      The Fibonacci numbers and Lucas numbers are related sequences, so
-     it's never necessary to call both `mpz_fib2_ui' and
-     `mpz_lucnum2_ui'.  The formulas for going from Fibonacci to Lucas
+     it's never necessary to call both 'mpz_fib2_ui' and
+     'mpz_lucnum2_ui'.  The formulas for going from Fibonacci to Lucas
      can be found in *note Lucas Numbers Algorithm::, the reverse is
      straightforward too.
 
@@ -2735,11 +2716,11 @@ File: gmp.info,  Node: Integer Comparisons,  Next: Integer Logic and Bit Fiddlin
  -- Function: int mpz_cmp_d (mpz_t OP1, double OP2)
  -- Macro: int mpz_cmp_si (mpz_t OP1, signed long int OP2)
  -- Macro: int mpz_cmp_ui (mpz_t OP1, unsigned long int OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, or a negative value if OP1 < OP2.
+     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero if
+     OP1 = OP2, or a negative value if OP1 < OP2.
 
-     `mpz_cmp_ui' and `mpz_cmp_si' are macros and will evaluate their
-     arguments more than once.  `mpz_cmp_d' can be called with an
+     'mpz_cmp_ui' and 'mpz_cmp_si' are macros and will evaluate their
+     arguments more than once.  'mpz_cmp_d' can be called with an
      infinity, but results are undefined for a NaN.
 
  -- Function: int mpz_cmpabs (mpz_t OP1, mpz_t OP2)
@@ -2749,14 +2730,14 @@ File: gmp.info,  Node: Integer Comparisons,  Next: Integer Logic and Bit Fiddlin
      value if abs(OP1) > abs(OP2), zero if abs(OP1) = abs(OP2), or a
      negative value if abs(OP1) < abs(OP2).
 
-     `mpz_cmpabs_d' can be called with an infinity, but results are
+     'mpz_cmpabs_d' can be called with an infinity, but results are
      undefined for a NaN.
 
  -- Macro: int mpz_sgn (mpz_t OP)
      Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.
 
-     This function is actually implemented as a macro.  It evaluates
-     its argument multiple times.
+     This function is actually implemented as a macro.  It evaluates its
+     argument multiple times.
 
 
 File: gmp.info,  Node: Integer Logic and Bit Fiddling,  Next: I/O of Integers,  Prev: Integer Comparisons,  Up: Integer Functions
@@ -2781,18 +2762,17 @@ significant bit is number 0.
      Set ROP to the one's complement of OP.
 
  -- Function: mp_bitcnt_t mpz_popcount (mpz_t OP)
-     If OP>=0, return the population count of OP, which is the number
-     of 1 bits in the binary representation.  If OP<0, the number of 1s
-     is infinite, and the return value is the largest possible
-     `mp_bitcnt_t'.
+     If OP>=0, return the population count of OP, which is the number of
+     1 bits in the binary representation.  If OP<0, the number of 1s is
+     infinite, and the return value is the largest possible
+     'mp_bitcnt_t'.
 
  -- Function: mp_bitcnt_t mpz_hamdist (mpz_t OP1, mpz_t OP2)
-     If OP1 and OP2 are both >=0 or both <0, return the hamming
-     distance between the two operands, which is the number of bit
-     positions where OP1 and OP2 have different bit values.  If one
-     operand is >=0 and the other <0 then the number of bits different
-     is infinite, and the return value is the largest possible
-     `mp_bitcnt_t'.
+     If OP1 and OP2 are both >=0 or both <0, return the hamming distance
+     between the two operands, which is the number of bit positions
+     where OP1 and OP2 have different bit values.  If one operand is >=0
+     and the other <0 then the number of bits different is infinite, and
+     the return value is the largest possible 'mp_bitcnt_t'.
 
  -- Function: mp_bitcnt_t mpz_scan0 (mpz_t OP, mp_bitcnt_t STARTING_BIT)
  -- Function: mp_bitcnt_t mpz_scan1 (mpz_t OP, mp_bitcnt_t STARTING_BIT)
@@ -2803,9 +2783,9 @@ significant bit is number 0.
      If the bit at STARTING_BIT is already what's sought, then
      STARTING_BIT is returned.
 
-     If there's no bit found, then the largest possible `mp_bitcnt_t' is
-     returned.  This will happen in `mpz_scan0' past the end of a
-     negative number, or `mpz_scan1' past the end of a nonnegative
+     If there's no bit found, then the largest possible 'mp_bitcnt_t' is
+     returned.  This will happen in 'mpz_scan0' past the end of a
+     negative number, or 'mpz_scan1' past the end of a nonnegative
      number.
 
  -- Function: void mpz_setbit (mpz_t ROP, mp_bitcnt_t BIT_INDEX)
@@ -2827,12 +2807,12 @@ File: gmp.info,  Node: I/O of Integers,  Next: Integer Random Numbers,  Prev: In
 ===============================
 
 Functions that perform input from a stdio stream, and functions that
-output to a stdio stream, of `mpz' numbers.  Passing a `NULL' pointer
+output to a stdio stream, of 'mpz' numbers.  Passing a 'NULL' pointer
 for a STREAM argument to any of these functions will make them read from
-`stdin' and write to `stdout', respectively.
+'stdin' and write to 'stdout', respectively.
 
    When using any of these functions, it is a good idea to include
-`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
+'stdio.h' before 'gmp.h', since that will allow 'gmp.h' to define
 prototypes for these functions.
 
    See also *note Formatted Output:: and *note Formatted Input::.
@@ -2843,24 +2823,24 @@ prototypes for these functions.
 
      For BASE in the range 2..36, digits and lower-case letters are
      used; for -2..-36, digits and upper-case letters are used; for
-     37..62, digits, upper-case letters, and lower-case letters (in
-     that significance order) are used.
+     37..62, digits, upper-case letters, and lower-case letters (in that
+     significance order) are used.
 
-     Return the number of bytes written, or if an error occurred,
-     return 0.
+     Return the number of bytes written, or if an error occurred, return
+     0.
 
  -- Function: size_t mpz_inp_str (mpz_t ROP, FILE *STREAM, int BASE)
      Input a possibly white-space preceded string in base BASE from
      stdio stream STREAM, and put the read integer in ROP.
 
      The BASE may vary from 2 to 62, or if BASE is 0, then the leading
-     characters are used: `0x' and `0X' for hexadecimal, `0b' and `0B'
-     for binary, `0' for octal, or decimal otherwise.
+     characters are used: '0x' and '0X' for hexadecimal, '0b' and '0B'
+     for binary, '0' for octal, or decimal otherwise.
 
      For bases up to 36, case is ignored; upper-case and lower-case
-     letters have the same value.  For bases 37 to 62, upper-case
-     letter represent the usual 10..35 while lower-case letter
-     represent 36..61.
+     letters have the same value.  For bases 37 to 62, upper-case letter
+     represent the usual 10..35 while lower-case letter represent
+     36..61.
 
      Return the number of bytes read, or if an error occurred, return 0.
 
@@ -2871,21 +2851,21 @@ prototypes for these functions.
      limbs are written in decreasing significance order (i.e., in
      big-endian).
 
-     The output can be read with `mpz_inp_raw'.
+     The output can be read with 'mpz_inp_raw'.
 
-     Return the number of bytes written, or if an error occurred,
-     return 0.
+     Return the number of bytes written, or if an error occurred, return
+     0.
 
-     The output of this can not be read by `mpz_inp_raw' from GMP 1,
+     The output of this can not be read by 'mpz_inp_raw' from GMP 1,
      because of changes necessary for compatibility between 32-bit and
      64-bit machines.
 
  -- Function: size_t mpz_inp_raw (mpz_t ROP, FILE *STREAM)
      Input from stdio stream STREAM in the format written by
-     `mpz_out_raw', and put the result in ROP.  Return the number of
+     'mpz_out_raw', and put the result in ROP.  Return the number of
      bytes read, or if an error occurred, return 0.
 
-     This routine can read the output from `mpz_out_raw' also from GMP
+     This routine can read the output from 'mpz_out_raw' also from GMP
      1, in spite of changes necessary for compatibility between 32-bit
      and 64-bit machines.
 
@@ -2897,9 +2877,9 @@ File: gmp.info,  Node: Integer Random Numbers,  Next: Integer Import and Export,
 
 The random number functions of GMP come in two groups; older function
 that rely on a global state, and newer functions that accept a state
-parameter that is read and modified.  Please see the *note Random
-Number Functions:: for more information on how to use and not to use
-random number functions.
+parameter that is read and modified.  Please see the *note Random Number
+Functions:: for more information on how to use and not to use random
+number functions.
 
  -- Function: void mpz_urandomb (mpz_t ROP, gmp_randstate_t STATE,
           mp_bitcnt_t N)
@@ -2907,15 +2887,15 @@ random number functions.
      2^N-1, inclusive.
 
      The variable STATE must be initialized by calling one of the
-     `gmp_randinit' functions (*note Random State Initialization::)
+     'gmp_randinit' functions (*note Random State Initialization::)
      before invoking this function.
 
- -- Function: void mpz_urandomm (mpz_t ROP, gmp_randstate_t STATE,
-          mpz_t N)
+ -- Function: void mpz_urandomm (mpz_t ROP, gmp_randstate_t STATE, mpz_t
+          N)
      Generate a uniform random integer in the range 0 to N-1, inclusive.
 
      The variable STATE must be initialized by calling one of the
-     `gmp_randinit' functions (*note Random State Initialization::)
+     'gmp_randinit' functions (*note Random State Initialization::)
      before invoking this function.
 
  -- Function: void mpz_rrandomb (mpz_t ROP, gmp_randstate_t STATE,
@@ -2923,30 +2903,30 @@ random number functions.
      Generate a random integer with long strings of zeros and ones in
      the binary representation.  Useful for testing functions and
      algorithms, since this kind of random numbers have proven to be
-     more likely to trigger corner-case bugs.  The random number will
-     be in the range 0 to 2^N-1, inclusive.
+     more likely to trigger corner-case bugs.  The random number will be
+     in the range 0 to 2^N-1, inclusive.
 
      The variable STATE must be initialized by calling one of the
-     `gmp_randinit' functions (*note Random State Initialization::)
+     'gmp_randinit' functions (*note Random State Initialization::)
      before invoking this function.
 
  -- Function: void mpz_random (mpz_t ROP, mp_size_t MAX_SIZE)
      Generate a random integer of at most MAX_SIZE limbs.  The generated
      random number doesn't satisfy any particular requirements of
-     randomness.  Negative random numbers are generated when MAX_SIZE
-     is negative.
+     randomness.  Negative random numbers are generated when MAX_SIZE is
+     negative.
 
-     This function is obsolete.  Use `mpz_urandomb' or `mpz_urandomm'
+     This function is obsolete.  Use 'mpz_urandomb' or 'mpz_urandomm'
      instead.
 
  -- Function: void mpz_random2 (mpz_t ROP, mp_size_t MAX_SIZE)
      Generate a random integer of at most MAX_SIZE limbs, with long
-     strings of zeros and ones in the binary representation.  Useful
-     for testing functions and algorithms, since this kind of random
-     numbers have proven to be more likely to trigger corner-case bugs.
+     strings of zeros and ones in the binary representation.  Useful for
+     testing functions and algorithms, since this kind of random numbers
+     have proven to be more likely to trigger corner-case bugs.
      Negative random numbers are generated when MAX_SIZE is negative.
 
-     This function is obsolete.  Use `mpz_rrandomb' instead.
+     This function is obsolete.  Use 'mpz_rrandomb' instead.
 
 
 File: gmp.info,  Node: Integer Import and Export,  Next: Miscellaneous Integer Functions,  Prev: Integer Random Numbers,  Up: Integer Functions
@@ -2954,7 +2934,7 @@ File: gmp.info,  Node: Integer Import and Export,  Next: Miscellaneous Integer F
 5.14 Integer Import and Export
 ==============================
 
-`mpz_t' variables can be converted to and from arbitrary words of binary
+'mpz_t' variables can be converted to and from arbitrary words of binary
 data with the following functions.
 
  -- Function: void mpz_import (mpz_t ROP, size_t COUNT, int ORDER,
@@ -2971,25 +2951,25 @@ data with the following functions.
 
      There is no sign taken from the data, ROP will simply be a positive
      integer.  An application can handle any sign itself, and apply it
-     for instance with `mpz_neg'.
+     for instance with 'mpz_neg'.
 
      There are no data alignment restrictions on OP, any address is
      allowed.
 
-     Here's an example converting an array of `unsigned long' data, most
+     Here's an example converting an array of 'unsigned long' data, most
      significant element first, and host byte order within each value.
 
           unsigned long  a[20];
           /* Initialize Z and A */
           mpz_import (z, 20, 1, sizeof(a[0]), 0, 0, a);
 
-     This example assumes the full `sizeof' bytes are used for data in
+     This example assumes the full 'sizeof' bytes are used for data in
      the given type, which is usually true, and certainly true for
-     `unsigned long' everywhere we know of.  However on Cray vector
-     systems it may be noted that `short' and `int' are always stored
-     in 8 bytes (and with `sizeof' indicating that) but use only 32 or
-     46 bits.  The NAILS feature can account for this, by passing for
-     instance `8*sizeof(int)-INT_BIT'.
+     'unsigned long' everywhere we know of.  However on Cray vector
+     systems it may be noted that 'short' and 'int' are always stored in
+     8 bytes (and with 'sizeof' indicating that) but use only 32 or 46
+     bits.  The NAILS feature can account for this, by passing for
+     instance '8*sizeof(int)-INT_BIT'.
 
  -- Function: void * mpz_export (void *ROP, size_t *COUNTP, int ORDER,
           size_t SIZE, int ENDIAN, size_t NAILS, mpz_t OP)
@@ -3003,20 +2983,20 @@ data with the following functions.
      significant NAILS bits of each word are unused and set to zero,
      this can be 0 to produce full words.
 
-     The number of words produced is written to `*COUNTP', or COUNTP
-     can be `NULL' to discard the count.  ROP must have enough space
-     for the data, or if ROP is `NULL' then a result array of the
-     necessary size is allocated using the current GMP allocation
-     function (*note Custom Allocation::).  In either case the return
-     value is the destination used, either ROP or the allocated block.
+     The number of words produced is written to '*COUNTP', or COUNTP can
+     be 'NULL' to discard the count.  ROP must have enough space for the
+     data, or if ROP is 'NULL' then a result array of the necessary size
+     is allocated using the current GMP allocation function (*note
+     Custom Allocation::).  In either case the return value is the
+     destination used, either ROP or the allocated block.
 
      If OP is non-zero then the most significant word produced will be
      non-zero.  If OP is zero then the count returned will be zero and
-     nothing written to ROP.  If ROP is `NULL' in this case, no block
-     is allocated, just `NULL' is returned.
+     nothing written to ROP.  If ROP is 'NULL' in this case, no block is
+     allocated, just 'NULL' is returned.
 
      The sign of OP is ignored, just the absolute value is exported.  An
-     application can use `mpz_sgn' to get the sign and handle it as
+     application can use 'mpz_sgn' to get the sign and handle it as
      desired.  (*note Integer Comparisons::)
 
      There are no data alignment restrictions on ROP, any address is
@@ -3024,10 +3004,10 @@ data with the following functions.
 
      When an application is allocating space itself the required size
      can be determined with a calculation like the following.  Since
-     `mpz_sizeinbase' always returns at least 1, `count' here will be
-     at least one, which avoids any portability problems with
-     `malloc(0)', though if `z' is zero no space at all is actually
-     needed (or written).
+     'mpz_sizeinbase' always returns at least 1, 'count' here will be at
+     least one, which avoids any portability problems with 'malloc(0)',
+     though if 'z' is zero no space at all is actually needed (or
+     written).
 
           numb = 8*size - nail;
           count = (mpz_sizeinbase (z, 2) + numb-1) / numb;
@@ -3045,29 +3025,29 @@ File: gmp.info,  Node: Miscellaneous Integer Functions,  Next: Integer Special F
  -- Function: int mpz_fits_sint_p (mpz_t OP)
  -- Function: int mpz_fits_ushort_p (mpz_t OP)
  -- Function: int mpz_fits_sshort_p (mpz_t OP)
-     Return non-zero iff the value of OP fits in an `unsigned long int',
-     `signed long int', `unsigned int', `signed int', `unsigned short
-     int', or `signed short int', respectively.  Otherwise, return zero.
+     Return non-zero iff the value of OP fits in an 'unsigned long int',
+     'signed long int', 'unsigned int', 'signed int', 'unsigned short
+     int', or 'signed short int', respectively.  Otherwise, return zero.
 
  -- Macro: int mpz_odd_p (mpz_t OP)
  -- Macro: int mpz_even_p (mpz_t OP)
-     Determine whether OP is odd or even, respectively.  Return
-     non-zero if yes, zero if no.  These macros evaluate their argument
-     more than once.
+     Determine whether OP is odd or even, respectively.  Return non-zero
+     if yes, zero if no.  These macros evaluate their argument more than
+     once.
 
  -- Function: size_t mpz_sizeinbase (mpz_t OP, int BASE)
      Return the size of OP measured in number of digits in the given
-     BASE.  BASE can vary from 2 to 62.  The sign of OP is ignored,
-     just the absolute value is used.  The result will be either exact
-     or 1 too big.  If BASE is a power of 2, the result is always
-     exact.  If OP is zero the return value is always 1.
+     BASE.  BASE can vary from 2 to 62.  The sign of OP is ignored, just
+     the absolute value is used.  The result will be either exact or 1
+     too big.  If BASE is a power of 2, the result is always exact.  If
+     OP is zero the return value is always 1.
 
      This function can be used to determine the space required when
      converting OP to a string.  The right amount of allocation is
-     normally two more than the value returned by `mpz_sizeinbase', one
+     normally two more than the value returned by 'mpz_sizeinbase', one
      extra for a minus sign and one for the null-terminator.
 
-     It will be noted that `mpz_sizeinbase(OP,2)' can be used to locate
+     It will be noted that 'mpz_sizeinbase(OP,2)' can be used to locate
      the most significant 1 bit in OP, counting from 1.  (Unlike the
      bitwise functions which start from 0, *Note Logical and Bit
      Manipulation Functions: Integer Logic and Bit Fiddling.)
@@ -3086,9 +3066,9 @@ applications will not need them.
      This is a special type of initialization.  *Fixed* space of
      FIXED_NUM_BITS is allocated to each of the ARRAY_SIZE integers in
      INTEGER_ARRAY.  There is no way to free the storage allocated by
-     this function.  Don't call `mpz_clear'!
+     this function.  Don't call 'mpz_clear'!
 
-     The INTEGER_ARRAY parameter is the first `mpz_t' in the array.  For
+     The INTEGER_ARRAY parameter is the first 'mpz_t' in the array.  For
      example,
 
           mpz_t  arr[20000];
@@ -3100,44 +3080,44 @@ applications will not need them.
      normal programs this function is not recommended.
 
      The space allocated to each integer by this function will not be
-     automatically increased, unlike the normal `mpz_init', so an
-     application must ensure it is sufficient for any value stored.
-     The following space requirements apply to various routines,
+     automatically increased, unlike the normal 'mpz_init', so an
+     application must ensure it is sufficient for any value stored.  The
+     following space requirements apply to various routines,
 
-        * `mpz_abs', `mpz_neg', `mpz_set', `mpz_set_si' and
-          `mpz_set_ui' need room for the value they store.
+        * 'mpz_abs', 'mpz_neg', 'mpz_set', 'mpz_set_si' and 'mpz_set_ui'
+          need room for the value they store.
 
-        * `mpz_add', `mpz_add_ui', `mpz_sub' and `mpz_sub_ui' need room
+        * 'mpz_add', 'mpz_add_ui', 'mpz_sub' and 'mpz_sub_ui' need room
           for the larger of the two operands, plus an extra
-          `mp_bits_per_limb'.
+          'mp_bits_per_limb'.
 
-        * `mpz_mul', `mpz_mul_ui' and `mpz_mul_si' need room for the sum
+        * 'mpz_mul', 'mpz_mul_ui' and 'mpz_mul_si' need room for the sum
           of the number of bits in their operands, but each rounded up
-          to a multiple of `mp_bits_per_limb'.
+          to a multiple of 'mp_bits_per_limb'.
 
-        * `mpz_swap' can be used between two array variables, but not
+        * 'mpz_swap' can be used between two array variables, but not
           between an array and a normal variable.
 
-     For other functions, or if in doubt, the suggestion is to
-     calculate in a regular `mpz_init' variable and copy the result to
-     an array variable with `mpz_set'.
+     For other functions, or if in doubt, the suggestion is to calculate
+     in a regular 'mpz_init' variable and copy the result to an array
+     variable with 'mpz_set'.
 
  -- Function: void * _mpz_realloc (mpz_t INTEGER, mp_size_t NEW_ALLOC)
      Change the space for INTEGER to NEW_ALLOC limbs.  The value in
      INTEGER is preserved if it fits, or is set to 0 if not.  The return
      value is not useful to applications and should be ignored.
 
-     `mpz_realloc2' is the preferred way to accomplish allocation
-     changes like this.  `mpz_realloc2' and `_mpz_realloc' are the same
-     except that `_mpz_realloc' takes its size in limbs.
+     'mpz_realloc2' is the preferred way to accomplish allocation
+     changes like this.  'mpz_realloc2' and '_mpz_realloc' are the same
+     except that '_mpz_realloc' takes its size in limbs.
 
  -- Function: mp_limb_t mpz_getlimbn (mpz_t OP, mp_size_t N)
      Return limb number N from OP.  The sign of OP is ignored, just the
      absolute value is used.  The least significant limb is number 0.
 
-     `mpz_size' can be used to find how many limbs make up OP.
-     `mpz_getlimbn' returns zero if N is outside the range 0 to
-     `mpz_size(OP)-1'.
+     'mpz_size' can be used to find how many limbs make up OP.
+     'mpz_getlimbn' returns zero if N is outside the range 0 to
+     'mpz_size(OP)-1'.
 
  -- Function: size_t mpz_size (mpz_t OP)
      Return the size of OP measured in number of limbs.  If OP is zero,
@@ -3150,9 +3130,9 @@ File: gmp.info,  Node: Rational Number Functions,  Next: Floating-point Function
 ***************************
 
 This chapter describes the GMP functions for performing arithmetic on
-rational numbers.  These functions start with the prefix `mpq_'.
+rational numbers.  These functions start with the prefix 'mpq_'.
 
-   Rational numbers are stored in objects of type `mpq_t'.
+   Rational numbers are stored in objects of type 'mpq_t'.
 
    All rational arithmetic functions assume operands have a canonical
 form, and canonicalize their result.  The canonical from means that the
@@ -3165,8 +3145,8 @@ variable before any arithmetic operations are performed on that
 variable.
 
  -- Function: void mpq_canonicalize (mpq_t OP)
-     Remove any factors that are common to the numerator and
-     denominator of OP, and make the denominator positive.
+     Remove any factors that are common to the numerator and denominator
+     of OP, and make the denominator positive.
 
 * Menu:
 
@@ -3184,20 +3164,20 @@ File: gmp.info,  Node: Initializing Rationals,  Next: Rational Conversions,  Pre
 ===========================================
 
  -- Function: void mpq_init (mpq_t X)
-     Initialize X and set it to 0/1.  Each variable should normally
-     only be initialized once, or at least cleared out (using the
-     function `mpq_clear') between each initialization.
+     Initialize X and set it to 0/1.  Each variable should normally only
+     be initialized once, or at least cleared out (using the function
+     'mpq_clear') between each initialization.
 
  -- Function: void mpq_inits (mpq_t X, ...)
-     Initialize a NULL-terminated list of `mpq_t' variables, and set
+     Initialize a NULL-terminated list of 'mpq_t' variables, and set
      their values to 0/1.
 
  -- Function: void mpq_clear (mpq_t X)
      Free the space occupied by X.  Make sure to call this function for
-     all `mpq_t' variables when you are done with them.
+     all 'mpq_t' variables when you are done with them.
 
  -- Function: void mpq_clears (mpq_t X, ...)
-     Free the space occupied by a NULL-terminated list of `mpq_t'
+     Free the space occupied by a NULL-terminated list of 'mpq_t'
      variables.
 
  -- Function: void mpq_set (mpq_t ROP, mpq_t OP)
@@ -3209,28 +3189,27 @@ File: gmp.info,  Node: Initializing Rationals,  Next: Rational Conversions,  Pre
  -- Function: void mpq_set_si (mpq_t ROP, signed long int OP1, unsigned
           long int OP2)
      Set the value of ROP to OP1/OP2.  Note that if OP1 and OP2 have
-     common factors, ROP has to be passed to `mpq_canonicalize' before
+     common factors, ROP has to be passed to 'mpq_canonicalize' before
      any operations are performed on ROP.
 
  -- Function: int mpq_set_str (mpq_t ROP, char *STR, int BASE)
      Set ROP from a null-terminated string STR in the given BASE.
 
-     The string can be an integer like "41" or a fraction like
-     "41/152".  The fraction must be in canonical form (*note Rational
-     Number Functions::), or if not then `mpq_canonicalize' must be
-     called.
+     The string can be an integer like "41" or a fraction like "41/152".
+     The fraction must be in canonical form (*note Rational Number
+     Functions::), or if not then 'mpq_canonicalize' must be called.
 
      The numerator and optional denominator are parsed the same as in
-     `mpz_set_str' (*note Assigning Integers::).  White space is
-     allowed in the string, and is simply ignored.  The BASE can vary
-     from 2 to 62, or if BASE is 0 then the leading characters are
-     used: `0x' or `0X' for hex, `0b' or `0B' for binary, `0' for
-     octal, or decimal otherwise.  Note that this is done separately
-     for the numerator and denominator, so for instance `0xEF/100' is
-     239/100, whereas `0xEF/0x100' is 239/256.
+     'mpz_set_str' (*note Assigning Integers::).  White space is allowed
+     in the string, and is simply ignored.  The BASE can vary from 2 to
+     62, or if BASE is 0 then the leading characters are used: '0x' or
+     '0X' for hex, '0b' or '0B' for binary, '0' for octal, or decimal
+     otherwise.  Note that this is done separately for the numerator and
+     denominator, so for instance '0xEF/100' is 239/100, whereas
+     '0xEF/0x100' is 239/256.
 
-     The return value is 0 if the entire string is a valid number, or
-     -1 if not.
+     The return value is 0 if the entire string is a valid number, or -1
+     if not.
 
  -- Function: void mpq_swap (mpq_t ROP1, mpq_t ROP2)
      Swap the values ROP1 and ROP2 efficiently.
@@ -3242,14 +3221,14 @@ File: gmp.info,  Node: Rational Conversions,  Next: Rational Arithmetic,  Prev:
 ========================
 
  -- Function: double mpq_get_d (mpq_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
+     Convert OP to a 'double', truncating if necessary (ie. rounding
      towards zero).
 
      If the exponent from the conversion is too big or too small to fit
-     a `double' then the result is system dependent.  For too big an
-     infinity is returned when available.  For too small 0.0 is
-     normally returned.  Hardware overflow, underflow and denorm traps
-     may or may not occur.
+     a 'double' then the result is system dependent.  For too big an
+     infinity is returned when available.  For too small 0.0 is normally
+     returned.  Hardware overflow, underflow and denorm traps may or may
+     not occur.
 
  -- Function: void mpq_set_d (mpq_t ROP, double OP)
  -- Function: void mpq_set_f (mpq_t ROP, mpf_t OP)
@@ -3258,15 +3237,15 @@ File: gmp.info,  Node: Rational Conversions,  Next: Rational Arithmetic,  Prev:
 
  -- Function: char * mpq_get_str (char *STR, int BASE, mpq_t OP)
      Convert OP to a string of digits in base BASE.  The base may vary
-     from 2 to 36.  The string will be of the form `num/den', or if the
-     denominator is 1 then just `num'.
+     from 2 to 36.  The string will be of the form 'num/den', or if the
+     denominator is 1 then just 'num'.
 
-     If STR is `NULL', the result string is allocated using the current
+     If STR is 'NULL', the result string is allocated using the current
      allocation function (*note Custom Allocation::).  The block will be
-     `strlen(str)+1' bytes, that being exactly enough for the string and
+     'strlen(str)+1' bytes, that being exactly enough for the string and
      null-terminator.
 
-     If STR is not `NULL', it should point to a block of storage large
+     If STR is not 'NULL', it should point to a block of storage large
      enough for the result, that being
 
           mpz_sizeinbase (mpq_numref(OP), BASE)
@@ -3322,11 +3301,11 @@ File: gmp.info,  Node: Comparing Rationals,  Next: Applying Integer Functions,
 ========================
 
  -- Function: int mpq_cmp (mpq_t OP1, mpq_t OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, and a negative value if OP1 < OP2.
+     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero if
+     OP1 = OP2, and a negative value if OP1 < OP2.
 
-     To determine if two rationals are equal, `mpq_equal' is faster than
-     `mpq_cmp'.
+     To determine if two rationals are equal, 'mpq_equal' is faster than
+     'mpq_cmp'.
 
  -- Macro: int mpq_cmp_ui (mpq_t OP1, unsigned long int NUM2, unsigned
           long int DEN2)
@@ -3349,7 +3328,7 @@ File: gmp.info,  Node: Comparing Rationals,  Next: Applying Integer Functions,
 
  -- Function: int mpq_equal (mpq_t OP1, mpq_t OP2)
      Return non-zero if OP1 and OP2 are equal, zero if they are
-     non-equal.  Although `mpq_cmp' can be used for the same purpose,
+     non-equal.  Although 'mpq_cmp' can be used for the same purpose,
      this function is much faster.
 
 
@@ -3358,20 +3337,19 @@ File: gmp.info,  Node: Applying Integer Functions,  Next: I/O of Rationals,  Pre
 6.5 Applying Integer Functions to Rationals
 ===========================================
 
-The set of `mpq' functions is quite small.  In particular, there are few
+The set of 'mpq' functions is quite small.  In particular, there are few
 functions for either input or output.  The following functions give
-direct access to the numerator and denominator of an `mpq_t'.
+direct access to the numerator and denominator of an 'mpq_t'.
 
    Note that if an assignment to the numerator and/or denominator could
-take an `mpq_t' out of the canonical form described at the start of
-this chapter (*note Rational Number Functions::) then
-`mpq_canonicalize' must be called before any other `mpq' functions are
-applied to that `mpq_t'.
+take an 'mpq_t' out of the canonical form described at the start of this
+chapter (*note Rational Number Functions::) then 'mpq_canonicalize' must
+be called before any other 'mpq' functions are applied to that 'mpq_t'.
 
  -- Macro: mpz_t mpq_numref (mpq_t OP)
  -- Macro: mpz_t mpq_denref (mpq_t OP)
      Return a reference to the numerator and denominator of OP,
-     respectively.  The `mpz' functions can be used on the result of
+     respectively.  The 'mpz' functions can be used on the result of
      these macros.
 
  -- Function: void mpq_get_num (mpz_t NUMERATOR, mpq_t RATIONAL)
@@ -3379,9 +3357,9 @@ applied to that `mpq_t'.
  -- Function: void mpq_set_num (mpq_t RATIONAL, mpz_t NUMERATOR)
  -- Function: void mpq_set_den (mpq_t RATIONAL, mpz_t DENOMINATOR)
      Get or set the numerator or denominator of a rational.  These
-     functions are equivalent to calling `mpz_set' with an appropriate
-     `mpq_numref' or `mpq_denref'.  Direct use of `mpq_numref' or
-     `mpq_denref' is recommended instead of these functions.
+     functions are equivalent to calling 'mpz_set' with an appropriate
+     'mpq_numref' or 'mpq_denref'.  Direct use of 'mpq_numref' or
+     'mpq_denref' is recommended instead of these functions.
 
 
 File: gmp.info,  Node: I/O of Rationals,  Prev: Applying Integer Functions,  Up: Rational Number Functions
@@ -3390,12 +3368,12 @@ File: gmp.info,  Node: I/O of Rationals,  Prev: Applying Integer Functions,  Up:
 ==============================
 
 Functions that perform input from a stdio stream, and functions that
-output to a stdio stream, of `mpq' numbers.  Passing a `NULL' pointer
+output to a stdio stream, of 'mpq' numbers.  Passing a 'NULL' pointer
 for a STREAM argument to any of these functions will make them read from
-`stdin' and write to `stdout', respectively.
+'stdin' and write to 'stdout', respectively.
 
    When using any of these functions, it is a good idea to include
-`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
+'stdio.h' before 'gmp.h', since that will allow 'gmp.h' to define
 prototypes for these functions.
 
    See also *note Formatted Output:: and *note Formatted Input::.
@@ -3403,29 +3381,29 @@ prototypes for these functions.
  -- Function: size_t mpq_out_str (FILE *STREAM, int BASE, mpq_t OP)
      Output OP on stdio stream STREAM, as a string of digits in base
      BASE.  The base may vary from 2 to 36.  Output is in the form
-     `num/den' or if the denominator is 1 then just `num'.
+     'num/den' or if the denominator is 1 then just 'num'.
 
-     Return the number of bytes written, or if an error occurred,
-     return 0.
+     Return the number of bytes written, or if an error occurred, return
+     0.
 
  -- Function: size_t mpq_inp_str (mpq_t ROP, FILE *STREAM, int BASE)
      Read a string of digits from STREAM and convert them to a rational
-     in ROP.  Any initial white-space characters are read and
-     discarded.  Return the number of characters read (including white
-     space), or 0 if a rational could not be read.
+     in ROP.  Any initial white-space characters are read and discarded.
+     Return the number of characters read (including white space), or 0
+     if a rational could not be read.
 
-     The input can be a fraction like `17/63' or just an integer like
-     `123'.  Reading stops at the first character not in this form, and
-     white space is not permitted within the string.  If the input
-     might not be in canonical form, then `mpq_canonicalize' must be
-     called (*note Rational Number Functions::).
+     The input can be a fraction like '17/63' or just an integer like
+     '123'.  Reading stops at the first character not in this form, and
+     white space is not permitted within the string.  If the input might
+     not be in canonical form, then 'mpq_canonicalize' must be called
+     (*note Rational Number Functions::).
 
      The BASE can be between 2 and 36, or can be 0 in which case the
-     leading characters of the string determine the base, `0x' or `0X'
-     for hexadecimal, `0' for octal, or decimal otherwise.  The leading
+     leading characters of the string determine the base, '0x' or '0X'
+     for hexadecimal, '0' for octal, or decimal otherwise.  The leading
      characters are examined separately for the numerator and
-     denominator of a fraction, so for instance `0x10/11' is 16/11,
-     whereas `0x10/0x11' is 16/17.
+     denominator of a fraction, so for instance '0x10/11' is 16/11,
+     whereas '0x10/0x11' is 16/17.
 
 
 File: gmp.info,  Node: Floating-point Functions,  Next: Low-level Functions,  Prev: Rational Number Functions,  Up: Top
@@ -3433,31 +3411,31 @@ File: gmp.info,  Node: Floating-point Functions,  Next: Low-level Functions,  Pr
 7 Floating-point Functions
 **************************
 
-GMP floating point numbers are stored in objects of type `mpf_t' and
-functions operating on them have an `mpf_' prefix.
+GMP floating point numbers are stored in objects of type 'mpf_t' and
+functions operating on them have an 'mpf_' prefix.
 
    The mantissa of each float has a user-selectable precision, limited
-only by available memory.  Each variable has its own precision, and
-that can be increased or decreased at any time.
+only by available memory.  Each variable has its own precision, and that
+can be increased or decreased at any time.
 
    The exponent of each float is a fixed precision, one machine word on
 most systems.  In the current implementation the exponent is a count of
 limbs, so for example on a 32-bit system this means a range of roughly
 2^-68719476768 to 2^68719476736, or on a 64-bit system this will be
-greater.  Note however `mpf_get_str' can only return an exponent which
-fits an `mp_exp_t' and currently `mpf_set_str' doesn't accept exponents
-bigger than a `long'.
+greater.  Note however 'mpf_get_str' can only return an exponent which
+fits an 'mp_exp_t' and currently 'mpf_set_str' doesn't accept exponents
+bigger than a 'long'.
 
    Each variable keeps a size for the mantissa data actually in use.
 This means that if a float is exactly represented in only a few bits
-then only those bits will be used in a calculation, even if the
-selected precision is high.
+then only those bits will be used in a calculation, even if the selected
+precision is high.
 
    All calculations are performed to the precision of the destination
 variable.  Each function is defined to calculate with "infinite
-precision" followed by a truncation to the destination precision, but
-of course the work done is only what's needed to determine a result
-under that definition.
+precision" followed by a truncation to the destination precision, but of
+course the work done is only what's needed to determine a result under
+that definition.
 
    The precision selected for a variable is a minimum value, GMP may
 increase it a little to facilitate efficient calculation.  Currently
@@ -3468,17 +3446,17 @@ applications shouldn't be concerned by such details.
    The mantissa in stored in binary, as might be imagined from the fact
 precisions are expressed in bits.  One consequence of this is that
 decimal fractions like 0.1 cannot be represented exactly.  The same is
-true of plain IEEE `double' floats.  This makes both highly unsuitable
+true of plain IEEE 'double' floats.  This makes both highly unsuitable
 for calculations involving money or other values that should be exact
-decimal fractions.  (Suitably scaled integers, or perhaps rationals,
-are better choices.)
+decimal fractions.  (Suitably scaled integers, or perhaps rationals, are
+better choices.)
 
-   `mpf' functions and variables have no special notion of infinity or
+   'mpf' functions and variables have no special notion of infinity or
 not-a-number, and applications must take care not to overflow the
 exponent or results will be unpredictable.  This might change in a
 future release.
 
-   Note that the `mpf' functions are _not_ intended as a smooth
+   Note that the 'mpf' functions are _not_ intended as a smooth
 extension to IEEE P754 arithmetic.  In particular results obtained on
 one computer often differ from the results on a computer with a
 different word size.
@@ -3502,40 +3480,40 @@ File: gmp.info,  Node: Initializing Floats,  Next: Assigning Floats,  Prev: Floa
 
  -- Function: void mpf_set_default_prec (mp_bitcnt_t PREC)
      Set the default precision to be *at least* PREC bits.  All
-     subsequent calls to `mpf_init' will use this precision, but
+     subsequent calls to 'mpf_init' will use this precision, but
      previously initialized variables are unaffected.
 
  -- Function: mp_bitcnt_t mpf_get_default_prec (void)
      Return the default precision actually used.
 
-   An `mpf_t' object must be initialized before storing the first value
-in it.  The functions `mpf_init' and `mpf_init2' are used for that
+   An 'mpf_t' object must be initialized before storing the first value
+in it.  The functions 'mpf_init' and 'mpf_init2' are used for that
 purpose.
 
  -- Function: void mpf_init (mpf_t X)
-     Initialize X to 0.  Normally, a variable should be initialized
-     once only or at least be cleared, using `mpf_clear', between
+     Initialize X to 0.  Normally, a variable should be initialized once
+     only or at least be cleared, using 'mpf_clear', between
      initializations.  The precision of X is undefined unless a default
      precision has already been established by a call to
-     `mpf_set_default_prec'.
+     'mpf_set_default_prec'.
 
  -- Function: void mpf_init2 (mpf_t X, mp_bitcnt_t PREC)
-     Initialize X to 0 and set its precision to be *at least* PREC
-     bits.  Normally, a variable should be initialized once only or at
-     least be cleared, using `mpf_clear', between initializations.
+     Initialize X to 0 and set its precision to be *at least* PREC bits.
+     Normally, a variable should be initialized once only or at least be
+     cleared, using 'mpf_clear', between initializations.
 
  -- Function: void mpf_inits (mpf_t X, ...)
-     Initialize a NULL-terminated list of `mpf_t' variables, and set
+     Initialize a NULL-terminated list of 'mpf_t' variables, and set
      their values to 0.  The precision of the initialized variables is
      undefined unless a default precision has already been established
-     by a call to `mpf_set_default_prec'.
+     by a call to 'mpf_set_default_prec'.
 
  -- Function: void mpf_clear (mpf_t X)
      Free the space occupied by X.  Make sure to call this function for
-     all `mpf_t' variables when you are done with them.
+     all 'mpf_t' variables when you are done with them.
 
  -- Function: void mpf_clears (mpf_t X, ...)
-     Free the space occupied by a NULL-terminated list of `mpf_t'
+     Free the space occupied by a NULL-terminated list of 'mpf_t'
      variables.
 
    Here is an example on how to initialize floating-point variables:
@@ -3562,7 +3540,7 @@ numbers.
      Set the precision of ROP to be *at least* PREC bits.  The value in
      ROP will be truncated to the new precision.
 
-     This function requires a call to `realloc', and so should not be
+     This function requires a call to 'realloc', and so should not be
      used in a tight loop.
 
  -- Function: void mpf_set_prec_raw (mpf_t ROP, mp_bitcnt_t PREC)
@@ -3571,22 +3549,22 @@ numbers.
 
      PREC must be no more than the allocated precision for ROP, that
      being the precision when ROP was initialized, or in the most recent
-     `mpf_set_prec'.
+     'mpf_set_prec'.
 
      The value in ROP is unchanged, and in particular if it had a higher
      precision than PREC it will retain that higher precision.  New
      values written to ROP will use the new PREC.
 
-     Before calling `mpf_clear' or the full `mpf_set_prec', another
-     `mpf_set_prec_raw' call must be made to restore ROP to its original
+     Before calling 'mpf_clear' or the full 'mpf_set_prec', another
+     'mpf_set_prec_raw' call must be made to restore ROP to its original
      allocated precision.  Failing to do so will have unpredictable
      results.
 
-     `mpf_get_prec' can be used before `mpf_set_prec_raw' to get the
-     original allocated precision.  After `mpf_set_prec_raw' it
-     reflects the PREC value set.
+     'mpf_get_prec' can be used before 'mpf_set_prec_raw' to get the
+     original allocated precision.  After 'mpf_set_prec_raw' it reflects
+     the PREC value set.
 
-     `mpf_set_prec_raw' is an efficient way to use an `mpf_t' variable
+     'mpf_set_prec_raw' is an efficient way to use an 'mpf_t' variable
      at different precisions during a calculation, perhaps to gradually
      increase precision in an iteration, or just to use various
      different precisions for different purposes during a calculation.
@@ -3610,12 +3588,11 @@ Initializing Floats::).
 
  -- Function: int mpf_set_str (mpf_t ROP, char *STR, int BASE)
      Set the value of ROP from the string in STR.  The string is of the
-     form `M@N' or, if the base is 10 or less, alternatively `MeN'.
-     `M' is the mantissa and `N' is the exponent.  The mantissa is
-     always in the specified base.  The exponent is either in the
-     specified base or, if BASE is negative, in decimal.  The decimal
-     point expected is taken from the current locale, on systems
-     providing `localeconv'.
+     form 'M@N' or, if the base is 10 or less, alternatively 'MeN'.  'M'
+     is the mantissa and 'N' is the exponent.  The mantissa is always in
+     the specified base.  The exponent is either in the specified base
+     or, if BASE is negative, in decimal.  The decimal point expected is
+     taken from the current locale, on systems providing 'localeconv'.
 
      The argument BASE may be in the ranges 2 to 62, or -62 to -2.
      Negative values are used to specify that the exponent is in
@@ -3626,25 +3603,25 @@ Initializing Floats::).
      represent the usual 10..35 while lower-case letter represent
      36..61.
 
-     Unlike the corresponding `mpz' function, the base will not be
+     Unlike the corresponding 'mpz' function, the base will not be
      determined from the leading characters of the string if BASE is 0.
-     This is so that numbers like `0.23' are not interpreted as octal.
+     This is so that numbers like '0.23' are not interpreted as octal.
 
-     White space is allowed in the string, and is simply ignored.
-     [This is not really true; white-space is ignored in the beginning
-     of the string and within the mantissa, but not in other places,
-     such as after a minus sign or in the exponent.  We are considering
-     changing the definition of this function, making it fail when
-     there is any white-space in the input, since that makes a lot of
-     sense.  Please tell us your opinion about this change.  Do you
-     really want it to accept "3 14" as meaning 314 as it does now?]
+     White space is allowed in the string, and is simply ignored.  [This
+     is not really true; white-space is ignored in the beginning of the
+     string and within the mantissa, but not in other places, such as
+     after a minus sign or in the exponent.  We are considering changing
+     the definition of this function, making it fail when there is any
+     white-space in the input, since that makes a lot of sense.  Please
+     tell us your opinion about this change.  Do you really want it to
+     accept "3 14" as meaning 314 as it does now?]
 
      This function returns 0 if the entire string is a valid number in
      base BASE.  Otherwise it returns -1.
 
  -- Function: void mpf_swap (mpf_t ROP1, mpf_t ROP2)
-     Swap ROP1 and ROP2 efficiently.  Both the values and the
-     precisions of the two variables are swapped.
+     Swap ROP1 and ROP2 efficiently.  Both the values and the precisions
+     of the two variables are swapped.
 
 
 File: gmp.info,  Node: Simultaneous Float Init & Assign,  Next: Converting Floats,  Prev: Assigning Floats,  Up: Floating-point Functions
@@ -3654,12 +3631,12 @@ File: gmp.info,  Node: Simultaneous Float Init & Assign,  Next: Converting Float
 
 For convenience, GMP provides a parallel series of initialize-and-set
 functions which initialize the output and then store the value there.
-These functions' names have the form `mpf_init_set...'
+These functions' names have the form 'mpf_init_set...'
 
-   Once the float has been initialized by any of the `mpf_init_set...'
+   Once the float has been initialized by any of the 'mpf_init_set...'
 functions, it can be used as the source or destination operand for the
-ordinary float functions.  Don't use an initialize-and-set function on
-a variable already initialized!
+ordinary float functions.  Don't use an initialize-and-set function on a
+variable already initialized!
 
  -- Function: void mpf_init_set (mpf_t ROP, mpf_t OP)
  -- Function: void mpf_init_set_ui (mpf_t ROP, unsigned long int OP)
@@ -3668,17 +3645,17 @@ a variable already initialized!
      Initialize ROP and set its value from OP.
 
      The precision of ROP will be taken from the active default
-     precision, as set by `mpf_set_default_prec'.
+     precision, as set by 'mpf_set_default_prec'.
 
  -- Function: int mpf_init_set_str (mpf_t ROP, char *STR, int BASE)
      Initialize ROP and set its value from the string in STR.  See
-     `mpf_set_str' above for details on the assignment operation.
+     'mpf_set_str' above for details on the assignment operation.
 
      Note that ROP is initialized even if an error occurs.  (I.e., you
-     have to call `mpf_clear' for it.)
+     have to call 'mpf_clear' for it.)
 
      The precision of ROP will be taken from the active default
-     precision, as set by `mpf_set_default_prec'.
+     precision, as set by 'mpf_set_default_prec'.
 
 
 File: gmp.info,  Node: Converting Floats,  Next: Float Arithmetic,  Prev: Simultaneous Float Init & Assign,  Up: Floating-point Functions
@@ -3687,58 +3664,58 @@ File: gmp.info,  Node: Converting Floats,  Next: Float Arithmetic,  Prev: Simult
 ========================
 
  -- Function: double mpf_get_d (mpf_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
+     Convert OP to a 'double', truncating if necessary (ie. rounding
      towards zero).
 
-     If the exponent in OP is too big or too small to fit a `double'
+     If the exponent in OP is too big or too small to fit a 'double'
      then the result is system dependent.  For too big an infinity is
      returned when available.  For too small 0.0 is normally returned.
      Hardware overflow, underflow and denorm traps may or may not occur.
 
  -- Function: double mpf_get_d_2exp (signed long int *EXP, mpf_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
+     Convert OP to a 'double', truncating if necessary (ie. rounding
      towards zero), and with an exponent returned separately.
 
      The return value is in the range 0.5<=abs(D)<1 and the exponent is
-     stored to `*EXP'.  D * 2^EXP is the (truncated) OP value.  If OP
-     is zero, the return is 0.0 and 0 is stored to `*EXP'.
+     stored to '*EXP'.  D * 2^EXP is the (truncated) OP value.  If OP is
+     zero, the return is 0.0 and 0 is stored to '*EXP'.
 
-     This is similar to the standard C `frexp' function (*note
-     Normalization Functions: (libc)Normalization Functions.).
+     This is similar to the standard C 'frexp' function (*note
+     (libc)Normalization Functions::).
 
  -- Function: long mpf_get_si (mpf_t OP)
  -- Function: unsigned long mpf_get_ui (mpf_t OP)
-     Convert OP to a `long' or `unsigned long', truncating any fraction
+     Convert OP to a 'long' or 'unsigned long', truncating any fraction
      part.  If OP is too big for the return type, the result is
      undefined.
 
-     See also `mpf_fits_slong_p' and `mpf_fits_ulong_p' (*note
+     See also 'mpf_fits_slong_p' and 'mpf_fits_ulong_p' (*note
      Miscellaneous Float Functions::).
 
- -- Function: char * mpf_get_str (char *STR, mp_exp_t *EXPPTR, int
-          BASE, size_t N_DIGITS, mpf_t OP)
+ -- Function: char * mpf_get_str (char *STR, mp_exp_t *EXPPTR, int BASE,
+          size_t N_DIGITS, mpf_t OP)
      Convert OP to a string of digits in base BASE.  The base argument
      may vary from 2 to 62 or from -2 to -36.  Up to N_DIGITS digits
      will be generated.  Trailing zeros are not returned.  No more
-     digits than can be accurately represented by OP are ever
-     generated.  If N_DIGITS is 0 then that accurate maximum number of
-     digits are generated.
+     digits than can be accurately represented by OP are ever generated.
+     If N_DIGITS is 0 then that accurate maximum number of digits are
+     generated.
 
      For BASE in the range 2..36, digits and lower-case letters are
      used; for -2..-36, digits and upper-case letters are used; for
-     37..62, digits, upper-case letters, and lower-case letters (in
-     that significance order) are used.
+     37..62, digits, upper-case letters, and lower-case letters (in that
+     significance order) are used.
 
-     If STR is `NULL', the result string is allocated using the current
+     If STR is 'NULL', the result string is allocated using the current
      allocation function (*note Custom Allocation::).  The block will be
-     `strlen(str)+1' bytes, that being exactly enough for the string and
+     'strlen(str)+1' bytes, that being exactly enough for the string and
      null-terminator.
 
-     If STR is not `NULL', it should point to a block of N_DIGITS + 2
+     If STR is not 'NULL', it should point to a block of N_DIGITS + 2
      bytes, that being enough for the mantissa, a possible minus sign,
      and a null-terminator.  When N_DIGITS is 0 to get all significant
      digits, an application won't be able to know the space required,
-     and STR should be `NULL' in that case.
+     and STR should be 'NULL' in that case.
 
      The generated string is a fraction, with an implicit radix point
      immediately to the left of the first digit.  The applicable
@@ -3816,10 +3793,10 @@ File: gmp.info,  Node: Float Comparison,  Next: I/O of Floats,  Prev: Float Arit
  -- Function: int mpf_cmp_d (mpf_t OP1, double OP2)
  -- Function: int mpf_cmp_ui (mpf_t OP1, unsigned long int OP2)
  -- Function: int mpf_cmp_si (mpf_t OP1, signed long int OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, and a negative value if OP1 < OP2.
+     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero if
+     OP1 = OP2, and a negative value if OP1 < OP2.
 
-     `mpf_cmp_d' can be called with an infinity, but results are
+     'mpf_cmp_d' can be called with an infinity, but results are
      undefined for a NaN.
 
  -- Function: int mpf_eq (mpf_t OP1, mpf_t OP2, mp_bitcnt_t op3)
@@ -3830,7 +3807,7 @@ File: gmp.info,  Node: Float Comparison,  Next: I/O of Floats,  Prev: Float Arit
      whole limbs, meaning sometimes more than OP3 bits, sometimes fewer.
 
      Caution 2: This function will consider XXX11...111 and XX100...000
-     different, even if ... is replaced by a semi-infinite number of
+     different, even if ...  is replaced by a semi-infinite number of
      bits.  Such numbers are really just one ulp off, and should be
      considered equal.
 
@@ -3841,8 +3818,8 @@ File: gmp.info,  Node: Float Comparison,  Next: I/O of Floats,  Prev: Float Arit
  -- Macro: int mpf_sgn (mpf_t OP)
      Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.
 
-     This function is actually implemented as a macro.  It evaluates
-     its arguments multiple times.
+     This function is actually implemented as a macro.  It evaluates its
+     arguments multiple times.
 
 
 File: gmp.info,  Node: I/O of Floats,  Next: Miscellaneous Float Functions,  Prev: Float Comparison,  Up: Floating-point Functions
@@ -3851,12 +3828,12 @@ File: gmp.info,  Node: I/O of Floats,  Next: Miscellaneous Float Functions,  Pre
 ==============================
 
 Functions that perform input from a stdio stream, and functions that
-output to a stdio stream, of `mpf' numbers.  Passing a `NULL' pointer
+output to a stdio stream, of 'mpf' numbers.  Passing a 'NULL' pointer
 for a STREAM argument to any of these functions will make them read from
-`stdin' and write to `stdout', respectively.
+'stdin' and write to 'stdout', respectively.
 
    When using any of these functions, it is a good idea to include
-`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
+'stdio.h' before 'gmp.h', since that will allow 'gmp.h' to define
 prototypes for these functions.
 
    See also *note Formatted Output:: and *note Formatted Input::.
@@ -3866,17 +3843,17 @@ prototypes for these functions.
      Print OP to STREAM, as a string of digits.  Return the number of
      bytes written, or if an error occurred, return 0.
 
-     The mantissa is prefixed with an `0.' and is in the given BASE,
-     which may vary from 2 to 62 or from -2 to -36.  An exponent is
-     then printed, separated by an `e', or if the base is greater than
-     10 then by an `@'.  The exponent is always in decimal.  The
-     decimal point follows the current locale, on systems providing
-     `localeconv'.
+     The mantissa is prefixed with an '0.' and is in the given BASE,
+     which may vary from 2 to 62 or from -2 to -36.  An exponent is then
+     printed, separated by an 'e', or if the base is greater than 10
+     then by an '@'.  The exponent is always in decimal.  The decimal
+     point follows the current locale, on systems providing
+     'localeconv'.
 
      For BASE in the range 2..36, digits and lower-case letters are
      used; for -2..-36, digits and upper-case letters are used; for
-     37..62, digits, upper-case letters, and lower-case letters (in
-     that significance order) are used.
+     37..62, digits, upper-case letters, and lower-case letters (in that
+     significance order) are used.
 
      Up to N_DIGITS will be printed from the mantissa, except that no
      more digits than are accurately representable by OP will be
@@ -3884,20 +3861,20 @@ prototypes for these functions.
 
  -- Function: size_t mpf_inp_str (mpf_t ROP, FILE *STREAM, int BASE)
      Read a string in base BASE from STREAM, and put the read float in
-     ROP.  The string is of the form `M@N' or, if the base is 10 or
-     less, alternatively `MeN'.  `M' is the mantissa and `N' is the
+     ROP.  The string is of the form 'M@N' or, if the base is 10 or
+     less, alternatively 'MeN'.  'M' is the mantissa and 'N' is the
      exponent.  The mantissa is always in the specified base.  The
      exponent is either in the specified base or, if BASE is negative,
      in decimal.  The decimal point expected is taken from the current
-     locale, on systems providing `localeconv'.
+     locale, on systems providing 'localeconv'.
 
      The argument BASE may be in the ranges 2 to 36, or -36 to -2.
      Negative values are used to specify that the exponent is in
      decimal.
 
-     Unlike the corresponding `mpz' function, the base will not be
+     Unlike the corresponding 'mpz' function, the base will not be
      determined from the leading characters of the string if BASE is 0.
-     This is so that numbers like `0.23' are not interpreted as octal.
+     This is so that numbers like '0.23' are not interpreted as octal.
 
      Return the number of bytes read, or if an error occurred, return 0.
 
@@ -3910,9 +3887,9 @@ File: gmp.info,  Node: Miscellaneous Float Functions,  Prev: I/O of Floats,  Up:
  -- Function: void mpf_ceil (mpf_t ROP, mpf_t OP)
  -- Function: void mpf_floor (mpf_t ROP, mpf_t OP)
  -- Function: void mpf_trunc (mpf_t ROP, mpf_t OP)
-     Set ROP to OP rounded to an integer.  `mpf_ceil' rounds to the
-     next higher integer, `mpf_floor' to the next lower, and `mpf_trunc'
-     to the integer towards zero.
+     Set ROP to OP rounded to an integer.  'mpf_ceil' rounds to the next
+     higher integer, 'mpf_floor' to the next lower, and 'mpf_trunc' to
+     the integer towards zero.
 
  -- Function: int mpf_integer_p (mpf_t OP)
      Return non-zero if OP is an integer.
@@ -3933,7 +3910,7 @@ File: gmp.info,  Node: Miscellaneous Float Functions,  Prev: I/O of Floats,  Up:
      the precision of ROP is smaller.
 
      The variable STATE must be initialized by calling one of the
-     `gmp_randinit' functions (*note Random State Initialization::)
+     'gmp_randinit' functions (*note Random State Initialization::)
      before invoking this function.
 
  -- Function: void mpf_random2 (mpf_t ROP, mp_size_t MAX_SIZE, mp_exp_t
@@ -3941,10 +3918,10 @@ File: gmp.info,  Node: Miscellaneous Float Functions,  Prev: I/O of Floats,  Up:
      Generate a random float of at most MAX_SIZE limbs, with long
      strings of zeros and ones in the binary representation.  The
      exponent of the number is in the interval -EXP to EXP (in limbs).
-     This function is useful for testing functions and algorithms,
-     since these kind of random numbers have proven to be more likely
-     to trigger corner-case bugs.  Negative random numbers are
-     generated when MAX_SIZE is negative.
+     This function is useful for testing functions and algorithms, since
+     these kind of random numbers have proven to be more likely to
+     trigger corner-case bugs.  Negative random numbers are generated
+     when MAX_SIZE is negative.
 
 
 File: gmp.info,  Node: Low-level Functions,  Next: Random Number Functions,  Prev: Floating-point Functions,  Up: Top
@@ -3955,9 +3932,9 @@ File: gmp.info,  Node: Low-level Functions,  Next: Random Number Functions,  Pre
 This chapter describes low-level GMP functions, used to implement the
 high-level GMP functions, but also intended for time-critical user code.
 
-   These functions start with the prefix `mpn_'.
+   These functions start with the prefix 'mpn_'.
 
-   The `mpn' functions are designed to be as fast as possible, *not* to
+   The 'mpn' functions are designed to be as fast as possible, *not* to
 provide a coherent calling interface.  The different functions have
 somewhat similar interfaces, but there are variations that make them
 hard to use.  These functions do as little as possible apart from the
@@ -3973,20 +3950,20 @@ destination has enough space for storing the result.
 computations on subranges of an argument, and store the result into a
 subrange of a destination.
 
-   A common requirement for all functions is that each source area
-needs at least one limb.  No size argument may be zero.  Unless
-otherwise stated, in-place operations are allowed where source and
-destination are the same, but not where they only partly overlap.
+   A common requirement for all functions is that each source area needs
+at least one limb.  No size argument may be zero.  Unless otherwise
+stated, in-place operations are allowed where source and destination are
+the same, but not where they only partly overlap.
 
-   The `mpn' functions are the base for the implementation of the
-`mpz_', `mpf_', and `mpq_' functions.
+   The 'mpn' functions are the base for the implementation of the
+'mpz_', 'mpf_', and 'mpq_' functions.
 
    This example adds the number beginning at S1P and the number
 beginning at S2P and writes the sum at DESTP.  All areas have N limbs.
 
      cy = mpn_add_n (destp, s1p, s2p, n)
 
-   It should be noted that the `mpn' functions make no attempt to
+   It should be noted that the 'mpn' functions make no attempt to
 identify high or low zero limbs on their operands, or other special
 forms.  On random data such cases will be unlikely and it'd be wasteful
 for every function to check every time.  An application knowing
@@ -4006,12 +3983,12 @@ For example, {S1P, S1N}.
      This is the lowest-level function for addition.  It is the
      preferred function for addition, since it is written in assembly
      for most CPUs.  For addition of a variable to itself (i.e., S1P
-     equals S2P) use `mpn_lshift' with a count of 1 for optimal speed.
+     equals S2P) use 'mpn_lshift' with a count of 1 for optimal speed.
 
  -- Function: mp_limb_t mpn_add_1 (mp_limb_t *RP, const mp_limb_t *S1P,
           mp_size_t N, mp_limb_t S2LIMB)
-     Add {S1P, N} and S2LIMB, and write the N least significant limbs
-     of the result to RP.  Return carry, either 0 or 1.
+     Add {S1P, N} and S2LIMB, and write the N least significant limbs of
+     the result to RP.  Return carry, either 0 or 1.
 
  -- Function: mp_limb_t mpn_add (mp_limb_t *RP, const mp_limb_t *S1P,
           mp_size_t S1N, const mp_limb_t *S2P, mp_size_t S2N)
@@ -4026,8 +4003,8 @@ For example, {S1P, S1N}.
      limbs of the result to RP.  Return borrow, either 0 or 1.
 
      This is the lowest-level function for subtraction.  It is the
-     preferred function for subtraction, since it is written in
-     assembly for most CPUs.
+     preferred function for subtraction, since it is written in assembly
+     for most CPUs.
 
  -- Function: mp_limb_t mpn_sub_1 (mp_limb_t *RP, const mp_limb_t *S1P,
           mp_size_t N, mp_limb_t S2LIMB)
@@ -4047,8 +4024,8 @@ For example, {S1P, S1N}.
      Perform the negation of {SP, N}, and write the result to {RP, N}.
      Return carry-out.
 
- -- Function: void mpn_mul_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
+ -- Function: void mpn_mul_n (mp_limb_t *RP, const mp_limb_t *S1P, const
+          mp_limb_t *S2P, mp_size_t N)
      Multiply {S1P, N} and {S2P, N}, and write the 2*N-limb result to
      RP.
 
@@ -4056,7 +4033,7 @@ For example, {S1P, S1N}.
      product's most significant limb is zero.  No overlap is permitted
      between the destination and either source.
 
-     If the two input operands are the same, use `mpn_sqr'.
+     If the two input operands are the same, use 'mpn_sqr'.
 
  -- Function: mp_limb_t mpn_mul (mp_limb_t *RP, const mp_limb_t *S1P,
           mp_size_t S1N, const mp_limb_t *S2P, mp_size_t S2N)
@@ -4089,15 +4066,15 @@ For example, {S1P, S1N}.
      in assembly for most CPUs.
 
      Don't call this function if S2LIMB is a power of 2; use
-     `mpn_lshift' with a count equal to the logarithm of S2LIMB
-     instead, for optimal speed.
+     'mpn_lshift' with a count equal to the logarithm of S2LIMB instead,
+     for optimal speed.
 
  -- Function: mp_limb_t mpn_addmul_1 (mp_limb_t *RP, const mp_limb_t
           *S1P, mp_size_t N, mp_limb_t S2LIMB)
-     Multiply {S1P, N} and S2LIMB, and add the N least significant
-     limbs of the product to {RP, N} and write the result to RP.
-     Return the most significant limb of the product, plus carry-out
-     from the addition.
+     Multiply {S1P, N} and S2LIMB, and add the N least significant limbs
+     of the product to {RP, N} and write the result to RP.  Return the
+     most significant limb of the product, plus carry-out from the
+     addition.
 
      This is a low-level function that is a building block for general
      multiplication as well as other operations in GMP.  It is written
@@ -4111,8 +4088,8 @@ For example, {S1P, S1N}.
      from the subtraction.
 
      This is a low-level function that is a building block for general
-     multiplication and division as well as other operations in GMP.
-     It is written in assembly for most CPUs.
+     multiplication and division as well as other operations in GMP.  It
+     is written in assembly for most CPUs.
 
  -- Function: void mpn_tdiv_qr (mp_limb_t *QP, mp_limb_t *RP, mp_size_t
           QXN, const mp_limb_t *NP, mp_size_t NN, const mp_limb_t *DP,
@@ -4128,13 +4105,13 @@ For example, {S1P, S1N}.
  -- Function: mp_limb_t mpn_divrem (mp_limb_t *R1P, mp_size_t QXN,
           mp_limb_t *RS2P, mp_size_t RS2N, const mp_limb_t *S3P,
           mp_size_t S3N)
-     [This function is obsolete.  Please call `mpn_tdiv_qr' instead for
+     [This function is obsolete.  Please call 'mpn_tdiv_qr' instead for
      best performance.]
 
      Divide {RS2P, RS2N} by {S3P, S3N}, and write the quotient at R1P,
-     with the exception of the most significant limb, which is
-     returned.  The remainder replaces the dividend at RS2P; it will be
-     S3N limbs long (i.e., as many limbs as the divisor).
+     with the exception of the most significant limb, which is returned.
+     The remainder replaces the dividend at RS2P; it will be S3N limbs
+     long (i.e., as many limbs as the divisor).
 
      In addition to an integer quotient, QXN fraction limbs are
      developed, and stored after the integral limbs.  For most usages,
@@ -4154,50 +4131,49 @@ For example, {S1P, S1N}.
           mp_limb_t *S2P, mp_size_t S2N, mp_limb_t S3LIMB)
  -- Macro: mp_limb_t mpn_divmod_1 (mp_limb_t *R1P, mp_limb_t *S2P,
           mp_size_t S2N, mp_limb_t S3LIMB)
-     Divide {S2P, S2N} by S3LIMB, and write the quotient at R1P.
-     Return the remainder.
+     Divide {S2P, S2N} by S3LIMB, and write the quotient at R1P.  Return
+     the remainder.
 
      The integer quotient is written to {R1P+QXN, S2N} and in addition
-     QXN fraction limbs are developed and written to {R1P, QXN}.
-     Either or both S2N and QXN can be zero.  For most usages, QXN will
-     be zero.
+     QXN fraction limbs are developed and written to {R1P, QXN}.  Either
+     or both S2N and QXN can be zero.  For most usages, QXN will be
+     zero.
 
-     `mpn_divmod_1' exists for upward source compatibility and is
-     simply a macro calling `mpn_divrem_1' with a QXN of 0.
+     'mpn_divmod_1' exists for upward source compatibility and is simply
+     a macro calling 'mpn_divrem_1' with a QXN of 0.
 
      The areas at R1P and S2P have to be identical or completely
      separate, not partially overlapping.
 
  -- Function: mp_limb_t mpn_divmod (mp_limb_t *R1P, mp_limb_t *RS2P,
           mp_size_t RS2N, const mp_limb_t *S3P, mp_size_t S3N)
-     [This function is obsolete.  Please call `mpn_tdiv_qr' instead for
+     [This function is obsolete.  Please call 'mpn_tdiv_qr' instead for
      best performance.]
 
  -- Macro: mp_limb_t mpn_divexact_by3 (mp_limb_t *RP, mp_limb_t *SP,
           mp_size_t N)
- -- Function: mp_limb_t mpn_divexact_by3c (mp_limb_t *RP, mp_limb_t
-          *SP, mp_size_t N, mp_limb_t CARRY)
+ -- Function: mp_limb_t mpn_divexact_by3c (mp_limb_t *RP, mp_limb_t *SP,
+          mp_size_t N, mp_limb_t CARRY)
      Divide {SP, N} by 3, expecting it to divide exactly, and writing
      the result to {RP, N}.  If 3 divides exactly, the return value is
      zero and the result is the quotient.  If not, the return value is
      non-zero and the result won't be anything useful.
 
-     `mpn_divexact_by3c' takes an initial carry parameter, which can be
+     'mpn_divexact_by3c' takes an initial carry parameter, which can be
      the return value from a previous call, so a large calculation can
-     be done piece by piece from low to high.  `mpn_divexact_by3' is
-     simply a macro calling `mpn_divexact_by3c' with a 0 carry
+     be done piece by piece from low to high.  'mpn_divexact_by3' is
+     simply a macro calling 'mpn_divexact_by3c' with a 0 carry
      parameter.
 
      These routines use a multiply-by-inverse and will be faster than
-     `mpn_divrem_1' on CPUs with fast multiplication but slow division.
+     'mpn_divrem_1' on CPUs with fast multiplication but slow division.
 
-     The source a, result q, size n, initial carry i, and return value
-     c satisfy c*b^n + a-i = 3*q, where b=2^GMP_NUMB_BITS.  The return
-     c is always 0, 1 or 2, and the initial carry i must also be 0, 1
-     or 2 (these are both borrows really).  When c=0 clearly q=(a-i)/3.
-     When c!=0, the remainder (a-i) mod 3 is given by 3-c, because b ==
-     1 mod 3 (when `mp_bits_per_limb' is even, which is always so
-     currently).
+     The source a, result q, size n, initial carry i, and return value c
+     satisfy c*b^n + a-i = 3*q, where b=2^GMP_NUMB_BITS. The return c is
+     always 0, 1 or 2, and the initial carry i must also be 0, 1 or 2
+     (these are both borrows really).  When c=0 clearly q=(a-i)/3.  When
+     c!=0, the remainder (a-i) mod 3 is given by 3-c, because b == 1 mod
+     3 (when 'mp_bits_per_limb' is even, which is always so currently).
 
  -- Function: mp_limb_t mpn_mod_1 (const mp_limb_t *S1P, mp_size_t S1N,
           mp_limb_t S2LIMB)
@@ -4218,8 +4194,8 @@ For example, {S1P, S1N}.
 
  -- Function: mp_limb_t mpn_rshift (mp_limb_t *RP, const mp_limb_t *SP,
           mp_size_t N, unsigned int COUNT)
-     Shift {SP, N} right by COUNT bits, and write the result to {RP,
-     N}.  The bits shifted out at the right are returned in the most
+     Shift {SP, N} right by COUNT bits, and write the result to {RP, N}.
+     The bits shifted out at the right are returned in the most
      significant COUNT bits of the return value (the rest of the return
      value is zero).
 
@@ -4233,8 +4209,8 @@ For example, {S1P, S1N}.
      Compare {S1P, N} and {S2P, N} and return a positive value if S1 >
      S2, 0 if they are equal, or a negative value if S1 < S2.
 
- -- Function: mp_size_t mpn_gcd (mp_limb_t *RP, mp_limb_t *XP,
-          mp_size_t XN, mp_limb_t *YP, mp_size_t YN)
+ -- Function: mp_size_t mpn_gcd (mp_limb_t *RP, mp_limb_t *XP, mp_size_t
+          XN, mp_limb_t *YP, mp_size_t YN)
      Set {RP, RETVAL} to the greatest common divisor of {XP, XN} and
      {YP, YN}.  The result can be up to YN limbs, the return value is
      the actual number produced.  Both source operands are destroyed.
@@ -4253,8 +4229,8 @@ For example, {S1P, S1N}.
           mp_size_t YN)
      Let U be defined by {XP, XN} and let V be defined by {YP, YN}.
 
-     Compute the greatest common divisor G of U and V.  Compute a
-     cofactor S such that G = US + VT.  The second cofactor T is not
+     Compute the greatest common divisor G of U and V. Compute a
+     cofactor S such that G = US + VT. The second cofactor T is not
      computed but can easily be obtained from (G - U*S) / V (the
      division will be exact).  It is required that U >= V > 0.
 
@@ -4275,32 +4251,32 @@ For example, {S1P, S1N}.
  -- Function: mp_size_t mpn_sqrtrem (mp_limb_t *R1P, mp_limb_t *R2P,
           const mp_limb_t *SP, mp_size_t N)
      Compute the square root of {SP, N} and put the result at {R1P,
-     ceil(N/2)} and the remainder at {R2P, RETVAL}.  R2P needs space
-     for N limbs, but the return value indicates how many are produced.
+     ceil(N/2)} and the remainder at {R2P, RETVAL}.  R2P needs space for
+     N limbs, but the return value indicates how many are produced.
 
      The most significant limb of {SP, N} must be non-zero.  The areas
      {R1P, ceil(N/2)} and {SP, N} must be completely separate.  The
      areas {R2P, N} and {SP, N} must be either identical or completely
      separate.
 
-     If the remainder is not wanted then R2P can be `NULL', and in this
+     If the remainder is not wanted then R2P can be 'NULL', and in this
      case the return value is zero or non-zero according to whether the
      remainder would have been zero or non-zero.
 
      A return value of zero indicates a perfect square.  See also
-     `mpz_perfect_square_p'.
+     'mpz_perfect_square_p'.
 
  -- Function: mp_size_t mpn_get_str (unsigned char *STR, int BASE,
           mp_limb_t *S1P, mp_size_t S1N)
      Convert {S1P, S1N} to a raw unsigned char array at STR in base
      BASE, and return the number of characters produced.  There may be
      leading zeros in the string.  The string is not in ASCII; to
-     convert it to printable format, add the ASCII codes for `0' or
-     `A', depending on the base and range.  BASE can vary from 2 to 256.
+     convert it to printable format, add the ASCII codes for '0' or 'A',
+     depending on the base and range.  BASE can vary from 2 to 256.
 
-     The most significant limb of the input {S1P, S1N} must be
-     non-zero.  The input {S1P, S1N} is clobbered, except when BASE is
-     a power of 2, in which case it's unchanged.
+     The most significant limb of the input {S1P, S1N} must be non-zero.
+     The input {S1P, S1N} is clobbered, except when BASE is a power of
+     2, in which case it's unchanged.
 
      The area at STR has to have space for the largest possible number
      represented by a S1N long limb array, plus one extra character.
@@ -4309,9 +4285,9 @@ For example, {S1P, S1N}.
           *STR, size_t STRSIZE, int BASE)
      Convert bytes {STR,STRSIZE} in the given BASE to limbs at RP.
 
-     STR[0] is the most significant byte and STR[STRSIZE-1] is the
-     least significant.  Each byte should be a value in the range 0 to
-     BASE-1, not an ASCII character.  BASE can vary from 2 to 256.
+     STR[0] is the most significant byte and STR[STRSIZE-1] is the least
+     significant.  Each byte should be a value in the range 0 to BASE-1,
+     not an ASCII character.  BASE can vary from 2 to 256.
 
      The return value is the number of limbs written to RP.  If the most
      significant input byte is non-zero then the high limb at RP will be
@@ -4343,11 +4319,11 @@ For example, {S1P, S1N}.
  -- Function: void mpn_random (mp_limb_t *R1P, mp_size_t R1N)
  -- Function: void mpn_random2 (mp_limb_t *R1P, mp_size_t R1N)
      Generate a random number of length R1N and store it at R1P.  The
-     most significant limb is always non-zero.  `mpn_random' generates
-     uniformly distributed limb data, `mpn_random2' generates long
+     most significant limb is always non-zero.  'mpn_random' generates
+     uniformly distributed limb data, 'mpn_random2' generates long
      strings of zeros and ones in the binary representation.
 
-     `mpn_random2' is intended for testing the correctness of the `mpn'
+     'mpn_random2' is intended for testing the correctness of the 'mpn'
      routines.
 
  -- Function: mp_bitcnt_t mpn_popcount (const mp_limb_t *S1P, mp_size_t
@@ -4365,18 +4341,18 @@ For example, {S1P, S1N}.
      Return non-zero iff {S1P, N} is a perfect square.  The most
      significant limb of the input {S1P, N} must be non-zero.
 
- -- Function: void mpn_and_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical and of {S1P, N} and {S2P, N}, and
-     write the result to {RP, N}.
+ -- Function: void mpn_and_n (mp_limb_t *RP, const mp_limb_t *S1P, const
+          mp_limb_t *S2P, mp_size_t N)
+     Perform the bitwise logical and of {S1P, N} and {S2P, N}, and write
+     the result to {RP, N}.
 
- -- Function: void mpn_ior_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
+ -- Function: void mpn_ior_n (mp_limb_t *RP, const mp_limb_t *S1P, const
+          mp_limb_t *S2P, mp_size_t N)
      Perform the bitwise logical inclusive or of {S1P, N} and {S2P, N},
      and write the result to {RP, N}.
 
- -- Function: void mpn_xor_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
+ -- Function: void mpn_xor_n (mp_limb_t *RP, const mp_limb_t *S1P, const
+          mp_limb_t *S2P, mp_size_t N)
      Perform the bitwise logical exclusive or of {S1P, N} and {S2P, N},
      and write the result to {RP, N}.
 
@@ -4392,8 +4368,8 @@ For example, {S1P, S1N}.
 
  -- Function: void mpn_nand_n (mp_limb_t *RP, const mp_limb_t *S1P,
           const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical and of {S1P, N} and {S2P, N}, and
-     write the bitwise complement of the result to {RP, N}.
+     Perform the bitwise logical and of {S1P, N} and {S2P, N}, and write
+     the bitwise complement of the result to {RP, N}.
 
  -- Function: void mpn_nior_n (mp_limb_t *RP, const mp_limb_t *S1P,
           const mp_limb_t *S2P, mp_size_t N)
@@ -4429,18 +4405,17 @@ For example, {S1P, S1N}.
 be subject to incompatible changes in a future version of GMP.*
 
    Nails are an experimental feature whereby a few bits are left unused
-at the top of each `mp_limb_t'.  This can significantly improve carry
+at the top of each 'mp_limb_t'.  This can significantly improve carry
 handling on some processors.
 
-   All the `mpn' functions accepting limb data will expect the nail
-bits to be zero on entry, and will return data with the nails similarly
-all zero.  This applies both to limb vectors and to single limb
-arguments.
+   All the 'mpn' functions accepting limb data will expect the nail bits
+to be zero on entry, and will return data with the nails similarly all
+zero.  This applies both to limb vectors and to single limb arguments.
 
-   Nails can be enabled by configuring with `--enable-nails'.  By
+   Nails can be enabled by configuring with '--enable-nails'.  By
 default the number of bits will be chosen according to what suits the
 host processor, but a particular number can be selected with
-`--enable-nails=N'.
+'--enable-nails=N'.
 
    At the mpn level, a nail build is neither source nor binary
 compatible with a non-nail build, strictly speaking.  But programs
@@ -4449,31 +4424,31 @@ equally well with either build, and judicious use of the definitions
 below should make any program compatible with either build, at the
 source level.
 
-   For the higher level routines, meaning `mpz' etc, a nail build
-should be fully source and binary compatible with a non-nail build.
+   For the higher level routines, meaning 'mpz' etc, a nail build should
+be fully source and binary compatible with a non-nail build.
 
  -- Macro: GMP_NAIL_BITS
  -- Macro: GMP_NUMB_BITS
  -- Macro: GMP_LIMB_BITS
-     `GMP_NAIL_BITS' is the number of nail bits, or 0 when nails are
-     not in use.  `GMP_NUMB_BITS' is the number of data bits in a limb.
-     `GMP_LIMB_BITS' is the total number of bits in an `mp_limb_t'.  In
+     'GMP_NAIL_BITS' is the number of nail bits, or 0 when nails are not
+     in use.  'GMP_NUMB_BITS' is the number of data bits in a limb.
+     'GMP_LIMB_BITS' is the total number of bits in an 'mp_limb_t'.  In
      all cases
 
           GMP_LIMB_BITS == GMP_NAIL_BITS + GMP_NUMB_BITS
 
  -- Macro: GMP_NAIL_MASK
  -- Macro: GMP_NUMB_MASK
-     Bit masks for the nail and number parts of a limb.
-     `GMP_NAIL_MASK' is 0 when nails are not in use.
+     Bit masks for the nail and number parts of a limb.  'GMP_NAIL_MASK'
+     is 0 when nails are not in use.
 
-     `GMP_NAIL_MASK' is not often needed, since the nail part can be
-     obtained with `x >> GMP_NUMB_BITS', and that means one less large
+     'GMP_NAIL_MASK' is not often needed, since the nail part can be
+     obtained with 'x >> GMP_NUMB_BITS', and that means one less large
      constant, which can help various RISC chips.
 
  -- Macro: GMP_NUMB_MAX
      The maximum value that can be stored in the number part of a limb.
-     This is the same as `GMP_NUMB_MASK', but can be used for clarity
+     This is the same as 'GMP_NUMB_MASK', but can be used for clarity
      when doing comparisons rather than bit-wise operations.
 
    The term "nails" comes from finger or toe nails, which are at the
@@ -4483,8 +4458,8 @@ sensible names for these things.
 
    In the future (the distant future most likely) a non-zero nail might
 be permitted, giving non-unique representations for numbers in a limb
-vector.  This would help vector processors since carries would only
-ever need to propagate one or two limbs.
+vector.  This would help vector processors since carries would only ever
+need to propagate one or two limbs.
 
 
 File: gmp.info,  Node: Random Number Functions,  Next: Formatted Output,  Prev: Low-level Functions,  Up: Top
@@ -4492,22 +4467,22 @@ File: gmp.info,  Node: Random Number Functions,  Next: Formatted Output,  Prev:
 9 Random Number Functions
 *************************
 
-Sequences of pseudo-random numbers in GMP are generated using a
-variable of type `gmp_randstate_t', which holds an algorithm selection
-and a current state.  Such a variable must be initialized by a call to
-one of the `gmp_randinit' functions, and can be seeded with one of the
-`gmp_randseed' functions.
+Sequences of pseudo-random numbers in GMP are generated using a variable
+of type 'gmp_randstate_t', which holds an algorithm selection and a
+current state.  Such a variable must be initialized by a call to one of
+the 'gmp_randinit' functions, and can be seeded with one of the
+'gmp_randseed' functions.
 
    The functions actually generating random numbers are described in
 *note Integer Random Numbers::, and *note Miscellaneous Float
 Functions::.
 
    The older style random number functions don't accept a
-`gmp_randstate_t' parameter but instead share a global variable of that
-type.  They use a default algorithm and are currently not seeded
-(though perhaps that will change in the future).  The new functions
-accepting a `gmp_randstate_t' are recommended for applications that
-care about randomness.
+'gmp_randstate_t' parameter but instead share a global variable of that
+type.  They use a default algorithm and are currently not seeded (though
+perhaps that will change in the future).  The new functions accepting a
+'gmp_randstate_t' are recommended for applications that care about
+randomness.
 
 * Menu:
 
@@ -4525,16 +4500,16 @@ File: gmp.info,  Node: Random State Initialization,  Next: Random State Seeding,
      Initialize STATE with a default algorithm.  This will be a
      compromise between speed and randomness, and is recommended for
      applications with no special requirements.  Currently this is
-     `gmp_randinit_mt'.
+     'gmp_randinit_mt'.
 
  -- Function: void gmp_randinit_mt (gmp_randstate_t STATE)
      Initialize STATE for a Mersenne Twister algorithm.  This algorithm
      is fast and has good randomness properties.
 
- -- Function: void gmp_randinit_lc_2exp (gmp_randstate_t STATE, mpz_t
-          A, unsigned long C, mp_bitcnt_t M2EXP)
-     Initialize STATE with a linear congruential algorithm X = (A*X +
-     C) mod 2^M2EXP.
+ -- Function: void gmp_randinit_lc_2exp (gmp_randstate_t STATE, mpz_t A,
+          unsigned long C, mp_bitcnt_t M2EXP)
+     Initialize STATE with a linear congruential algorithm X = (A*X + C)
+     mod 2^M2EXP.
 
      The low bits of X in this algorithm are not very random.  The least
      significant bit will have a period no more than 2, and the second
@@ -4548,13 +4523,13 @@ File: gmp.info,  Node: Random State Initialization,  Next: Random State Seeding,
  -- Function: int gmp_randinit_lc_2exp_size (gmp_randstate_t STATE,
           mp_bitcnt_t SIZE)
      Initialize STATE for a linear congruential algorithm as per
-     `gmp_randinit_lc_2exp'.  A, C and M2EXP are selected from a table,
+     'gmp_randinit_lc_2exp'.  A, C and M2EXP are selected from a table,
      chosen so that SIZE bits (or more) of each X will be used, ie.
      M2EXP/2 >= SIZE.
 
-     If successful the return value is non-zero.  If SIZE is bigger
-     than the table data provides then the return value is zero.  The
-     maximum SIZE currently supported is 128.
+     If successful the return value is non-zero.  If SIZE is bigger than
+     the table data provides then the return value is zero.  The maximum
+     SIZE currently supported is 128.
 
  -- Function: void gmp_randinit_set (gmp_randstate_t ROP,
           gmp_randstate_t OP)
@@ -4565,16 +4540,16 @@ File: gmp.info,  Node: Random State Initialization,  Next: Random State Seeding,
      *This function is obsolete.*
 
      Initialize STATE with an algorithm selected by ALG.  The only
-     choice is `GMP_RAND_ALG_LC', which is `gmp_randinit_lc_2exp_size'
-     described above.  A third parameter of type `unsigned long' is
+     choice is 'GMP_RAND_ALG_LC', which is 'gmp_randinit_lc_2exp_size'
+     described above.  A third parameter of type 'unsigned long' is
      required, this is the SIZE for that function.
-     `GMP_RAND_ALG_DEFAULT' or 0 are the same as `GMP_RAND_ALG_LC'.
+     'GMP_RAND_ALG_DEFAULT' or 0 are the same as 'GMP_RAND_ALG_LC'.
 
-     `gmp_randinit' sets bits in the global variable `gmp_errno' to
-     indicate an error.  `GMP_ERROR_UNSUPPORTED_ARGUMENT' if ALG is
-     unsupported, or `GMP_ERROR_INVALID_ARGUMENT' if the SIZE parameter
+     'gmp_randinit' sets bits in the global variable 'gmp_errno' to
+     indicate an error.  'GMP_ERROR_UNSUPPORTED_ARGUMENT' if ALG is
+     unsupported, or 'GMP_ERROR_INVALID_ARGUMENT' if the SIZE parameter
      is too big.  It may be noted this error reporting is not thread
-     safe (a good reason to use `gmp_randinit_lc_2exp_size' instead).
+     safe (a good reason to use 'gmp_randinit_lc_2exp_size' instead).
 
  -- Function: void gmp_randclear (gmp_randstate_t STATE)
      Free all memory occupied by STATE.
@@ -4592,20 +4567,20 @@ File: gmp.info,  Node: Random State Seeding,  Next: Random State Miscellaneous,
 
      The size of a seed determines how many different sequences of
      random numbers that it's possible to generate.  The "quality" of
-     the seed is the randomness of a given seed compared to the
-     previous seed used, and this affects the randomness of separate
-     number sequences.  The method for choosing a seed is critical if
-     the generated numbers are to be used for important applications,
-     such as generating cryptographic keys.
-
-     Traditionally the system time has been used to seed, but care
-     needs to be taken with this.  If an application seeds often and
-     the resolution of the system clock is low, then the same sequence
-     of numbers might be repeated.  Also, the system time is quite easy
-     to guess, so if unpredictability is required then it should
-     definitely not be the only source for the seed value.  On some
-     systems there's a special device `/dev/random' which provides
-     random data better suited for use as a seed.
+     the seed is the randomness of a given seed compared to the previous
+     seed used, and this affects the randomness of separate number
+     sequences.  The method for choosing a seed is critical if the
+     generated numbers are to be used for important applications, such
+     as generating cryptographic keys.
+
+     Traditionally the system time has been used to seed, but care needs
+     to be taken with this.  If an application seeds often and the
+     resolution of the system clock is low, then the same sequence of
+     numbers might be repeated.  Also, the system time is quite easy to
+     guess, so if unpredictability is required then it should definitely
+     not be the only source for the seed value.  On some systems there's
+     a special device '/dev/random' which provides random data better
+     suited for use as a seed.
 
 
 File: gmp.info,  Node: Random State Miscellaneous,  Prev: Random State Seeding,  Up: Random Number Functions
@@ -4617,12 +4592,12 @@ File: gmp.info,  Node: Random State Miscellaneous,  Prev: Random State Seeding,
           unsigned long N)
      Return a uniformly distributed random number of N bits, ie. in the
      range 0 to 2^N-1 inclusive.  N must be less than or equal to the
-     number of bits in an `unsigned long'.
+     number of bits in an 'unsigned long'.
 
  -- Function: unsigned long gmp_urandomm_ui (gmp_randstate_t STATE,
           unsigned long N)
-     Return a uniformly distributed random number in the range 0 to
-     N-1, inclusive.
+     Return a uniformly distributed random number in the range 0 to N-1,
+     inclusive.
 
 
 File: gmp.info,  Node: Formatted Output,  Next: Formatted Input,  Prev: Random Number Functions,  Up: Top
@@ -4642,16 +4617,16 @@ File: gmp.info,  Node: Formatted Output Strings,  Next: Formatted Output Functio
 10.1 Format Strings
 ===================
 
-`gmp_printf' and friends accept format strings similar to the standard C
-`printf' (*note Formatted Output: (libc)Formatted Output.).  A format
+'gmp_printf' and friends accept format strings similar to the standard C
+'printf' (*note Formatted Output: (libc)Formatted Output.).  A format
 specification is of the form
 
      % [flags] [width] [.[precision]] [type] conv
 
-   GMP adds types `Z', `Q' and `F' for `mpz_t', `mpq_t' and `mpf_t'
-respectively, `M' for `mp_limb_t', and `N' for an `mp_limb_t' array.
-`Z', `Q', `M' and `N' behave like integers.  `Q' will print a `/' and a
-denominator, if needed.  `F' behaves like a float.  For example,
+   GMP adds types 'Z', 'Q' and 'F' for 'mpz_t', 'mpq_t' and 'mpf_t'
+respectively, 'M' for 'mp_limb_t', and 'N' for an 'mp_limb_t' array.
+'Z', 'Q', 'M' and 'N' behave like integers.  'Q' will print a '/' and a
+denominator, if needed.  'F' behaves like a float.  For example,
 
      mpz_t z;
      gmp_printf ("%s is an mpz %Zd\n", "here", z);
@@ -4670,30 +4645,31 @@ denominator, if needed.  `F' behaves like a float.  For example,
      mp_size_t       size;
      gmp_printf ("limb array %Nx\n", ptr, size);
 
-   For `N' the limbs are expected least significant first, as per the
-`mpn' functions (*note Low-level Functions::).  A negative size can be
+   For 'N' the limbs are expected least significant first, as per the
+'mpn' functions (*note Low-level Functions::).  A negative size can be
 given to print the value as a negative.
 
-   All the standard C `printf' types behave the same as the C library
-`printf', and can be freely intermixed with the GMP extensions.  In the
+   All the standard C 'printf' types behave the same as the C library
+'printf', and can be freely intermixed with the GMP extensions.  In the
 current implementation the standard parts of the format string are
-simply handed to `printf' and only the GMP extensions handled directly.
+simply handed to 'printf' and only the GMP extensions handled directly.
 
    The flags accepted are as follows.  GLIBC style ' is only for the
-standard C types (not the GMP types), and only if the C library
-supports it.
+standard C types (not the GMP types), and only if the C library supports
+it.
 
      0         pad with zeros (rather than spaces)
-     #         show the base with `0x', `0X' or `0'
+     #         show the base with '0x', '0X' or '0'
      +         always show a sign
-     (space)   show a space or a `-' sign
-     '         group digits, GLIBC style (not GMP types)
+     (space)   show a space or a '-' sign
+     '         group digits, GLIBC style (not GMP
+               types)
 
    The optional width and precision can be given as a number within the
-format string, or as a `*' to take an extra parameter of type `int', the
-same as the standard `printf'.
+format string, or as a '*' to take an extra parameter of type 'int', the
+same as the standard 'printf'.
 
-   The standard types accepted are as follows.  `h' and `l' are
+   The standard types accepted are as follows.  'h' and 'l' are
 portable, the rest will depend on the compiler (or include files) for
 the type and the C library for the output.
 
@@ -4715,9 +4691,9 @@ The GMP types are
      N         mp_limb_t array, integer conversions
      Z         mpz_t, integer conversions
 
-   The conversions accepted are as follows.  `a' and `A' are always
-supported for `mpf_t' but depend on the C library for standard C float
-types.  `m' and `p' depend on the C library.
+   The conversions accepted are as follows.  'a' and 'A' are always
+supported for 'mpf_t' but depend on the C library for standard C float
+types.  'm' and 'p' depend on the C library.
 
      a A       hex floats, C99 style
      c         character
@@ -4726,7 +4702,7 @@ types.  `m' and `p' depend on the C library.
      f         fixed point float
      i         same as d
      g G       fixed or scientific float
-     m         `strerror' string, GLIBC style
+     m         'strerror' string, GLIBC style
      n         store characters written so far
      o         octal integer
      p         pointer
@@ -4734,42 +4710,42 @@ types.  `m' and `p' depend on the C library.
      u         unsigned integer
      x X       hex integer
 
-   `o', `x' and `X' are unsigned for the standard C types, but for
-types `Z', `Q' and `N' they are signed.  `u' is not meaningful for `Z',
-`Q' and `N'.
+   'o', 'x' and 'X' are unsigned for the standard C types, but for types
+'Z', 'Q' and 'N' they are signed.  'u' is not meaningful for 'Z', 'Q'
+and 'N'.
 
-   `M' is a proxy for the C library `l' or `L', according to the size
-of `mp_limb_t'.  Unsigned conversions will be usual, but a signed
+   'M' is a proxy for the C library 'l' or 'L', according to the size of
+'mp_limb_t'.  Unsigned conversions will be usual, but a signed
 conversion can be used and will interpret the value as a twos complement
 negative.
 
-   `n' can be used with any type, even the GMP types.
+   'n' can be used with any type, even the GMP types.
 
    Other types or conversions that might be accepted by the C library
-`printf' cannot be used through `gmp_printf', this includes for
-instance extensions registered with GLIBC `register_printf_function'.
-Also currently there's no support for POSIX `$' style numbered arguments
+'printf' cannot be used through 'gmp_printf', this includes for instance
+extensions registered with GLIBC 'register_printf_function'.  Also
+currently there's no support for POSIX '$' style numbered arguments
 (perhaps this will be added in the future).
 
-   The precision field has it's usual meaning for integer `Z' and float
-`F' types, but is currently undefined for `Q' and should not be used
+   The precision field has it's usual meaning for integer 'Z' and float
+'F' types, but is currently undefined for 'Q' and should not be used
 with that.
 
-   `mpf_t' conversions only ever generate as many digits as can be
-accurately represented by the operand, the same as `mpf_get_str' does.
+   'mpf_t' conversions only ever generate as many digits as can be
+accurately represented by the operand, the same as 'mpf_get_str' does.
 Zeros will be used if necessary to pad to the requested precision.  This
-happens even for an `f' conversion of an `mpf_t' which is an integer,
-for instance 2^1024 in an `mpf_t' of 128 bits precision will only
+happens even for an 'f' conversion of an 'mpf_t' which is an integer,
+for instance 2^1024 in an 'mpf_t' of 128 bits precision will only
 produce about 40 digits, then pad with zeros to the decimal point.  An
-empty precision field like `%.Fe' or `%.Ff' can be used to specifically
+empty precision field like '%.Fe' or '%.Ff' can be used to specifically
 request just the significant digits.
 
    The decimal point character (or string) is taken from the current
-locale settings on systems which provide `localeconv' (*note Locales
-and Internationalization: (libc)Locales.).  The C library will normally
-do the same for standard float output.
+locale settings on systems which provide 'localeconv' (*note Locales and
+Internationalization: (libc)Locales.).  The C library will normally do
+the same for standard float output.
 
-   The format string is only interpreted as plain `char's, multibyte
+   The format string is only interpreted as plain 'char's, multibyte
 characters are not recognised.  Perhaps this will change in the future.
 
 
@@ -4779,9 +4755,9 @@ File: gmp.info,  Node: Formatted Output Functions,  Next: C++ Formatted Output,
 ==============
 
 Each of the following functions is similar to the corresponding C
-library function.  The basic `printf' forms take a variable argument
-list.  The `vprintf' forms take an argument pointer, see *note Variadic
-Functions: (libc)Variadic Functions, or `man 3 va_start'.
+library function.  The basic 'printf' forms take a variable argument
+list.  The 'vprintf' forms take an argument pointer, see *note Variadic
+Functions: (libc)Variadic Functions, or 'man 3 va_start'.
 
    It should be emphasised that if a format string is invalid, or the
 arguments don't match what the format specifies, then the behaviour of
@@ -4789,15 +4765,15 @@ any of these functions will be unpredictable.  GCC format string
 checking is not available, since it doesn't recognise the GMP
 extensions.
 
-   The file based functions `gmp_printf' and `gmp_fprintf' will return
--1 to indicate a write error.  Output is not "atomic", so partial
-output may be produced if a write error occurs.  All the functions can
-return -1 if the C library `printf' variant in use returns -1, but this
+   The file based functions 'gmp_printf' and 'gmp_fprintf' will return
+-1 to indicate a write error.  Output is not "atomic", so partial output
+may be produced if a write error occurs.  All the functions can return
+-1 if the C library 'printf' variant in use returns -1, but this
 shouldn't normally occur.
 
  -- Function: int gmp_printf (const char *FMT, ...)
  -- Function: int gmp_vprintf (const char *FMT, va_list AP)
-     Print to the standard output `stdout'.  Return the number of
+     Print to the standard output 'stdout'.  Return the number of
      characters written, or -1 if an error occurred.
 
  -- Function: int gmp_fprintf (FILE *FP, const char *FMT, ...)
@@ -4816,13 +4792,13 @@ shouldn't normally occur.
      These functions are not recommended, since there's no protection
      against exceeding the space available at BUF.
 
- -- Function: int gmp_snprintf (char *BUF, size_t SIZE, const char
-          *FMT, ...)
+ -- Function: int gmp_snprintf (char *BUF, size_t SIZE, const char *FMT,
+          ...)
  -- Function: int gmp_vsnprintf (char *BUF, size_t SIZE, const char
           *FMT, va_list AP)
-     Form a null-terminated string in BUF.  No more than SIZE bytes
-     will be written.  To get the full output, SIZE must be enough for
-     the string and null-terminator.
+     Form a null-terminated string in BUF.  No more than SIZE bytes will
+     be written.  To get the full output, SIZE must be enough for the
+     string and null-terminator.
 
      The return value is the total number of characters which ought to
      have been produced, excluding the terminating null.  If RETVAL >=
@@ -4832,20 +4808,18 @@ shouldn't normally occur.
      No overlap is permitted between the region {BUF,SIZE} and the FMT
      string.
 
-     Notice the return value is in ISO C99 `snprintf' style.  This is
-     so even if the C library `vsnprintf' is the older GLIBC 2.0.x
-     style.
+     Notice the return value is in ISO C99 'snprintf' style.  This is so
+     even if the C library 'vsnprintf' is the older GLIBC 2.0.x style.
 
  -- Function: int gmp_asprintf (char **PP, const char *FMT, ...)
  -- Function: int gmp_vasprintf (char **PP, const char *FMT, va_list AP)
      Form a null-terminated string in a block of memory obtained from
-     the current memory allocation function (*note Custom
-     Allocation::).  The block will be the size of the string and
-     null-terminator.  The address of the block in stored to *PP.  The
-     return value is the number of characters produced, excluding the
-     null-terminator.
+     the current memory allocation function (*note Custom Allocation::).
+     The block will be the size of the string and null-terminator.  The
+     address of the block in stored to *PP.  The return value is the
+     number of characters produced, excluding the null-terminator.
 
-     Unlike the C library `asprintf', `gmp_asprintf' doesn't return -1
+     Unlike the C library 'asprintf', 'gmp_asprintf' doesn't return -1
      if there's no more memory available, it lets the current allocation
      function handle that.
 
@@ -4853,8 +4827,8 @@ shouldn't normally occur.
           *FMT, ...)
  -- Function: int gmp_obstack_vprintf (struct obstack *OB, const char
           *FMT, va_list AP)
-     Append to the current object in OB.  The return value is the
-     number of characters written.  A null-terminator is not written.
+     Append to the current object in OB.  The return value is the number
+     of characters written.  A null-terminator is not written.
 
      FMT cannot be within the current object in OB, since that object
      might move as it grows.
@@ -4869,47 +4843,47 @@ File: gmp.info,  Node: C++ Formatted Output,  Prev: Formatted Output Functions,
 10.3 C++ Formatted Output
 =========================
 
-The following functions are provided in `libgmpxx' (*note Headers and
+The following functions are provided in 'libgmpxx' (*note Headers and
 Libraries::), which is built if C++ support is enabled (*note Build
-Options::).  Prototypes are available from `<gmp.h>'.
+Options::).  Prototypes are available from '<gmp.h>'.
 
  -- Function: ostream& operator<< (ostream& STREAM, mpz_t OP)
-     Print OP to STREAM, using its `ios' formatting settings.
-     `ios::width' is reset to 0 after output, the same as the standard
-     `ostream operator<<' routines do.
+     Print OP to STREAM, using its 'ios' formatting settings.
+     'ios::width' is reset to 0 after output, the same as the standard
+     'ostream operator<<' routines do.
 
      In hex or octal, OP is printed as a signed number, the same as for
-     decimal.  This is unlike the standard `operator<<' routines on
-     `int' etc, which instead give twos complement.
+     decimal.  This is unlike the standard 'operator<<' routines on
+     'int' etc, which instead give twos complement.
 
  -- Function: ostream& operator<< (ostream& STREAM, mpq_t OP)
-     Print OP to STREAM, using its `ios' formatting settings.
-     `ios::width' is reset to 0 after output, the same as the standard
-     `ostream operator<<' routines do.
+     Print OP to STREAM, using its 'ios' formatting settings.
+     'ios::width' is reset to 0 after output, the same as the standard
+     'ostream operator<<' routines do.
 
-     Output will be a fraction like `5/9', or if the denominator is 1
-     then just a plain integer like `123'.
+     Output will be a fraction like '5/9', or if the denominator is 1
+     then just a plain integer like '123'.
 
      In hex or octal, OP is printed as a signed value, the same as for
-     decimal.  If `ios::showbase' is set then a base indicator is shown
+     decimal.  If 'ios::showbase' is set then a base indicator is shown
      on both the numerator and denominator (if the denominator is
      required).
 
  -- Function: ostream& operator<< (ostream& STREAM, mpf_t OP)
-     Print OP to STREAM, using its `ios' formatting settings.
-     `ios::width' is reset to 0 after output, the same as the standard
-     `ostream operator<<' routines do.
+     Print OP to STREAM, using its 'ios' formatting settings.
+     'ios::width' is reset to 0 after output, the same as the standard
+     'ostream operator<<' routines do.
 
-     The decimal point follows the standard library float `operator<<',
-     which on recent systems means the `std::locale' imbued on STREAM.
+     The decimal point follows the standard library float 'operator<<',
+     which on recent systems means the 'std::locale' imbued on STREAM.
 
-     Hex and octal are supported, unlike the standard `operator<<' on
-     `double'.  The mantissa will be in hex or octal, the exponent will
-     be in decimal.  For hex the exponent delimiter is an `@'.  This is
-     as per `mpf_out_str'.
+     Hex and octal are supported, unlike the standard 'operator<<' on
+     'double'.  The mantissa will be in hex or octal, the exponent will
+     be in decimal.  For hex the exponent delimiter is an '@'.  This is
+     as per 'mpf_out_str'.
 
-     `ios::showbase' is supported, and will put a base on the mantissa,
-     for example hex `0x1.8' or `0x0.8', or octal `01.4' or `00.4'.
+     'ios::showbase' is supported, and will put a base on the mantissa,
+     for example hex '0x1.8' or '0x0.8', or octal '01.4' or '00.4'.
      This last form is slightly strange, but at least differentiates
      itself from decimal.
 
@@ -4921,9 +4895,9 @@ way, for example,
      ...
      cout << "iteration " << n << " value " << z << "\n";
 
-   But note that `ostream' output (and `istream' input, *note C++
+   But note that 'ostream' output (and 'istream' input, *note C++
 Formatted Input::) is the only overloading available for the GMP types
-and that for instance using `+' with an `mpz_t' will have unpredictable
+and that for instance using '+' with an 'mpz_t' will have unpredictable
 results.  For classes with overloading, see *note C++ Class Interface::.
 
 
@@ -4944,17 +4918,17 @@ File: gmp.info,  Node: Formatted Input Strings,  Next: Formatted Input Functions
 11.1 Formatted Input Strings
 ============================
 
-`gmp_scanf' and friends accept format strings similar to the standard C
-`scanf' (*note Formatted Input: (libc)Formatted Input.).  A format
+'gmp_scanf' and friends accept format strings similar to the standard C
+'scanf' (*note Formatted Input: (libc)Formatted Input.).  A format
 specification is of the form
 
      % [flags] [width] [type] conv
 
-   GMP adds types `Z', `Q' and `F' for `mpz_t', `mpq_t' and `mpf_t'
-respectively.  `Z' and `Q' behave like integers.  `Q' will read a `/'
-and a denominator, if present.  `F' behaves like a float.
+   GMP adds types 'Z', 'Q' and 'F' for 'mpz_t', 'mpq_t' and 'mpf_t'
+respectively.  'Z' and 'Q' behave like integers.  'Q' will read a '/'
+and a denominator, if present.  'F' behaves like a float.
 
-   GMP variables don't require an `&' when passed to `gmp_scanf', since
+   GMP variables don't require an '&' when passed to 'gmp_scanf', since
 they're already "call-by-reference".  For example,
 
      /* to read say "a(5) = 1234" */
@@ -4970,20 +4944,20 @@ they're already "call-by-reference".  For example,
      char  buf[32];
      gmp_scanf ("%31s (%Ff,%Ff)", buf, x, y);
 
-   All the standard C `scanf' types behave the same as in the C library
-`scanf', and can be freely intermixed with the GMP extensions.  In the
+   All the standard C 'scanf' types behave the same as in the C library
+'scanf', and can be freely intermixed with the GMP extensions.  In the
 current implementation the standard parts of the format string are
-simply handed to `scanf' and only the GMP extensions handled directly.
+simply handed to 'scanf' and only the GMP extensions handled directly.
 
-   The flags accepted are as follows.  `a' and `'' will depend on
-support from the C library, and `'' cannot be used with GMP types.
+   The flags accepted are as follows.  'a' and ''' will depend on
+support from the C library, and ''' cannot be used with GMP types.
 
      *         read but don't store
      a         allocate a buffer (string conversions)
      '         grouped digits, GLIBC style (not GMP
                types)
 
-   The standard types accepted are as follows.  `h' and `l' are
+   The standard types accepted are as follows.  'h' and 'l' are
 portable, the rest will depend on the compiler (or include files) for
 the type and the C library for the input.
 
@@ -5003,12 +4977,13 @@ The GMP types are
      Q         mpq_t, integer conversions
      Z         mpz_t, integer conversions
 
-   The conversions accepted are as follows.  `p' and `[' will depend on
+   The conversions accepted are as follows.  'p' and '[' will depend on
 support from the C library, the rest are standard.
 
      c         character or characters
      d         decimal integer
-     e E f g G float
+     e E f g   float
+     G
      i         integer with base indicator
      n         characters read so far
      o         octal integer
@@ -5018,50 +4993,49 @@ support from the C library, the rest are standard.
      x X       hex integer
      [         string of characters in a set
 
-   `e', `E', `f', `g' and `G' are identical, they all read either fixed
-point or scientific format, and either upper or lower case `e' for the
+   'e', 'E', 'f', 'g' and 'G' are identical, they all read either fixed
+point or scientific format, and either upper or lower case 'e' for the
 exponent in scientific format.
 
-   C99 style hex float format (`printf %a', *note Formatted Output
-Strings::) is always accepted for `mpf_t', but for the standard float
+   C99 style hex float format ('printf %a', *note Formatted Output
+Strings::) is always accepted for 'mpf_t', but for the standard float
 types it will depend on the C library.
 
-   `x' and `X' are identical, both accept both upper and lower case
+   'x' and 'X' are identical, both accept both upper and lower case
 hexadecimal.
 
-   `o', `u', `x' and `X' all read positive or negative values.  For the
-standard C types these are described as "unsigned" conversions, but
-that merely affects certain overflow handling, negatives are still
-allowed (per `strtoul', *note Parsing of Integers: (libc)Parsing of
-Integers.).  For GMP types there are no overflows, so `d' and `u' are
-identical.
+   'o', 'u', 'x' and 'X' all read positive or negative values.  For the
+standard C types these are described as "unsigned" conversions, but that
+merely affects certain overflow handling, negatives are still allowed
+(per 'strtoul', *note Parsing of Integers: (libc)Parsing of Integers.).
+For GMP types there are no overflows, so 'd' and 'u' are identical.
 
-   `Q' type reads the numerator and (optional) denominator as given.
-If the value might not be in canonical form then `mpq_canonicalize'
-must be called before using it in any calculations (*note Rational
-Number Functions::).
+   'Q' type reads the numerator and (optional) denominator as given.  If
+the value might not be in canonical form then 'mpq_canonicalize' must be
+called before using it in any calculations (*note Rational Number
+Functions::).
 
-   `Qi' will read a base specification separately for the numerator and
-denominator.  For example `0x10/11' would be 16/11, whereas `0x10/0x11'
+   'Qi' will read a base specification separately for the numerator and
+denominator.  For example '0x10/11' would be 16/11, whereas '0x10/0x11'
 would be 16/17.
 
-   `n' can be used with any of the types above, even the GMP types.
-`*' to suppress assignment is allowed, though in that case it would do
+   'n' can be used with any of the types above, even the GMP types.  '*'
+to suppress assignment is allowed, though in that case it would do
 nothing at all.
 
    Other conversions or types that might be accepted by the C library
-`scanf' cannot be used through `gmp_scanf'.
+'scanf' cannot be used through 'gmp_scanf'.
 
-   Whitespace is read and discarded before a field, except for `c' and
-`[' conversions.
+   Whitespace is read and discarded before a field, except for 'c' and
+'[' conversions.
 
    For float conversions, the decimal point character (or string)
 expected is taken from the current locale settings on systems which
-provide `localeconv' (*note Locales and Internationalization:
+provide 'localeconv' (*note Locales and Internationalization:
 (libc)Locales.).  The C library will normally do the same for standard
 float input.
 
-   The format string is only interpreted as plain `char's, multibyte
+   The format string is only interpreted as plain 'char's, multibyte
 characters are not recognised.  Perhaps this will change in the future.
 
 
@@ -5071,9 +5045,9 @@ File: gmp.info,  Node: Formatted Input Functions,  Next: C++ Formatted Input,  P
 ==============================
 
 Each of the following functions is similar to the corresponding C
-library function.  The plain `scanf' forms take a variable argument
-list.  The `vscanf' forms take an argument pointer, see *note Variadic
-Functions: (libc)Variadic Functions, or `man 3 va_start'.
+library function.  The plain 'scanf' forms take a variable argument
+list.  The 'vscanf' forms take an argument pointer, see *note Variadic
+Functions: (libc)Variadic Functions, or 'man 3 va_start'.
 
    It should be emphasised that if a format string is invalid, or the
 arguments don't match what the format specifies, then the behaviour of
@@ -5086,7 +5060,7 @@ produced.
 
  -- Function: int gmp_scanf (const char *FMT, ...)
  -- Function: int gmp_vscanf (const char *FMT, va_list AP)
-     Read from the standard input `stdin'.
+     Read from the standard input 'stdin'.
 
  -- Function: int gmp_fscanf (FILE *FP, const char *FMT, ...)
  -- Function: int gmp_vfscanf (FILE *FP, const char *FMT, va_list AP)
@@ -5098,34 +5072,34 @@ produced.
      Read from a null-terminated string S.
 
    The return value from each of these functions is the same as the
-standard C99 `scanf', namely the number of fields successfully parsed
-and stored.  `%n' fields and fields read but suppressed by `*' don't
+standard C99 'scanf', namely the number of fields successfully parsed
+and stored.  '%n' fields and fields read but suppressed by '*' don't
 count towards the return value.
 
-   If end of input (or a file error) is reached before a character for
-a field or a literal, and if no previous non-suppressed fields have
-matched, then the return value is `EOF' instead of 0.  A whitespace
+   If end of input (or a file error) is reached before a character for a
+field or a literal, and if no previous non-suppressed fields have
+matched, then the return value is 'EOF' instead of 0.  A whitespace
 character in the format string is only an optional match and doesn't
-induce an `EOF' in this fashion.  Leading whitespace read and discarded
+induce an 'EOF' in this fashion.  Leading whitespace read and discarded
 for a field don't count as characters for that field.
 
    For the GMP types, input parsing follows C99 rules, namely one
 character of lookahead is used and characters are read while they
 continue to meet the format requirements.  If this doesn't provide a
-complete number then the function terminates, with that field not
-stored nor counted towards the return value.  For instance with `mpf_t'
-an input `1.23e-XYZ' would be read up to the `X' and that character
-pushed back since it's not a digit.  The string `1.23e-' would then be
-considered invalid since an `e' must be followed by at least one digit.
+complete number then the function terminates, with that field not stored
+nor counted towards the return value.  For instance with 'mpf_t' an
+input '1.23e-XYZ' would be read up to the 'X' and that character pushed
+back since it's not a digit.  The string '1.23e-' would then be
+considered invalid since an 'e' must be followed by at least one digit.
 
-   For the standard C types, in the current implementation GMP calls
-the C library `scanf' functions, which might have looser rules about
-what constitutes a valid input.
+   For the standard C types, in the current implementation GMP calls the
+C library 'scanf' functions, which might have looser rules about what
+constitutes a valid input.
 
-   Note that `gmp_sscanf' is the same as `gmp_fscanf' and only does one
+   Note that 'gmp_sscanf' is the same as 'gmp_fscanf' and only does one
 character of lookahead when parsing.  Although clearly it could look at
-its entire input, it is deliberately made identical to `gmp_fscanf',
-the same way C99 `sscanf' is the same as `fscanf'.
+its entire input, it is deliberately made identical to 'gmp_fscanf', the
+same way C99 'sscanf' is the same as 'fscanf'.
 
 
 File: gmp.info,  Node: C++ Formatted Input,  Prev: Formatted Input Functions,  Up: Formatted Input
@@ -5133,45 +5107,45 @@ File: gmp.info,  Node: C++ Formatted Input,  Prev: Formatted Input Functions,  U
 11.3 C++ Formatted Input
 ========================
 
-The following functions are provided in `libgmpxx' (*note Headers and
-Libraries::), which is built only if C++ support is enabled (*note
-Build Options::).  Prototypes are available from `<gmp.h>'.
+The following functions are provided in 'libgmpxx' (*note Headers and
+Libraries::), which is built only if C++ support is enabled (*note Build
+Options::).  Prototypes are available from '<gmp.h>'.
 
  -- Function: istream& operator>> (istream& STREAM, mpz_t ROP)
-     Read ROP from STREAM, using its `ios' formatting settings.
+     Read ROP from STREAM, using its 'ios' formatting settings.
 
  -- Function: istream& operator>> (istream& STREAM, mpq_t ROP)
-     An integer like `123' will be read, or a fraction like `5/9'.  No
-     whitespace is allowed around the `/'.  If the fraction is not in
-     canonical form then `mpq_canonicalize' must be called (*note
+     An integer like '123' will be read, or a fraction like '5/9'.  No
+     whitespace is allowed around the '/'.  If the fraction is not in
+     canonical form then 'mpq_canonicalize' must be called (*note
      Rational Number Functions::) before operating on it.
 
-     As per integer input, an `0' or `0x' base indicator is read when
-     none of `ios::dec', `ios::oct' or `ios::hex' are set.  This is
-     done separately for numerator and denominator, so that for instance
-     `0x10/11' is 16/11 and `0x10/0x11' is 16/17.
+     As per integer input, an '0' or '0x' base indicator is read when
+     none of 'ios::dec', 'ios::oct' or 'ios::hex' are set.  This is done
+     separately for numerator and denominator, so that for instance
+     '0x10/11' is 16/11 and '0x10/0x11' is 16/17.
 
  -- Function: istream& operator>> (istream& STREAM, mpf_t ROP)
-     Read ROP from STREAM, using its `ios' formatting settings.
+     Read ROP from STREAM, using its 'ios' formatting settings.
 
      Hex or octal floats are not supported, but might be in the future,
      or perhaps it's best to accept only what the standard float
-     `operator>>' does.
+     'operator>>' does.
 
-   Note that digit grouping specified by the `istream' locale is
+   Note that digit grouping specified by the 'istream' locale is
 currently not accepted.  Perhaps this will change in the future.
 
 
-   These operators mean that GMP types can be read in the usual C++
-way, for example,
+   These operators mean that GMP types can be read in the usual C++ way,
+for example,
 
      mpz_t  z;
      ...
      cin >> z;
 
-   But note that `istream' input (and `ostream' output, *note C++
+   But note that 'istream' input (and 'ostream' output, *note C++
 Formatted Output::) is the only overloading available for the GMP types
-and that for instance using `+' with an `mpz_t' will have unpredictable
+and that for instance using '+' with an 'mpz_t' will have unpredictable
 results.  For classes with overloading, see *note C++ Class Interface::.
 
 
@@ -5183,7 +5157,7 @@ File: gmp.info,  Node: C++ Class Interface,  Next: BSD Compatible Functions,  Pr
 This chapter describes the C++ class based interface to GMP.
 
    All GMP C language types and functions can be used in C++ programs,
-since `gmp.h' has `extern "C"' qualifiers, but the class interface
+since 'gmp.h' has 'extern "C"' qualifiers, but the class interface
 offers overloaded functions and operators which may be more convenient.
 
    Due to the implementation of this interface, a reasonably recent C++
@@ -5214,8 +5188,8 @@ All the C++ classes and functions are available with
 
      #include <gmpxx.h>
 
-   Programs should be linked with the `libgmpxx' and `libgmp'
-libraries.  For example,
+   Programs should be linked with the 'libgmpxx' and 'libgmp' libraries.
+For example,
 
      g++ mycxxprog.cc -lgmpxx -lgmp
 
@@ -5243,24 +5217,24 @@ to allow arithmetic with these classes.  For example,
      }
 
    An important feature of the implementation is that an expression like
-`a=b+c' results in a single call to the corresponding `mpz_add',
-without using a temporary for the `b+c' part.  Expressions which by
-their nature imply intermediate values, like `a=b*c+d*e', still use
-temporaries though.
+'a=b+c' results in a single call to the corresponding 'mpz_add', without
+using a temporary for the 'b+c' part.  Expressions which by their nature
+imply intermediate values, like 'a=b*c+d*e', still use temporaries
+though.
 
    The classes can be freely intermixed in expressions, as can the
-classes and the standard types `long', `unsigned long' and `double'.
-Smaller types like `int' or `float' can also be intermixed, since C++
+classes and the standard types 'long', 'unsigned long' and 'double'.
+Smaller types like 'int' or 'float' can also be intermixed, since C++
 will promote them.
 
-   Note that `bool' is not accepted directly, but must be explicitly
-cast to an `int' first.  This is because C++ will automatically convert
-any pointer to a `bool', so if GMP accepted `bool' it would make all
+   Note that 'bool' is not accepted directly, but must be explicitly
+cast to an 'int' first.  This is because C++ will automatically convert
+any pointer to a 'bool', so if GMP accepted 'bool' it would make all
 sorts of invalid class and pointer combinations compile but almost
 certainly not do anything sensible.
 
    Conversions back from the classes to standard C++ types aren't done
-automatically, instead member functions like `get_si' are provided (see
+automatically, instead member functions like 'get_si' are provided (see
 the following sections for details).
 
    Also there are no automatic conversions from the classes to the
@@ -5272,7 +5246,7 @@ object can be obtained with the following functions,
  -- Function: mpf_t mpf_class::get_mpf_t ()
 
    These can be used to call a C function which doesn't have a C++ class
-interface.  For example to set `a' to the GCD of `b' and `c',
+interface.  For example to set 'a' to the GCD of 'b' and 'c',
 
      mpz_class a, b, c;
      ...
@@ -5289,11 +5263,11 @@ any sort of association.  For example,
      mpz_class y;
      y = mpz_class (z);
 
-   There are no namespace setups in `gmpxx.h', all types and functions
-are simply put into the global namespace.  This is what `gmp.h' has
-done in the past, and continues to do for compatibility.  The extras
-provided by `gmpxx.h' follow GMP naming conventions and are unlikely to
-clash with anything.
+   There are no namespace setups in 'gmpxx.h', all types and functions
+are simply put into the global namespace.  This is what 'gmp.h' has done
+in the past, and continues to do for compatibility.  The extras provided
+by 'gmpxx.h' follow GMP naming conventions and are unlikely to clash
+with anything.
 
 
 File: gmp.info,  Node: C++ Interface Integers,  Next: C++ Interface Rationals,  Prev: C++ Interface General,  Up: C++ Class Interface
@@ -5301,35 +5275,35 @@ File: gmp.info,  Node: C++ Interface Integers,  Next: C++ Interface Rationals,
 12.2 C++ Interface Integers
 ===========================
 
- -- Function:  mpz_class::mpz_class (type N)
-     Construct an `mpz_class'.  All the standard C++ types may be used,
-     except `long long' and `long double', and all the GMP C++ classes
+ -- Function: mpz_class::mpz_class (type N)
+     Construct an 'mpz_class'.  All the standard C++ types may be used,
+     except 'long long' and 'long double', and all the GMP C++ classes
      can be used.  Any necessary conversion follows the corresponding C
-     function, for example `double' follows `mpz_set_d' (*note
-     Assigning Integers::).
+     function, for example 'double' follows 'mpz_set_d' (*note Assigning
+     Integers::).
 
  -- Function: explicit mpz_class::mpz_class (mpz_t Z)
-     Construct an `mpz_class' from an `mpz_t'.  The value in Z is
-     copied into the new `mpz_class', there won't be any permanent
-     association between it and Z.
+     Construct an 'mpz_class' from an 'mpz_t'.  The value in Z is copied
+     into the new 'mpz_class', there won't be any permanent association
+     between it and Z.
 
  -- Function: explicit mpz_class::mpz_class (const char *S, int BASE =
           0)
- -- Function: explicit mpz_class::mpz_class (const string& S, int BASE
-          = 0)
-     Construct an `mpz_class' converted from a string using
-     `mpz_set_str' (*note Assigning Integers::).
+ -- Function: explicit mpz_class::mpz_class (const string& S, int BASE =
+          0)
+     Construct an 'mpz_class' converted from a string using
+     'mpz_set_str' (*note Assigning Integers::).
 
-     If the string is not a valid integer, an `std::invalid_argument'
-     exception is thrown.  The same applies to `operator='.
+     If the string is not a valid integer, an 'std::invalid_argument'
+     exception is thrown.  The same applies to 'operator='.
 
  -- Function: mpz_class operator/ (mpz_class A, mpz_class D)
  -- Function: mpz_class operator% (mpz_class A, mpz_class D)
-     Divisions involving `mpz_class' round towards zero, as per the
-     `mpz_tdiv_q' and `mpz_tdiv_r' functions (*note Integer Division::).
-     This is the same as the C99 `/' and `%' operators.
+     Divisions involving 'mpz_class' round towards zero, as per the
+     'mpz_tdiv_q' and 'mpz_tdiv_r' functions (*note Integer Division::).
+     This is the same as the C99 '/' and '%' operators.
 
-     The `mpz_fdiv...' or `mpz_cdiv...' functions can always be called
+     The 'mpz_fdiv...' or 'mpz_cdiv...' functions can always be called
      directly if desired.  For example,
 
           mpz_class q, a, d;
@@ -5339,16 +5313,20 @@ File: gmp.info,  Node: C++ Interface Integers,  Next: C++ Interface Rationals,
  -- Function: mpz_class abs (mpz_class OP1)
  -- Function: int cmp (mpz_class OP1, type OP2)
  -- Function: int cmp (type OP1, mpz_class OP2)
+
  -- Function: bool mpz_class::fits_sint_p (void)
  -- Function: bool mpz_class::fits_slong_p (void)
  -- Function: bool mpz_class::fits_sshort_p (void)
+
  -- Function: bool mpz_class::fits_uint_p (void)
  -- Function: bool mpz_class::fits_ulong_p (void)
  -- Function: bool mpz_class::fits_ushort_p (void)
+
  -- Function: double mpz_class::get_d (void)
  -- Function: long mpz_class::get_si (void)
  -- Function: string mpz_class::get_str (int BASE = 10)
  -- Function: unsigned long mpz_class::get_ui (void)
+
  -- Function: int mpz_class::set_str (const char *STR, int BASE)
  -- Function: int mpz_class::set_str (const string& STR, int BASE)
  -- Function: int sgn (mpz_class OP)
@@ -5356,20 +5334,20 @@ File: gmp.info,  Node: C++ Interface Integers,  Next: C++ Interface Rationals,
      These functions provide a C++ class interface to the corresponding
      GMP C routines.
 
-     `cmp' can be used with any of the classes or the standard C++
-     types, except `long long' and `long double'.
+     'cmp' can be used with any of the classes or the standard C++
+     types, except 'long long' and 'long double'.
 
 
-   Overloaded operators for combinations of `mpz_class' and `double'
-are provided for completeness, but it should be noted that if the given
-`double' is not an integer then the way any rounding is done is
+   Overloaded operators for combinations of 'mpz_class' and 'double' are
+provided for completeness, but it should be noted that if the given
+'double' is not an integer then the way any rounding is done is
 currently unspecified.  The rounding might take place at the start, in
 the middle, or at the end of the operation, and it might change in the
 future.
 
-   Conversions between `mpz_class' and `double', however, are defined
-to follow the corresponding C functions `mpz_get_d' and `mpz_set_d'.
-And comparisons are always made exactly, as per `mpz_cmp_d'.
+   Conversions between 'mpz_class' and 'double', however, are defined to
+follow the corresponding C functions 'mpz_get_d' and 'mpz_set_d'.  And
+comparisons are always made exactly, as per 'mpz_cmp_d'.
 
 
 File: gmp.info,  Node: C++ Interface Rationals,  Next: C++ Interface Floats,  Prev: C++ Interface Integers,  Up: C++ Class Interface
@@ -5377,38 +5355,37 @@ File: gmp.info,  Node: C++ Interface Rationals,  Next: C++ Interface Floats,  Pr
 12.3 C++ Interface Rationals
 ============================
 
-In all the following constructors, if a fraction is given then it
-should be in canonical form, or if not then `mpq_class::canonicalize'
-called.
+In all the following constructors, if a fraction is given then it should
+be in canonical form, or if not then 'mpq_class::canonicalize' called.
 
- -- Function:  mpq_class::mpq_class (type OP)
- -- Function:  mpq_class::mpq_class (integer NUM, integer DEN)
-     Construct an `mpq_class'.  The initial value can be a single value
-     of any type, or a pair of integers (`mpz_class' or standard C++
-     integer types) representing a fraction, except that `long long'
-     and `long double' are not supported.  For example,
+ -- Function: mpq_class::mpq_class (type OP)
+ -- Function: mpq_class::mpq_class (integer NUM, integer DEN)
+     Construct an 'mpq_class'.  The initial value can be a single value
+     of any type, or a pair of integers ('mpz_class' or standard C++
+     integer types) representing a fraction, except that 'long long' and
+     'long double' are not supported.  For example,
 
           mpq_class q (99);
           mpq_class q (1.75);
           mpq_class q (1, 3);
 
  -- Function: explicit mpq_class::mpq_class (mpq_t Q)
-     Construct an `mpq_class' from an `mpq_t'.  The value in Q is
-     copied into the new `mpq_class', there won't be any permanent
-     association between it and Q.
+     Construct an 'mpq_class' from an 'mpq_t'.  The value in Q is copied
+     into the new 'mpq_class', there won't be any permanent association
+     between it and Q.
 
  -- Function: explicit mpq_class::mpq_class (const char *S, int BASE =
           0)
- -- Function: explicit mpq_class::mpq_class (const string& S, int BASE
-          = 0)
-     Construct an `mpq_class' converted from a string using
-     `mpq_set_str' (*note Initializing Rationals::).
+ -- Function: explicit mpq_class::mpq_class (const string& S, int BASE =
+          0)
+     Construct an 'mpq_class' converted from a string using
+     'mpq_set_str' (*note Initializing Rationals::).
 
-     If the string is not a valid rational, an `std::invalid_argument'
-     exception is thrown.  The same applies to `operator='.
+     If the string is not a valid rational, an 'std::invalid_argument'
+     exception is thrown.  The same applies to 'operator='.
 
  -- Function: void mpq_class::canonicalize ()
-     Put an `mpq_class' into canonical form, as per *note Rational
+     Put an 'mpq_class' into canonical form, as per *note Rational
      Number Functions::.  All arithmetic operators require their
      operands in canonical form, and will return results in canonical
      form.
@@ -5416,43 +5393,45 @@ called.
  -- Function: mpq_class abs (mpq_class OP)
  -- Function: int cmp (mpq_class OP1, type OP2)
  -- Function: int cmp (type OP1, mpq_class OP2)
+
  -- Function: double mpq_class::get_d (void)
  -- Function: string mpq_class::get_str (int BASE = 10)
+
  -- Function: int mpq_class::set_str (const char *STR, int BASE)
  -- Function: int mpq_class::set_str (const string& STR, int BASE)
  -- Function: int sgn (mpq_class OP)
      These functions provide a C++ class interface to the corresponding
      GMP C routines.
 
-     `cmp' can be used with any of the classes or the standard C++
-     types, except `long long' and `long double'.
+     'cmp' can be used with any of the classes or the standard C++
+     types, except 'long long' and 'long double'.
 
  -- Function: mpz_class& mpq_class::get_num ()
  -- Function: mpz_class& mpq_class::get_den ()
-     Get a reference to an `mpz_class' which is the numerator or
-     denominator of an `mpq_class'.  This can be used both for read and
+     Get a reference to an 'mpz_class' which is the numerator or
+     denominator of an 'mpq_class'.  This can be used both for read and
      write access.  If the object returned is modified, it modifies the
-     original `mpq_class'.
+     original 'mpq_class'.
 
      If direct manipulation might produce a non-canonical value, then
-     `mpq_class::canonicalize' must be called before further operations.
+     'mpq_class::canonicalize' must be called before further operations.
 
  -- Function: mpz_t mpq_class::get_num_mpz_t ()
  -- Function: mpz_t mpq_class::get_den_mpz_t ()
-     Get a reference to the underlying `mpz_t' numerator or denominator
-     of an `mpq_class'.  This can be passed to C functions expecting an
-     `mpz_t'.  Any modifications made to the `mpz_t' will modify the
-     original `mpq_class'.
+     Get a reference to the underlying 'mpz_t' numerator or denominator
+     of an 'mpq_class'.  This can be passed to C functions expecting an
+     'mpz_t'.  Any modifications made to the 'mpz_t' will modify the
+     original 'mpq_class'.
 
      If direct manipulation might produce a non-canonical value, then
-     `mpq_class::canonicalize' must be called before further operations.
+     'mpq_class::canonicalize' must be called before further operations.
 
  -- Function: istream& operator>> (istream& STREAM, mpq_class& ROP);
-     Read ROP from STREAM, using its `ios' formatting settings, the
-     same as `mpq_t operator>>' (*note C++ Formatted Input::).
+     Read ROP from STREAM, using its 'ios' formatting settings, the same
+     as 'mpq_t operator>>' (*note C++ Formatted Input::).
 
      If the ROP read might not be in canonical form then
-     `mpq_class::canonicalize' must be called.
+     'mpq_class::canonicalize' must be called.
 
 
 File: gmp.info,  Node: C++ Interface Floats,  Next: C++ Interface Random Numbers,  Prev: C++ Interface Rationals,  Up: C++ Class Interface
@@ -5461,23 +5440,23 @@ File: gmp.info,  Node: C++ Interface Floats,  Next: C++ Interface Random Numbers
 =========================
 
 When an expression requires the use of temporary intermediate
-`mpf_class' values, like `f=g*h+x*y', those temporaries will have the
-same precision as the destination `f'.  Explicit constructors can be
+'mpf_class' values, like 'f=g*h+x*y', those temporaries will have the
+same precision as the destination 'f'.  Explicit constructors can be
 used if this doesn't suit.
 
- -- Function:  mpf_class::mpf_class (type OP)
- -- Function:  mpf_class::mpf_class (type OP, unsigned long PREC)
-     Construct an `mpf_class'.  Any standard C++ type can be used,
-     except `long long' and `long double', and any of the GMP C++
+ -- Function: mpf_class::mpf_class (type OP)
+ -- Function: mpf_class::mpf_class (type OP, unsigned long PREC)
+     Construct an 'mpf_class'.  Any standard C++ type can be used,
+     except 'long long' and 'long double', and any of the GMP C++
      classes can be used.
 
      If PREC is given, the initial precision is that value, in bits.  If
      PREC is not given, then the initial precision is determined by the
-     type of OP given.  An `mpz_class', `mpq_class', or C++ builtin
-     type will give the default `mpf' precision (*note Initializing
-     Floats::).  An `mpf_class' or expression will give the precision
-     of that value.  The precision of a binary expression is the higher
-     of the two operands.
+     type of OP given.  An 'mpz_class', 'mpq_class', or C++ builtin type
+     will give the default 'mpf' precision (*note Initializing
+     Floats::).  An 'mpf_class' or expression will give the precision of
+     that value.  The precision of a binary expression is the higher of
+     the two operands.
 
           mpf_class f(1.5);        // default precision
           mpf_class f(1.5, 500);   // 500 bits (at least)
@@ -5487,36 +5466,36 @@ used if this doesn't suit.
           mpf_class f(x+y);        // greater of precisions of x and y
 
  -- Function: explicit mpf_class::mpf_class (mpf_t F)
- -- Function:  mpf_class::mpf_class (mpf_t F, unsigned long PREC)
-     Construct an `mpf_class' from an `mpf_t'.  The value in F is
-     copied into the new `mpf_class', there won't be any permanent
-     association between it and F.
+ -- Function: mpf_class::mpf_class (mpf_t F, unsigned long PREC)
+     Construct an 'mpf_class' from an 'mpf_t'.  The value in F is copied
+     into the new 'mpf_class', there won't be any permanent association
+     between it and F.
 
      If PREC is given, the initial precision is that value, in bits.  If
      PREC is not given, then the initial precision is that of F.
 
  -- Function: explicit mpf_class::mpf_class (const char *S)
- -- Function:  mpf_class::mpf_class (const char *S, unsigned long PREC,
+ -- Function: mpf_class::mpf_class (const char *S, unsigned long PREC,
           int BASE = 0)
  -- Function: explicit mpf_class::mpf_class (const string& S)
- -- Function:  mpf_class::mpf_class (const string& S, unsigned long
-          PREC, int BASE = 0)
-     Construct an `mpf_class' converted from a string using
-     `mpf_set_str' (*note Assigning Floats::).  If PREC is given, the
+ -- Function: mpf_class::mpf_class (const string& S, unsigned long PREC,
+          int BASE = 0)
+     Construct an 'mpf_class' converted from a string using
+     'mpf_set_str' (*note Assigning Floats::).  If PREC is given, the
      initial precision is that value, in bits.  If not, the default
-     `mpf' precision (*note Initializing Floats::) is used.
+     'mpf' precision (*note Initializing Floats::) is used.
 
-     If the string is not a valid float, an `std::invalid_argument'
-     exception is thrown.  The same applies to `operator='.
+     If the string is not a valid float, an 'std::invalid_argument'
+     exception is thrown.  The same applies to 'operator='.
 
  -- Function: mpf_class& mpf_class::operator= (type OP)
-     Convert and store the given OP value to an `mpf_class' object.  The
+     Convert and store the given OP value to an 'mpf_class' object.  The
      same types are accepted as for the constructors above.
 
-     Note that `operator=' only stores a new value, it doesn't copy or
+     Note that 'operator=' only stores a new value, it doesn't copy or
      change the precision of the destination, instead the value is
-     truncated if necessary.  This is the same as `mpf_set' etc.  Note
-     in particular this means for `mpf_class' a copy constructor is not
+     truncated if necessary.  This is the same as 'mpf_set' etc.  Note
+     in particular this means for 'mpf_class' a copy constructor is not
      the same as a default constructor plus assignment.
 
           mpf_class x (y);   // x created with precision of y
@@ -5526,9 +5505,9 @@ used if this doesn't suit.
 
      Applications using templated code may need to be careful about the
      assumptions the code makes in this area, when working with
-     `mpf_class' values of various different or non-default precisions.
-     For instance implementations of the standard `complex' template
-     have been seen in both styles above, though of course `complex' is
+     'mpf_class' values of various different or non-default precisions.
+     For instance implementations of the standard 'complex' template
+     have been seen in both styles above, though of course 'complex' is
      normally only actually specified for use with the builtin float
      types.
 
@@ -5536,19 +5515,24 @@ used if this doesn't suit.
  -- Function: mpf_class ceil (mpf_class OP)
  -- Function: int cmp (mpf_class OP1, type OP2)
  -- Function: int cmp (type OP1, mpf_class OP2)
+
  -- Function: bool mpf_class::fits_sint_p (void)
  -- Function: bool mpf_class::fits_slong_p (void)
  -- Function: bool mpf_class::fits_sshort_p (void)
+
  -- Function: bool mpf_class::fits_uint_p (void)
  -- Function: bool mpf_class::fits_ulong_p (void)
  -- Function: bool mpf_class::fits_ushort_p (void)
+
  -- Function: mpf_class floor (mpf_class OP)
  -- Function: mpf_class hypot (mpf_class OP1, mpf_class OP2)
+
  -- Function: double mpf_class::get_d (void)
  -- Function: long mpf_class::get_si (void)
  -- Function: string mpf_class::get_str (mp_exp_t& EXP, int BASE = 10,
           size_t DIGITS = 0)
  -- Function: unsigned long mpf_class::get_ui (void)
+
  -- Function: int mpf_class::set_str (const char *STR, int BASE)
  -- Function: int mpf_class::set_str (const string& STR, int BASE)
  -- Function: int sgn (mpf_class OP)
@@ -5557,21 +5541,21 @@ used if this doesn't suit.
      These functions provide a C++ class interface to the corresponding
      GMP C routines.
 
-     `cmp' can be used with any of the classes or the standard C++
-     types, except `long long' and `long double'.
+     'cmp' can be used with any of the classes or the standard C++
+     types, except 'long long' and 'long double'.
 
-     The accuracy provided by `hypot' is not currently guaranteed.
+     The accuracy provided by 'hypot' is not currently guaranteed.
 
  -- Function: mp_bitcnt_t mpf_class::get_prec ()
  -- Function: void mpf_class::set_prec (mp_bitcnt_t PREC)
  -- Function: void mpf_class::set_prec_raw (mp_bitcnt_t PREC)
-     Get or set the current precision of an `mpf_class'.
+     Get or set the current precision of an 'mpf_class'.
 
-     The restrictions described for `mpf_set_prec_raw' (*note
-     Initializing Floats::) apply to `mpf_class::set_prec_raw'.  Note
-     in particular that the `mpf_class' must be restored to it's
-     allocated precision before being destroyed.  This must be done by
-     application code, there's no automatic mechanism for it.
+     The restrictions described for 'mpf_set_prec_raw' (*note
+     Initializing Floats::) apply to 'mpf_class::set_prec_raw'.  Note in
+     particular that the 'mpf_class' must be restored to it's allocated
+     precision before being destroyed.  This must be done by application
+     code, there's no automatic mechanism for it.
 
 
 File: gmp.info,  Node: C++ Interface Random Numbers,  Next: C++ Interface Limitations,  Prev: C++ Interface Floats,  Up: C++ Class Interface
@@ -5581,27 +5565,27 @@ File: gmp.info,  Node: C++ Interface Random Numbers,  Next: C++ Interface Limita
 
  -- Class: gmp_randclass
      The C++ class interface to the GMP random number functions uses
-     `gmp_randclass' to hold an algorithm selection and current state,
-     as per `gmp_randstate_t'.
+     'gmp_randclass' to hold an algorithm selection and current state,
+     as per 'gmp_randstate_t'.
 
- -- Function:  gmp_randclass::gmp_randclass (void (*RANDINIT)
+ -- Function: gmp_randclass::gmp_randclass (void (*RANDINIT)
           (gmp_randstate_t, ...), ...)
-     Construct a `gmp_randclass', using a call to the given RANDINIT
+     Construct a 'gmp_randclass', using a call to the given RANDINIT
      function (*note Random State Initialization::).  The arguments
-     expected are the same as RANDINIT, but with `mpz_class' instead of
-     `mpz_t'.  For example,
+     expected are the same as RANDINIT, but with 'mpz_class' instead of
+     'mpz_t'.  For example,
 
           gmp_randclass r1 (gmp_randinit_default);
           gmp_randclass r2 (gmp_randinit_lc_2exp_size, 32);
           gmp_randclass r3 (gmp_randinit_lc_2exp, a, c, m2exp);
           gmp_randclass r4 (gmp_randinit_mt);
 
-     `gmp_randinit_lc_2exp_size' will fail if the size requested is too
-     big, an `std::length_error' exception is thrown in that case.
+     'gmp_randinit_lc_2exp_size' will fail if the size requested is too
+     big, an 'std::length_error' exception is thrown in that case.
 
- -- Function:  gmp_randclass::gmp_randclass (gmp_randalg_t ALG, ...)
-     Construct a `gmp_randclass' using the same parameters as
-     `gmp_randinit' (*note Random State Initialization::).  This
+ -- Function: gmp_randclass::gmp_randclass (gmp_randalg_t ALG, ...)
+     Construct a 'gmp_randclass' using the same parameters as
+     'gmp_randinit' (*note Random State Initialization::).  This
      function is obsolete and the above RANDINIT style should be
      preferred.
 
@@ -5634,22 +5618,22 @@ File: gmp.info,  Node: C++ Interface Limitations,  Prev: C++ Interface Random Nu
 12.6 C++ Interface Limitations
 ==============================
 
-`mpq_class' and Templated Reading
+'mpq_class' and Templated Reading
      A generic piece of template code probably won't know that
-     `mpq_class' requires a `canonicalize' call if inputs read with
-     `operator>>' might be non-canonical.  This can lead to incorrect
+     'mpq_class' requires a 'canonicalize' call if inputs read with
+     'operator>>' might be non-canonical.  This can lead to incorrect
      results.
 
-     `operator>>' behaves as it does for reasons of efficiency.  A
+     'operator>>' behaves as it does for reasons of efficiency.  A
      canonicalize can be quite time consuming on large operands, and is
      best avoided if it's not necessary.
 
      But this potential difficulty reduces the usefulness of
-     `mpq_class'.  Perhaps a mechanism to tell `operator>>' what to do
+     'mpq_class'.  Perhaps a mechanism to tell 'operator>>' what to do
      will be adopted in the future, maybe a preprocessor define, a
-     global flag, or an `ios' flag pressed into service.  Or maybe, at
-     the risk of inconsistency, the `mpq_class' `operator>>' could
-     canonicalize and leave `mpq_t' `operator>>' not doing so, for use
+     global flag, or an 'ios' flag pressed into service.  Or maybe, at
+     the risk of inconsistency, the 'mpq_class' 'operator>>' could
+     canonicalize and leave 'mpq_t' 'operator>>' not doing so, for use
      on those occasions when that's acceptable.  Send feedback or
      alternate ideas to <gmp-bugs@gmplib.org>.
 
@@ -5658,21 +5642,20 @@ Subclassing
      recommended.
 
      Expressions involving subclasses resolve correctly (or seem to),
-     but in normal C++ fashion the subclass doesn't inherit
-     constructors and assignments.  There's many of those in the GMP
-     classes, and a good way to reestablish them in a subclass is not
-     yet provided.
+     but in normal C++ fashion the subclass doesn't inherit constructors
+     and assignments.  There's many of those in the GMP classes, and a
+     good way to reestablish them in a subclass is not yet provided.
 
 Templated Expressions
      A subtle difficulty exists when using expressions together with
      application-defined template functions.  Consider the following,
-     with `T' intended to be some numeric type,
+     with 'T' intended to be some numeric type,
 
           template <class T>
           T fun (const T &, const T &);
 
-     When used with, say, plain `mpz_class' variables, it works fine:
-     `T' is resolved as `mpz_class'.
+     When used with, say, plain 'mpz_class' variables, it works fine:
+     'T' is resolved as 'mpz_class'.
 
           mpz_class f(1), g(2);
           fun (f, g);    // Good
@@ -5682,16 +5665,16 @@ Templated Expressions
           mpz_class f(1), g(2), h(3);
           fun (f, g+h);  // Bad
 
-     This is because `g+h' ends up being a certain expression template
-     type internal to `gmpxx.h', which the C++ template resolution
-     rules are unable to automatically convert to `mpz_class'.  The
-     workaround is simply to add an explicit cast.
+     This is because 'g+h' ends up being a certain expression template
+     type internal to 'gmpxx.h', which the C++ template resolution rules
+     are unable to automatically convert to 'mpz_class'.  The workaround
+     is simply to add an explicit cast.
 
           mpz_class f(1), g(2), h(3);
           fun (f, mpz_class(g+h));  // Good
 
-     Similarly, within `fun' it may be necessary to cast an expression
-     to type `T' when calling a templated `fun2'.
+     Similarly, within 'fun' it may be necessary to cast an expression
+     to type 'T' when calling a templated 'fun2'.
 
           template <class T>
           void fun (T f, T g)
@@ -5713,7 +5696,7 @@ File: gmp.info,  Node: BSD Compatible Functions,  Next: Custom Allocation,  Prev
 
 These functions are intended to be fully compatible with the Berkeley MP
 library which is available on many BSD derived U*ix systems.  The
-`--enable-mpbsd' option must be used when building GNU MP to make these
+'--enable-mpbsd' option must be used when building GNU MP to make these
 available (*note Installing GMP::).
 
    The original Berkeley MP library has a usage restriction: you cannot
@@ -5723,25 +5706,25 @@ restriction--inputs and outputs may overlap.
 
    It is not recommended that new programs are written using these
 functions.  Apart from the incomplete set of functions, the interface
-for initializing `MINT' objects is more error prone, and the `pow'
-function collides with `pow' in `libm.a'.
+for initializing 'MINT' objects is more error prone, and the 'pow'
+function collides with 'pow' in 'libm.a'.
 
-   Include the header `mp.h' to get the definition of the necessary
+   Include the header 'mp.h' to get the definition of the necessary
 types and functions.  If you are on a BSD derived system, make sure to
-include GNU `mp.h' if you are going to link the GNU `libmp.a' to your
-program.  This means that you probably need to give the `-I<dir>'
-option to the compiler, where `<dir>' is the directory where you have
-GNU `mp.h'.
+include GNU 'mp.h' if you are going to link the GNU 'libmp.a' to your
+program.  This means that you probably need to give the '-I<dir>' option
+to the compiler, where '<dir>' is the directory where you have GNU
+'mp.h'.
 
  -- Function: MINT * itom (signed short int INITIAL_VALUE)
-     Allocate an integer consisting of a `MINT' object and dynamic limb
+     Allocate an integer consisting of a 'MINT' object and dynamic limb
      space.  Initialize the integer to INITIAL_VALUE.  Return a pointer
-     to the `MINT' object.
+     to the 'MINT' object.
 
  -- Function: MINT * xtom (char *INITIAL_VALUE)
-     Allocate an integer consisting of a `MINT' object and dynamic limb
+     Allocate an integer consisting of a 'MINT' object and dynamic limb
      space.  Initialize the integer from INITIAL_VALUE, a hexadecimal,
-     null-terminated C string.  Return a pointer to the `MINT' object.
+     null-terminated C string.  Return a pointer to the 'MINT' object.
 
  -- Function: void move (MINT *SRC, MINT *DEST)
      Set DEST to SRC by copying.  Both variables must be previously
@@ -5764,12 +5747,12 @@ GNU `mp.h'.
      DIVISOR.  The quotient is rounded towards zero; the remainder has
      the same sign as the dividend unless it is zero.
 
-     Some implementations of these functions work differently--or not
-     at all--for negative arguments.
+     Some implementations of these functions work differently--or not at
+     all--for negative arguments.
 
  -- Function: void msqrt (MINT *OP, MINT *ROOT, MINT *REMAINDER)
      Set ROOT to the truncated integer part of the square root of OP,
-     like `mpz_sqrt'.  Set REMAINDER to OP-ROOT*ROOT, i.e.  zero if OP
+     like 'mpz_sqrt'.  Set REMAINDER to OP-ROOT*ROOT, i.e.  zero if OP
      is a perfect square.
 
      If ROOT and REMAINDER are the same variable, the results are
@@ -5778,7 +5761,7 @@ GNU `mp.h'.
  -- Function: void pow (MINT *BASE, MINT *EXP, MINT *MOD, MINT *DEST)
      Set DEST to (BASE raised to EXP) modulo MOD.
 
-     Note that the name `pow' clashes with `pow' from the standard C
+     Note that the name 'pow' clashes with 'pow' from the standard C
      math library (*note Exponentiation and Logarithms: (libc)Exponents
      and Logarithms.).  An application will only be able to use one or
      the other.
@@ -5790,28 +5773,28 @@ GNU `mp.h'.
      Set RES to the greatest common divisor of OP1 and OP2.
 
  -- Function: int mcmp (MINT *OP1, MINT *OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, and a negative value if OP1 < OP2.
+     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero if
+     OP1 = OP2, and a negative value if OP1 < OP2.
 
  -- Function: void min (MINT *DEST)
-     Input a decimal string from `stdin', and put the read integer in
+     Input a decimal string from 'stdin', and put the read integer in
      DEST.  SPC and TAB are allowed in the number string, and are
      ignored.
 
  -- Function: void mout (MINT *SRC)
-     Output SRC to `stdout', as a decimal string.  Also output a
+     Output SRC to 'stdout', as a decimal string.  Also output a
      newline.
 
  -- Function: char * mtox (MINT *OP)
      Convert OP to a hexadecimal string, and return a pointer to the
      string.  The returned string is allocated using the default memory
-     allocation function, `malloc' by default.  It will be
-     `strlen(str)+1' bytes, that being exactly enough for the string
-     and null-terminator.
+     allocation function, 'malloc' by default.  It will be
+     'strlen(str)+1' bytes, that being exactly enough for the string and
+     null-terminator.
 
  -- Function: void mfree (MINT *OP)
      De-allocate, the space used by OP.  *This function should only be
-     passed a value returned by `itom' or `xtom'.*
+     passed a value returned by 'itom' or 'xtom'.*
 
 
 File: gmp.info,  Node: Custom Allocation,  Next: Language Bindings,  Prev: BSD Compatible Functions,  Up: Top
@@ -5819,7 +5802,7 @@ File: gmp.info,  Node: Custom Allocation,  Next: Language Bindings,  Prev: BSD C
 14 Custom Allocation
 ********************
 
-By default GMP uses `malloc', `realloc' and `free' for memory
+By default GMP uses 'malloc', 'realloc' and 'free' for memory
 allocation, and if they fail GMP prints a message to the standard error
 output and terminates the program.
 
@@ -5834,14 +5817,14 @@ memory.
           void *(*ALLOC_FUNC_PTR) (size_t),
           void *(*REALLOC_FUNC_PTR) (void *, size_t, size_t),
           void (*FREE_FUNC_PTR) (void *, size_t))
-     Replace the current allocation functions from the arguments.  If
-     an argument is `NULL', the corresponding default function is used.
+     Replace the current allocation functions from the arguments.  If an
+     argument is 'NULL', the corresponding default function is used.
 
-     These functions will be used for all memory allocation done by
-     GMP, apart from temporary space from `alloca' if that function is
+     These functions will be used for all memory allocation done by GMP,
+     apart from temporary space from 'alloca' if that function is
      available and GMP is configured to use it (*note Build Options::).
 
-     *Be sure to call `mp_set_memory_functions' only when there are no
+     *Be sure to call 'mp_set_memory_functions' only when there are no
      active GMP objects allocated using the previous memory functions!
      Usually that means calling it before any other GMP function.*
 
@@ -5856,49 +5839,49 @@ memory.
      Resize a previously allocated block PTR of OLD_SIZE bytes to be
      NEW_SIZE bytes.
 
-     The block may be moved if necessary or if desired, and in that
-     case the smaller of OLD_SIZE and NEW_SIZE bytes must be copied to
-     the new location.  The return value is a pointer to the resized
-     block, that being the new location if moved or just PTR if not.
+     The block may be moved if necessary or if desired, and in that case
+     the smaller of OLD_SIZE and NEW_SIZE bytes must be copied to the
+     new location.  The return value is a pointer to the resized block,
+     that being the new location if moved or just PTR if not.
 
-     PTR is never `NULL', it's always a previously allocated block.
+     PTR is never 'NULL', it's always a previously allocated block.
      NEW_SIZE may be bigger or smaller than OLD_SIZE.
 
  -- Function: void free_function (void *PTR, size_t SIZE)
      De-allocate the space pointed to by PTR.
 
-     PTR is never `NULL', it's always a previously allocated block of
+     PTR is never 'NULL', it's always a previously allocated block of
      SIZE bytes.
 
-   A "byte" here means the unit used by the `sizeof' operator.
+   A "byte" here means the unit used by the 'sizeof' operator.
 
    The OLD_SIZE parameters to REALLOCATE_FUNCTION and FREE_FUNCTION are
-passed for convenience, but of course can be ignored if not needed.
-The default functions using `malloc' and friends for instance don't use
+passed for convenience, but of course can be ignored if not needed.  The
+default functions using 'malloc' and friends for instance don't use
 them.
 
    No error return is allowed from any of these functions, if they
 return then they must have performed the specified operation.  In
 particular note that ALLOCATE_FUNCTION or REALLOCATE_FUNCTION mustn't
-return `NULL'.
+return 'NULL'.
 
    Getting a different fatal error action is a good use for custom
 allocation functions, for example giving a graphical dialog rather than
-the default print to `stderr'.  How much is possible when genuinely out
+the default print to 'stderr'.  How much is possible when genuinely out
 of memory is another question though.
 
    There's currently no defined way for the allocation functions to
-recover from an error such as out of memory, they must terminate
-program execution.  A `longjmp' or throwing a C++ exception will have
-undefined results.  This may change in the future.
+recover from an error such as out of memory, they must terminate program
+execution.  A 'longjmp' or throwing a C++ exception will have undefined
+results.  This may change in the future.
 
    GMP may use allocated blocks to hold pointers to other allocated
 blocks.  This will limit the assumptions a conservative garbage
 collection scheme can make.
 
-   Since the default GMP allocation uses `malloc' and friends, those
+   Since the default GMP allocation uses 'malloc' and friends, those
 functions will be linked in even if the first thing a program does is an
-`mp_set_memory_functions'.  It's necessary to change the GMP sources if
+'mp_set_memory_functions'.  It's necessary to change the GMP sources if
 this is a problem.
 
 
@@ -5907,7 +5890,7 @@ this is a problem.
           void *(**REALLOC_FUNC_PTR) (void *, size_t, size_t),
           void (**FREE_FUNC_PTR) (void *, size_t))
      Get the current allocation functions, storing function pointers to
-     the locations given by the arguments.  If an argument is `NULL',
+     the locations given by the arguments.  If an argument is 'NULL',
      that function pointer is not stored.
 
      For example, to get just the current free function,
@@ -5931,134 +5914,111 @@ C++
         * GMP C++ class interface, *note C++ Class Interface::
           Straightforward interface, expression templates to eliminate
           temporaries.
-
-        * ALP `http://www-sop.inria.fr/saga/logiciels/ALP/'
+        * ALP <http://www-sop.inria.fr/saga/logiciels/ALP/>
           Linear algebra and polynomials using templates.
-
-        * Arithmos `http://www.win.ua.ac.be/~cant/arithmos/'
+        * Arithmos <http://www.win.ua.ac.be/~cant/arithmos/>
           Rationals with infinities and square roots.
-
-        * CLN `http://www.ginac.de/CLN/'
+        * CLN <http://www.ginac.de/CLN/>
           High level classes for arithmetic.
-
-        * LiDIA `http://www.cdc.informatik.tu-darmstadt.de/TI/LiDIA/'
+        * LiDIA <http://www.cdc.informatik.tu-darmstadt.de/TI/LiDIA/>
           A C++ library for computational number theory.
-
-        * Linbox `http://www.linalg.org/'
+        * Linbox <http://www.linalg.org/>
           Sparse vectors and matrices.
-
-        * NTL `http://www.shoup.net/ntl/'
+        * NTL <http://www.shoup.net/ntl/>
           A C++ number theory library.
 
 Eiffel
-        * Eiffelroom `http://www.eiffelroom.org/node/442'
+        * Eiffelroom <http://www.eiffelroom.org/node/442>
 
 Fortran
-        * Omni F77 `http://phase.hpcc.jp/Omni/home.html'
+        * Omni F77 <http://phase.hpcc.jp/Omni/home.html>
           Arbitrary precision floats.
 
 Haskell
-        * Glasgow Haskell Compiler `http://www.haskell.org/ghc/'
+        * Glasgow Haskell Compiler <http://www.haskell.org/ghc/>
 
 Java
-        * Kaffe `http://www.kaffe.org/'
-
-        * Kissme `http://kissme.sourceforge.net/'
+        * Kaffe <http://www.kaffe.org/>
+        * Kissme <http://kissme.sourceforge.net/>
 
 Lisp
-        * GNU Common Lisp `http://www.gnu.org/software/gcl/gcl.html'
-
-        * Librep `http://librep.sourceforge.net/'
-
-        * XEmacs (21.5.18 beta and up) `http://www.xemacs.org'
+        * GNU Common Lisp <http://www.gnu.org/software/gcl/gcl.html>
+        * Librep <http://librep.sourceforge.net/>
+        * XEmacs (21.5.18 beta and up) <http://www.xemacs.org>
           Optional big integers, rationals and floats using GMP.
 
 M4
-        * GNU m4 betas `http://www.seindal.dk/rene/gnu/'
-          Optionally provides an arbitrary precision `mpeval'.
+        * GNU m4 betas <http://www.seindal.dk/rene/gnu/>
+          Optionally provides an arbitrary precision 'mpeval'.
 
 ML
-        * MLton compiler `http://mlton.org/'
+        * MLton compiler <http://mlton.org/>
 
 Objective Caml
-        * MLGMP `http://www.di.ens.fr/~monniaux/programmes.html.en'
-
-        * Numerix `http://pauillac.inria.fr/~quercia/'
+        * MLGMP <http://www.di.ens.fr/~monniaux/programmes.html.en>
+        * Numerix <http://pauillac.inria.fr/~quercia/>
           Optionally using GMP.
 
 Oz
-        * Mozart `http://www.mozart-oz.org/'
+        * Mozart <http://www.mozart-oz.org/>
 
 Pascal
-        * GNU Pascal Compiler `http://www.gnu-pascal.de/'
+        * GNU Pascal Compiler <http://www.gnu-pascal.de/>
           GMP unit.
-
-        * Numerix `http://pauillac.inria.fr/~quercia/'
+        * Numerix <http://pauillac.inria.fr/~quercia/>
           For Free Pascal, optionally using GMP.
 
 Perl
-        * GMP module, see `demos/perl' in the GMP sources (*note
+        * GMP module, see 'demos/perl' in the GMP sources (*note
           Demonstration Programs::).
-
-        * Math::GMP `http://www.cpan.org/'
-          Compatible with Math::BigInt, but not as many functions as
-          the GMP module above.
-
-        * Math::BigInt::GMP `http://www.cpan.org/'
+        * Math::GMP <http://www.cpan.org/>
+          Compatible with Math::BigInt, but not as many functions as the
+          GMP module above.
+        * Math::BigInt::GMP <http://www.cpan.org/>
           Plug Math::GMP into normal Math::BigInt operations.
 
 Pike
         * mpz module in the standard distribution,
-          `http://pike.ida.liu.se/'
+          <http://pike.ida.liu.se/>
 
 Prolog
-        * SWI Prolog `http://www.swi-prolog.org/'
+        * SWI Prolog <http://www.swi-prolog.org/>
           Arbitrary precision floats.
 
 Python
-        * GMPY `http://code.google.com/p/gmpy/'
+        * GMPY <http://code.google.com/p/gmpy/>
 
 Ruby
         * http://rubygems.org/gems/gmp
 
 Scheme
         * GNU Guile (upcoming 1.8)
-          `http://www.gnu.org/software/guile/guile.html'
-
-        * RScheme `http://www.rscheme.org/'
-
-        * STklos `http://www.stklos.org/'
+          <http://www.gnu.org/software/guile/guile.html>
+        * RScheme <http://www.rscheme.org/>
+        * STklos <http://www.stklos.org/>
 
 Smalltalk
         * GNU Smalltalk
-          `http://www.smalltalk.org/versions/GNUSmalltalk.html'
+          <http://www.smalltalk.org/versions/GNUSmalltalk.html>
 
 Other
-        * Axiom `http://savannah.nongnu.org/projects/axiom'
+        * Axiom <http://savannah.nongnu.org/projects/axiom>
           Computer algebra using GCL.
-
-        * DrGenius `http://drgenius.seul.org/'
+        * DrGenius <http://drgenius.seul.org/>
           Geometry system and mathematical programming language.
-
-        * GiNaC `http://www.ginac.de/'
+        * GiNaC <http://www.ginac.de/>
           C++ computer algebra using CLN.
-
-        * GOO `http://www.googoogaga.org/'
+        * GOO <http://www.googoogaga.org/>
           Dynamic object oriented language.
-
-        * Maxima `http://www.ma.utexas.edu/users/wfs/maxima.html'
+        * Maxima <http://www.ma.utexas.edu/users/wfs/maxima.html>
           Macsyma computer algebra using GCL.
-
-        * Q `http://q-lang.sourceforge.net/'
+        * Q <http://q-lang.sourceforge.net/>
           Equational programming system.
-
-        * Regina `http://regina.sourceforge.net/'
+        * Regina <http://regina.sourceforge.net/>
           Topological calculator.
-
-        * Yacas `http://www.xs4all.nl/~apinkus/yacas.html'
+        * Yacas <http://www.xs4all.nl/~apinkus/yacas.html>
           Yet another computer algebra system.
 
-
 
 File: gmp.info,  Node: Algorithms,  Next: Internals,  Prev: Language Bindings,  Up: Top
 
@@ -6095,15 +6055,15 @@ algorithms, as the size N increases.
 
      Algorithm      Threshold
      Basecase       (none)
-     Karatsuba      `MUL_TOOM22_THRESHOLD'
-     Toom-3         `MUL_TOOM33_THRESHOLD'
-     Toom-4         `MUL_TOOM44_THRESHOLD'
-     FFT            `MUL_FFT_THRESHOLD'
+     Karatsuba      'MUL_TOOM22_THRESHOLD'
+     Toom-3         'MUL_TOOM33_THRESHOLD'
+     Toom-4         'MUL_TOOM44_THRESHOLD'
+     FFT            'MUL_FFT_THRESHOLD'
 
-   Similarly for squaring, with the `SQR' thresholds.
+   Similarly for squaring, with the 'SQR' thresholds.
 
    NxM multiplications of operands with different sizes above
-`MUL_TOOM22_THRESHOLD' are currently done by special Toom-inspired
+'MUL_TOOM22_THRESHOLD' are currently done by special Toom-inspired
 algorithms or directly with FFT, depending on operand size (*note
 Unbalanced Multiplication::).
 
@@ -6126,18 +6086,18 @@ File: gmp.info,  Node: Basecase Multiplication,  Next: Karatsuba Multiplication,
 Basecase NxM multiplication is a straightforward rectangular set of
 cross-products, the same as long multiplication done by hand and for
 that reason sometimes known as the schoolbook or grammar school method.
-This is an O(N*M) algorithm.  See Knuth section 4.3.1 algorithm M
-(*note References::), and the `mpn/generic/mul_basecase.c' code.
+This is an O(N*M) algorithm.  See Knuth section 4.3.1 algorithm M (*note
+References::), and the 'mpn/generic/mul_basecase.c' code.
 
-   Assembly implementations of `mpn_mul_basecase' are essentially the
+   Assembly implementations of 'mpn_mul_basecase' are essentially the
 same as the generic C code, but have all the usual assembly tricks and
 obscurities introduced for speed.
 
-   A square can be done in roughly half the time of a multiply, by
-using the fact that the cross products above and below the diagonal are
-the same.  A triangle of products below the diagonal is formed, doubled
+   A square can be done in roughly half the time of a multiply, by using
+the fact that the cross products above and below the diagonal are the
+same.  A triangle of products below the diagonal is formed, doubled
 (left shift by one bit), and then the products on the diagonal added.
-This can be seen in `mpn/generic/sqr_basecase.c'.  Again the assembly
+This can be seen in 'mpn/generic/sqr_basecase.c'.  Again the assembly
 implementations take essentially the same approach.
 
           u0  u1  u2  u3  u4
@@ -6155,11 +6115,11 @@ implementations take essentially the same approach.
 
    In practice squaring isn't a full 2x faster than multiplying, it's
 usually around 1.5x.  Less than 1.5x probably indicates
-`mpn_sqr_basecase' wants improving on that CPU.
+'mpn_sqr_basecase' wants improving on that CPU.
 
-   On some CPUs `mpn_mul_basecase' can be faster than the generic C
-`mpn_sqr_basecase' on some small sizes.  `SQR_BASECASE_THRESHOLD' is
-the size at which to use `mpn_sqr_basecase', this will be zero if that
+   On some CPUs 'mpn_mul_basecase' can be faster than the generic C
+'mpn_sqr_basecase' on some small sizes.  'SQR_BASECASE_THRESHOLD' is the
+size at which to use 'mpn_sqr_basecase', this will be zero if that
 routine should be used always.
 
 
@@ -6169,8 +6129,8 @@ File: gmp.info,  Node: Karatsuba Multiplication,  Next: Toom 3-Way Multiplicatio
 -------------------------------
 
 The Karatsuba multiplication algorithm is described in Knuth section
-4.3.3 part A, and various other textbooks.  A brief description is
-given here.
+4.3.3 part A, and various other textbooks.  A brief description is given
+here.
 
    The inputs x and y are treated as each split into two parts of equal
 length (or the most significant part one limb shorter if N is odd).
@@ -6209,8 +6169,8 @@ positions where the three products must be added.
            sub | (x1-x0)*(y1-y0) |
                +--------+--------+
 
-   The term (x1-x0)*(y1-y0) is best calculated as an absolute value,
-and the sign used to choose to add or subtract.  Notice the sum
+   The term (x1-x0)*(y1-y0) is best calculated as an absolute value, and
+the sign used to choose to add or subtract.  Notice the sum
 high(x0*y0)+low(x1*y1) occurs twice, so it's possible to do 5*k limb
 additions, rather than 6*k, but in GMP extra function call overheads
 outweigh the saving.
@@ -6220,8 +6180,8 @@ to an equivalent with three squares,
 
      x^2 = (b^2+b)*x1^2 - b*(x1-x0)^2 + (b+1)*x0^2
 
-   The final result is accumulated from those three squares the same
-way as for the three multiplies above.  The middle term (x1-x0)^2 is now
+   The final result is accumulated from those three squares the same way
+as for the three multiplies above.  The middle term (x1-x0)^2 is now
 always positive.
 
    A similar formula for both multiplying and squaring can be
@@ -6230,21 +6190,21 @@ exceed k limbs, leading to more carry handling and additions than the
 form above.
 
    Karatsuba multiplication is asymptotically an O(N^1.585) algorithm,
-the exponent being log(3)/log(2), representing 3 multiplies each 1/2
-the size of the inputs.  This is a big improvement over the basecase
+the exponent being log(3)/log(2), representing 3 multiplies each 1/2 the
+size of the inputs.  This is a big improvement over the basecase
 multiply at O(N^2) and the advantage soon overcomes the extra additions
-Karatsuba performs.  `MUL_TOOM22_THRESHOLD' can be as little as 10
-limbs.  The `SQR' threshold is usually about twice the `MUL'.
+Karatsuba performs.  'MUL_TOOM22_THRESHOLD' can be as little as 10
+limbs.  The 'SQR' threshold is usually about twice the 'MUL'.
 
    The basecase algorithm will take a time of the form M(N) = a*N^2 +
 b*N + c and the Karatsuba algorithm K(N) = 3*M(N/2) + d*N + e, which
 expands to K(N) = 3/4*a*N^2 + 3/2*b*N + 3*c + d*N + e.  The factor 3/4
-for a means per-crossproduct speedups in the basecase code will
-increase the threshold since they benefit M(N) more than K(N).  And
-conversely the 3/2 for b means linear style speedups of b will increase
-the threshold since they benefit K(N) more than M(N).  The latter can
-be seen for instance when adding an optimized `mpn_sqr_diagonal' to
-`mpn_sqr_basecase'.  Of course all speedups reduce total time, and in
+for a means per-crossproduct speedups in the basecase code will increase
+the threshold since they benefit M(N) more than K(N). And conversely the
+3/2 for b means linear style speedups of b will increase the threshold
+since they benefit K(N) more than M(N). The latter can be seen for
+instance when adding an optimized 'mpn_sqr_diagonal' to
+'mpn_sqr_basecase'.  Of course all speedups reduce total time, and in
 that sense the algorithm thresholds are merely of academic interest.
 
 
@@ -6255,9 +6215,9 @@ File: gmp.info,  Node: Toom 3-Way Multiplication,  Next: Toom 4-Way Multiplicati
 
 The Karatsuba formula is the simplest case of a general approach to
 splitting inputs that leads to both Toom and FFT algorithms.  A
-description of Toom can be found in Knuth section 4.3.3, with an
-example 3-way calculation after Theorem A.  The 3-way form used in GMP
-is described here.
+description of Toom can be found in Knuth section 4.3.3, with an example
+3-way calculation after Theorem A.  The 3-way form used in GMP is
+described here.
 
    The operands are each considered split into 3 pieces of equal length
 (or the most significant part 1 or 2 limbs shorter than the other two).
@@ -6276,9 +6236,9 @@ These parts are treated as the coefficients of two polynomials
      X(t) = x2*t^2 + x1*t + x0
      Y(t) = y2*t^2 + y1*t + y0
 
-   Let b equal the power of 2 which is the size of the x0, x1, y0 and
-y1 pieces, ie. if they're k limbs each then b=2^(k*mp_bits_per_limb).
-With this x=X(b) and y=Y(b).
+   Let b equal the power of 2 which is the size of the x0, x1, y0 and y1
+pieces, ie. if they're k limbs each then b=2^(k*mp_bits_per_limb).  With
+this x=X(b) and y=Y(b).
 
    Let a polynomial W(t)=X(t)*Y(t) and suppose its coefficients are
 
@@ -6312,8 +6272,8 @@ this would need all nine x[i]*y[j] for i,j=0,1,2, and would be
 equivalent merely to a basecase multiply.  Instead the following
 approach is used.
 
-   X(t) and Y(t) are evaluated and multiplied at 5 points, giving
-values of W(t) at those points.  In GMP the following points are used,
+   X(t) and Y(t) are evaluated and multiplied at 5 points, giving values
+of W(t) at those points.  In GMP the following points are used,
 
      Point    Value
      t=0      x0 * y0, which gives w0 immediately
@@ -6323,13 +6283,13 @@ values of W(t) at those points.  In GMP the following points are used,
      t=inf    x2 * y2, which gives w4 immediately
 
    At t=-1 the values can be negative and that's handled using the
-absolute values and tracking the sign separately.  At t=inf the value
-is actually X(t)*Y(t)/t^4 in the limit as t approaches infinity, but
-it's much easier to think of as simply x2*y2 giving w4 immediately
-(much like x0*y0 at t=0 gives w0 immediately).
+absolute values and tracking the sign separately.  At t=inf the value is
+actually X(t)*Y(t)/t^4 in the limit as t approaches infinity, but it's
+much easier to think of as simply x2*y2 giving w4 immediately (much like
+x0*y0 at t=0 gives w0 immediately).
 
-   Each of the points substituted into W(t)=w4*t^4+...+w0 gives a
-linear combination of the w[i] coefficients, and the value of those
+   Each of the points substituted into W(t)=w4*t^4+...+w0 gives a linear
+combination of the w[i] coefficients, and the value of those
 combinations has just been calculated.
 
      W(0)   =                              w0
@@ -6338,22 +6298,22 @@ combinations has just been calculated.
      W(2)   = 16*w4 + 8*w3 + 4*w2 + 2*w1 + w0
      W(inf) =    w4
 
-   This is a set of five equations in five unknowns, and some
-elementary linear algebra quickly isolates each w[i].  This involves
-adding or subtracting one W(t) value from another, and a couple of
-divisions by powers of 2 and one division by 3, the latter using the
-special `mpn_divexact_by3' (*note Exact Division::).
+   This is a set of five equations in five unknowns, and some elementary
+linear algebra quickly isolates each w[i].  This involves adding or
+subtracting one W(t) value from another, and a couple of divisions by
+powers of 2 and one division by 3, the latter using the special
+'mpn_divexact_by3' (*note Exact Division::).
 
    The conversion of W(t) values to the coefficients is interpolation.
 A polynomial of degree 4 like W(t) is uniquely determined by values
-known at 5 different points.  The points are arbitrary and can be
-chosen to make the linear equations come out with a convenient set of
-steps for quickly isolating the w[i].
+known at 5 different points.  The points are arbitrary and can be chosen
+to make the linear equations come out with a convenient set of steps for
+quickly isolating the w[i].
 
    Squaring follows the same procedure as multiplication, but there's
 only one X(t) and it's evaluated at the 5 points, and those values
 squared to give values of W(t).  The interpolation is then identical,
-and in fact the same `toom3_interpolate' subroutine is used for both
+and in fact the same 'toom3_interpolate' subroutine is used for both
 squaring and multiplying.
 
    Toom-3 is asymptotically O(N^1.465), the exponent being
@@ -6364,18 +6324,18 @@ realizes its advantage above a certain size.
 
    Near the crossover between Toom-3 and Karatsuba there's generally a
 range of sizes where the difference between the two is small.
-`MUL_TOOM33_THRESHOLD' is a somewhat arbitrary point in that range and
+'MUL_TOOM33_THRESHOLD' is a somewhat arbitrary point in that range and
 successive runs of the tune program can give different values due to
 small variations in measuring.  A graph of time versus size for the two
-shows the effect, see `tune/README'.
+shows the effect, see 'tune/README'.
 
    At the fairly small sizes where the Toom-3 thresholds occur it's
-worth remembering that the asymptotic behaviour for Karatsuba and
-Toom-3 can't be expected to make accurate predictions, due of course to
-the big influence of all sorts of overheads, and the fact that only a
-few recursions of each are being performed.  Even at large sizes
-there's a good chance machine dependent effects like cache architecture
-will mean actual performance deviates from what might be predicted.
+worth remembering that the asymptotic behaviour for Karatsuba and Toom-3
+can't be expected to make accurate predictions, due of course to the big
+influence of all sorts of overheads, and the fact that only a few
+recursions of each are being performed.  Even at large sizes there's a
+good chance machine dependent effects like cache architecture will mean
+actual performance deviates from what might be predicted.
 
    The formula given for the Karatsuba algorithm (*note Karatsuba
 Multiplication::) has an equivalent for Toom-3 involving only five
@@ -6386,9 +6346,9 @@ References::), using a vector to represent the x and y splits and a
 matrix multiplication for the evaluation and interpolation stages.  The
 matrix inverses are not meant to be actually used, and they have
 elements with values much greater than in fact arise in the
-interpolation steps.  The diagram shown for the 3-way is attractive,
-but again doesn't have to be implemented that way and for example with
-a bit of rearrangement just one division by 6 can be done.
+interpolation steps.  The diagram shown for the 3-way is attractive, but
+again doesn't have to be implemented that way and for example with a bit
+of rearrangement just one division by 6 can be done.
 
 
 File: gmp.info,  Node: Toom 4-Way Multiplication,  Next: FFT Multiplication,  Prev: Toom 3-Way Multiplication,  Up: Multiplication Algorithms
@@ -6404,8 +6364,8 @@ multiplication, we form two polynomials:
      X(t) = x3*t^3 + x2*t^2 + x1*t + x0
      Y(t) = y3*t^3 + y2*t^2 + y1*t + y0
 
-   X(t) and Y(t) are evaluated and multiplied at 7 points, giving
-values of W(t) at those points.  In GMP the following points are used,
+   X(t) and Y(t) are evaluated and multiplied at 7 points, giving values
+of W(t) at those points.  In GMP the following points are used,
 
      Point    Value
      t=0      x0 * y0, which gives w0 immediately
@@ -6432,14 +6392,14 @@ File: gmp.info,  Node: FFT Multiplication,  Next: Other Multiplication,  Prev: T
 
 At large to very large sizes a Fermat style FFT multiplication is used,
 following Schnhage and Strassen (*note References::).  Descriptions of
-FFTs in various forms can be found in many textbooks, for instance
-Knuth section 4.3.3 part C or Lipson chapter IX.  A brief description
-of the form used in GMP is given here.
+FFTs in various forms can be found in many textbooks, for instance Knuth
+section 4.3.3 part C or Lipson chapter IX.  A brief description of the
+form used in GMP is given here.
 
-   The multiplication done is x*y mod 2^N+1, for a given N.  A full
-product x*y is obtained by choosing N>=bits(x)+bits(y) and padding x
-and y with high zero limbs.  The modular product is the native form for
-the algorithm, so padding to get a full product is unavoidable.
+   The multiplication done is x*y mod 2^N+1, for a given N. A full
+product x*y is obtained by choosing N>=bits(x)+bits(y) and padding x and
+y with high zero limbs.  The modular product is the native form for the
+algorithm, so padding to get a full product is unavoidable.
 
    The algorithm follows a split, evaluate, pointwise multiply,
 interpolate and combine similar to that described above for Karatsuba
@@ -6450,9 +6410,9 @@ bit shifts in the split and combine stages.
 
    The evaluations, pointwise multiplications, and interpolation, are
 all done modulo 2^N'+1 where N' is 2M+k+3 rounded up to a multiple of
-2^k and of `mp_bits_per_limb'.  The results of interpolation will be
-the following negacyclic convolution of the input pieces, and the
-choice of N' ensures these sums aren't truncated.
+2^k and of 'mp_bits_per_limb'.  The results of interpolation will be the
+following negacyclic convolution of the input pieces, and the choice of
+N' ensures these sums aren't truncated.
 
                 ---
                 \         b
@@ -6469,7 +6429,7 @@ interpolation do only shifts, adds and negations.
 
    The pointwise multiplications are done modulo 2^N'+1 and either
 recurse into a further FFT or use a plain multiplication (Toom-3,
-Karatsuba or basecase), whichever is optimal at the size N'.  The
+Karatsuba or basecase), whichever is optimal at the size N'. The
 interpolation is an inverse fast Fourier transform.  The resulting set
 of sums of x[i]*y[j] are added at appropriate offsets to give the final
 result.
@@ -6478,19 +6438,19 @@ result.
 at the evaluate stage and the pointwise multiplies are squares.  The
 interpolation is the same.
 
-   For a mod 2^N+1 product, an FFT-k is an O(N^(k/(k-1))) algorithm,
-the exponent representing 2^k recursed modular multiplies each
-1/2^(k-1) the size of the original.  Each successive k is an asymptotic
-improvement, but overheads mean each is only faster at bigger and
-bigger sizes.  In the code, `MUL_FFT_TABLE' and `SQR_FFT_TABLE' are the
-thresholds where each k is used.  Each new k effectively swaps some
-multiplying for some shifts, adds and overheads.
+   For a mod 2^N+1 product, an FFT-k is an O(N^(k/(k-1))) algorithm, the
+exponent representing 2^k recursed modular multiplies each 1/2^(k-1) the
+size of the original.  Each successive k is an asymptotic improvement,
+but overheads mean each is only faster at bigger and bigger sizes.  In
+the code, 'MUL_FFT_TABLE' and 'SQR_FFT_TABLE' are the thresholds where
+each k is used.  Each new k effectively swaps some multiplying for some
+shifts, adds and overheads.
 
    A mod 2^N+1 product can be formed with a normal NxN->2N bit multiply
 plus a subtraction, so an FFT and Toom-3 etc can be compared directly.
 A k=4 FFT at O(N^1.333) can be expected to be the first faster than
 Toom-3 at O(N^1.465).  In practice this is what's found, with
-`MUL_FFT_MODF_THRESHOLD' and `SQR_FFT_MODF_THRESHOLD' being between 300
+'MUL_FFT_MODF_THRESHOLD' and 'SQR_FFT_MODF_THRESHOLD' being between 300
 and 1000 limbs, depending on the CPU.  So far it's been found that only
 very large FFTs recurse into pointwise multiplies above these sizes.
 
@@ -6500,13 +6460,13 @@ considering where an FFT might be first used it can be assumed that the
 FFT is recursing into a normal multiply and that on that basis it's
 doing 2^k recursed multiplies each 1/2^(k-2) the size of the inputs,
 making it O(N^(k/(k-2))).  This would mean k=7 at O(N^1.4) would be the
-first FFT faster than Toom-3.  In practice `MUL_FFT_THRESHOLD' and
-`SQR_FFT_THRESHOLD' have been found to be in the k=8 range, somewhere
+first FFT faster than Toom-3.  In practice 'MUL_FFT_THRESHOLD' and
+'SQR_FFT_THRESHOLD' have been found to be in the k=8 range, somewhere
 between 3000 and 10000 limbs.
 
-   The way N is split into 2^k pieces and then 2M+k+3 is rounded up to
-a multiple of 2^k and `mp_bits_per_limb' means that when
-2^k>=mp_bits_per_limb the effective N is a multiple of 2^(2k-1) bits.
+   The way N is split into 2^k pieces and then 2M+k+3 is rounded up to a
+multiple of 2^k and 'mp_bits_per_limb' means that when
+2^k>=mp\_bits\_per\_limb the effective N is a multiple of 2^(2k-1) bits.
 The +k+3 means some values of N just under such a multiple will be
 rounded to the next.  The complexity calculations above assume that a
 favourable size is used, meaning one which isn't padded through
@@ -6515,17 +6475,17 @@ at typical FFT sizes.
 
    The practical effect of the 2^(2k-1) constraint is to introduce a
 step-effect into measured speeds.  For example k=8 will round N up to a
-multiple of 32768 bits, so for a 32-bit limb there'll be 512 limb
-groups of sizes for which `mpn_mul_n' runs at the same speed.  Or for
-k=9 groups of 2048 limbs, k=10 groups of 8192 limbs, etc.  In practice
-it's been found each k is used at quite small multiples of its size
+multiple of 32768 bits, so for a 32-bit limb there'll be 512 limb groups
+of sizes for which 'mpn_mul_n' runs at the same speed.  Or for k=9
+groups of 2048 limbs, k=10 groups of 8192 limbs, etc.  In practice it's
+been found each k is used at quite small multiples of its size
 constraint and so the step effect is quite noticeable in a time versus
 size graph.
 
    The threshold determinations currently measure at the mid-points of
 size steps, but this is sub-optimal since at the start of a new step it
 can happen that it's better to go back to the previous k for a while.
-Something more sophisticated for `MUL_FFT_TABLE' and `SQR_FFT_TABLE'
+Something more sophisticated for 'MUL_FFT_TABLE' and 'SQR_FFT_TABLE'
 will be needed.
 
 
@@ -6546,8 +6506,8 @@ algorithm is O(N^(log(2*r+1)/log(r+1))).  Only the pointwise
 multiplications count towards big-O complexity, but the time spent in
 the evaluate and interpolate stages grows with r and has a significant
 practical impact, with the asymptotic advantage of each r realized only
-at bigger and bigger sizes.  The overheads grow as O(N*r), whereas in
-an r=2^k FFT they grow only as O(N*log(r)).
+at bigger and bigger sizes.  The overheads grow as O(N*r), whereas in an
+r=2^k FFT they grow only as O(N*log(r)).
 
    Knuth algorithm C evaluates at points 0,1,2,...,2*r, but exercise 4
 uses -r,...,0,...,r and the latter saves some small multiplies in the
@@ -6557,14 +6517,14 @@ odd and even final coefficients and then perform algorithm C steps C7
 and C8 on them separately.  The divisors at step C7 become j^2 and the
 multipliers at C8 become 2*t*j-j^2.
 
-   Splitting odd and even parts through positive and negative points
-can be thought of as using -1 as a square root of unity.  If a 4th root
-of unity was available then a further split and speedup would be
-possible, but no such root exists for plain integers.  Going to complex
-integers with i=sqrt(-1) doesn't help, essentially because in Cartesian
-form it takes three real multiplies to do a complex multiply.  The
-existence of 2^k'th roots of unity in a suitable ring or field lets the
-fast Fourier transform keep splitting and get to O(N*log(r)).
+   Splitting odd and even parts through positive and negative points can
+be thought of as using -1 as a square root of unity.  If a 4th root of
+unity was available then a further split and speedup would be possible,
+but no such root exists for plain integers.  Going to complex integers
+with i=sqrt(-1) doesn't help, essentially because in Cartesian form it
+takes three real multiplies to do a complex multiply.  The existence of
+2^k'th roots of unity in a suitable ring or field lets the fast Fourier
+transform keep splitting and get to O(N*log(r)).
 
    Floating point FFTs use complex numbers approximating Nth roots of
 unity.  Some processors have special support for such FFTs.  But these
@@ -6580,17 +6540,17 @@ File: gmp.info,  Node: Unbalanced Multiplication,  Prev: Other Multiplication,
 --------------------------------
 
 Multiplication of operands with different sizes, both below
-`MUL_TOOM22_THRESHOLD' are done with plain schoolbook multiplication
+'MUL_TOOM22_THRESHOLD' are done with plain schoolbook multiplication
 (*note Basecase Multiplication::).
 
    For really large operands, we invoke FFT directly.
 
    For operands between these sizes, we use Toom inspired algorithms
-suggested by Alberto Zanoni and Marco Bodrato.  The idea is to split
-the operands into polynomials of different degree.  GMP currently
-splits the smaller operand onto 2 coefficients, i.e., a polynomial of
-degree 1, but the larger operand can be split into 2, 3, or 4
-coefficients, i.e., a polynomial of degree 1 to 3.
+suggested by Alberto Zanoni and Marco Bodrato.  The idea is to split the
+operands into polynomials of different degree.  GMP currently splits the
+smaller operand onto 2 coefficients, i.e., a polynomial of degree 1, but
+the larger operand can be split into 2, 3, or 4 coefficients, i.e., a
+polynomial of degree 1 to 3.
 
 
 File: gmp.info,  Node: Division Algorithms,  Next: Greatest Common Divisor Algorithms,  Prev: Multiplication Algorithms,  Up: Algorithms
@@ -6619,27 +6579,27 @@ low, either with a hardware divide instruction or a multiplication by
 inverse, whichever is best on a given CPU.
 
    The multiply by inverse follows "Improved division by invariant
-integers" by Mller and Granlund (*note References::) and is
-implemented as `udiv_qrnnd_preinv' in `gmp-impl.h'.  The idea is to
-have a fixed-point approximation to 1/d (see `invert_limb') and then
-multiply by the high limb (plus one bit) of the dividend to get a
-quotient q.  With d normalized (high bit set), q is no more than 1 too
-small.  Subtracting q*d from the dividend gives a remainder, and
-reveals whether q or q-1 is correct.
+integers" by Mller and Granlund (*note References::) and is implemented
+as 'udiv_qrnnd_preinv' in 'gmp-impl.h'.  The idea is to have a
+fixed-point approximation to 1/d (see 'invert_limb') and then multiply
+by the high limb (plus one bit) of the dividend to get a quotient q.
+With d normalized (high bit set), q is no more than 1 too small.
+Subtracting q*d from the dividend gives a remainder, and reveals whether
+q or q-1 is correct.
 
    The result is a division done with two multiplications and four or
 five arithmetic operations.  On CPUs with low latency multipliers this
 can be much faster than a hardware divide, though the cost of
-calculating the inverse at the start may mean it's only better on
-inputs bigger than say 4 or 5 limbs.
+calculating the inverse at the start may mean it's only better on inputs
+bigger than say 4 or 5 limbs.
 
    When a divisor must be normalized, either for the generic C
-`__udiv_qrnnd_c' or the multiply by inverse, the division performed is
+'__udiv_qrnnd_c' or the multiply by inverse, the division performed is
 actually a*2^k by d*2^k where a is the dividend and k is the power
 necessary to have the high bit of d*2^k set.  The bit shifts for the
-dividend are usually accomplished "on the fly" meaning by extracting
-the appropriate bits at each step.  Done this way the quotient limbs
-come out aligned ready to store.  When only the remainder is wanted, an
+dividend are usually accomplished "on the fly" meaning by extracting the
+appropriate bits at each step.  Done this way the quotient limbs come
+out aligned ready to store.  When only the remainder is wanted, an
 alternative is to take the dividend limbs unshifted and calculate r = a
 mod d*2^k followed by an extra final step r*2^k mod d*2^k.  This can
 help on CPUs with poor bit shifts or few registers.
@@ -6656,10 +6616,10 @@ though the extra work to apply the inverse will almost certainly soon
 reach the limits of multiplier throughput.
 
    A similar approach in reverse can be taken to process just half a
-limb at a time if the divisor is only a half limb.  In this case the
-1x1 multiply for the inverse effectively becomes two (1/2)x1 for each
-limb, which can be a saving on CPUs with a fast half limb multiply, or
-in fact if the only multiply is a half limb, and especially if it's not
+limb at a time if the divisor is only a half limb.  In this case the 1x1
+multiply for the inverse effectively becomes two (1/2)x1 for each limb,
+which can be a saving on CPUs with a fast half limb multiply, or in fact
+if the only multiply is a half limb, and especially if it's not
 pipelined.
 
 
@@ -6670,17 +6630,17 @@ File: gmp.info,  Node: Basecase Division,  Next: Divide and Conquer Division,  P
 
 Basecase NxM division is like long division done by hand, but in base
 2^mp_bits_per_limb.  See Knuth section 4.3.1 algorithm D, and
-`mpn/generic/sb_divrem_mn.c'.
-
-   Briefly stated, while the dividend remains larger than the divisor,
-a high quotient limb is formed and the Nx1 product q*d subtracted at
-the top end of the dividend.  With a normalized divisor (most
-significant bit set), each quotient limb can be formed with a 2x1
-division and a 1x1 multiplication plus some subtractions.  The 2x1
-division is by the high limb of the divisor and is done either with a
-hardware divide or a multiply by inverse (the same as in *note Single
-Limb Division::) whichever is faster.  Such a quotient is sometimes one
-too big, requiring an addback of the divisor, but that happens rarely.
+'mpn/generic/sb_divrem_mn.c'.
+
+   Briefly stated, while the dividend remains larger than the divisor, a
+high quotient limb is formed and the Nx1 product q*d subtracted at the
+top end of the dividend.  With a normalized divisor (most significant
+bit set), each quotient limb can be formed with a 2x1 division and a 1x1
+multiplication plus some subtractions.  The 2x1 division is by the high
+limb of the divisor and is done either with a hardware divide or a
+multiply by inverse (the same as in *note Single Limb Division::)
+whichever is faster.  Such a quotient is sometimes one too big,
+requiring an addback of the divisor, but that happens rarely.
 
    With Q=N-M being the number of quotient limbs, this is an O(Q*M)
 algorithm and will run at a speed similar to a basecase QxM
@@ -6693,7 +6653,7 @@ File: gmp.info,  Node: Divide and Conquer Division,  Next: Block-Wise Barrett Di
 16.2.3 Divide and Conquer Division
 ----------------------------------
 
-For divisors larger than `DC_DIV_QR_THRESHOLD', division is done by
+For divisors larger than 'DC_DIV_QR_THRESHOLD', division is done by
 dividing.  Or to be precise by a recursive divide and conquer algorithm
 based on work by Moenck and Borodin, Jebelean, and Burnikel and Ziegler
 (*note References::).
@@ -6710,22 +6670,22 @@ formed by recursive Nx(N/2) divisions.
 then the work is about the same as a basecase division, but with more
 function call overheads and with some subtractions separated from the
 multiplies.  These overheads mean that it's only when N/2 is above
-`MUL_TOOM22_THRESHOLD' that divide and conquer is of use.
+'MUL_TOOM22_THRESHOLD' that divide and conquer is of use.
 
-   `DC_DIV_QR_THRESHOLD' is based on the divisor size N, so it will be
-somewhere above twice `MUL_TOOM22_THRESHOLD', but how much above
-depends on the CPU.  An optimized `mpn_mul_basecase' can lower
-`DC_DIV_QR_THRESHOLD' a little by offering a ready-made advantage over
-repeated `mpn_submul_1' calls.
+   'DC_DIV_QR_THRESHOLD' is based on the divisor size N, so it will be
+somewhere above twice 'MUL_TOOM22_THRESHOLD', but how much above depends
+on the CPU.  An optimized 'mpn_mul_basecase' can lower
+'DC_DIV_QR_THRESHOLD' a little by offering a ready-made advantage over
+repeated 'mpn_submul_1' calls.
 
-   Divide and conquer is asymptotically O(M(N)*log(N)) where M(N) is
-the time for an NxN multiplication done with FFTs.  The actual time is
-a sum over multiplications of the recursed sizes, as can be seen near
-the end of section 2.2 of Burnikel and Ziegler.  For example, within
-the Toom-3 range, divide and conquer is 2.63*M(N).  With higher
-algorithms the M(N) term improves and the multiplier tends to log(N).
-In practice, at moderate to large sizes, a 2NxN division is about 2 to
-4 times slower than an NxN multiplication.
+   Divide and conquer is asymptotically O(M(N)*log(N)) where M(N) is the
+time for an NxN multiplication done with FFTs.  The actual time is a sum
+over multiplications of the recursed sizes, as can be seen near the end
+of section 2.2 of Burnikel and Ziegler.  For example, within the Toom-3
+range, divide and conquer is 2.63*M(N). With higher algorithms the M(N)
+term improves and the multiplier tends to log(N). In practice, at
+moderate to large sizes, a 2NxN division is about 2 to 4 times slower
+than an NxN multiplication.
 
 
 File: gmp.info,  Node: Block-Wise Barrett Division,  Next: Exact Division,  Prev: Divide and Conquer Division,  Up: Division Algorithms
@@ -6735,12 +6695,11 @@ File: gmp.info,  Node: Block-Wise Barrett Division,  Next: Exact Division,  Prev
 
 For the largest divisions, a block-wise Barrett division algorithm is
 used.  Here, the divisor is inverted to a precision determined by the
-relative size of the dividend and divisor.  Blocks of quotient limbs
-are then generated by multiplying blocks from the dividend by the
-inverse.
+relative size of the dividend and divisor.  Blocks of quotient limbs are
+then generated by multiplying blocks from the dividend by the inverse.
 
-   Our block-wise algorithm computes a smaller inverse than in the
-plain Barrett algorithm.  For a 2n/n division, the inverse will be just
+   Our block-wise algorithm computes a smaller inverse than in the plain
+Barrett algorithm.  For a 2n/n division, the inverse will be just
 ceil(n/2) limbs.
 
 
@@ -6760,28 +6719,28 @@ using the fact 7 is the modular inverse of 3 (the low digit of the
 divisor), since 3*7 == 1 mod 10.  So 8*543=4344 can be subtracted from
 the dividend leaving 363810.  Notice the low digit has become zero.
 
-   The procedure is repeated at the second digit, with the next
-quotient digit 7 (7 == 1*7 mod 10), subtracting 7*543=3801, leaving
-325800.  And finally at the third digit with quotient digit 6 (8*7 mod
-10), subtracting 6*543=3258 leaving 0.  So the quotient is 678.
+   The procedure is repeated at the second digit, with the next quotient
+digit 7 (7 == 1*7 mod 10), subtracting 7*543=3801, leaving 325800.  And
+finally at the third digit with quotient digit 6 (8*7 mod 10),
+subtracting 6*543=3258 leaving 0.  So the quotient is 678.
 
    Notice however that the multiplies and subtractions don't need to
-extend past the low three digits of the dividend, since that's enough
-to determine the three quotient digits.  For the last quotient digit no
+extend past the low three digits of the dividend, since that's enough to
+determine the three quotient digits.  For the last quotient digit no
 subtraction is needed at all.  On a 2NxN division like this one, only
 about half the work of a normal basecase division is necessary.
 
    For an NxM exact division producing Q=N-M quotient limbs, the saving
-over a normal basecase division is in two parts.  Firstly, each of the
-Q quotient limbs needs only one multiply, not a 2x1 divide and
-multiply.  Secondly, the crossproducts are reduced when Q>M to
-Q*M-M*(M+1)/2, or when Q<=M to Q*(Q-1)/2.  Notice the savings are
-complementary.  If Q is big then many divisions are saved, or if Q is
-small then the crossproducts reduce to a small number.
-
-   The modular inverse used is calculated efficiently by `binvert_limb'
-in `gmp-impl.h'.  This does four multiplies for a 32-bit limb, or six
-for a 64-bit limb.  `tune/modlinv.c' has some alternate implementations
+over a normal basecase division is in two parts.  Firstly, each of the Q
+quotient limbs needs only one multiply, not a 2x1 divide and multiply.
+Secondly, the crossproducts are reduced when Q>M to Q*M-M*(M+1)/2, or
+when Q<=M to Q*(Q-1)/2.  Notice the savings are complementary.  If Q is
+big then many divisions are saved, or if Q is small then the
+crossproducts reduce to a small number.
+
+   The modular inverse used is calculated efficiently by 'binvert_limb'
+in 'gmp-impl.h'.  This does four multiplies for a 32-bit limb, or six
+for a 64-bit limb.  'tune/modlinv.c' has some alternate implementations
 that might suit processors better at bit twiddling than multiplying.
 
    The sub-quadratic exact division described by Jebelean in "Exact
@@ -6794,10 +6753,10 @@ forms quotient limbs from both the high and low ends of the dividend,
 and can halve once more the number of crossproducts needed in a 2NxN
 division.
 
-   A special case exact division by 3 exists in `mpn_divexact_by3',
-supporting Toom-3 multiplication and `mpq' canonicalizations.  It forms
+   A special case exact division by 3 exists in 'mpn_divexact_by3',
+supporting Toom-3 multiplication and 'mpq' canonicalizations.  It forms
 quotient digits with a multiply by the modular inverse of 3 (which is
-`0xAA..AAB') and uses two comparisons to determine a borrow for the next
+'0xAA..AAB') and uses two comparisons to determine a borrow for the next
 limb.  The multiplications don't need to be on the dependent chain, as
 long as the effect of the borrows is applied, which can help chips with
 pipelined multipliers.
@@ -6810,9 +6769,9 @@ File: gmp.info,  Node: Exact Remainder,  Next: Small Quotient Division,  Prev: E
 
 If the exact division algorithm is done with a full subtraction at each
 stage and the dividend isn't a multiple of the divisor, then low zero
-limbs are produced but with a remainder in the high limbs.  For
-dividend a, divisor d, quotient q, and b = 2^mp_bits_per_limb, this
-remainder r is of the form
+limbs are produced but with a remainder in the high limbs.  For dividend
+a, divisor d, quotient q, and b = 2^mp_bits_per_limb, this remainder r
+is of the form
 
      a = q*d + r*b^n
 
@@ -6821,13 +6780,13 @@ that being the number of limbs produced for q.  r will be in the range
 0<=r<d and can be viewed as a remainder, but one shifted up by a factor
 of b^n.
 
-   Carrying out full subtractions at each stage means the same number
-of cross products must be done as a normal division, but there's still
-some single limb divisions saved.  When d is a single limb some
+   Carrying out full subtractions at each stage means the same number of
+cross products must be done as a normal division, but there's still some
+single limb divisions saved.  When d is a single limb some
 simplifications arise, providing good speedups on a number of
 processors.
 
-   `mpn_divexact_by3', `mpn_modexact_1_odd' and the `mpn_redc_X'
+   'mpn_divexact_by3', 'mpn_modexact_1_odd' and the 'mpn_redc_X'
 functions differ subtly in how they return r, leading to some negations
 in the above formula, but all are essentially the same.
 
@@ -6836,19 +6795,19 @@ divisibility or congruence tests which are potentially more efficient
 than a normal division.
 
    The factor of b^n on r can be ignored in a GCD when d is odd, hence
-the use of `mpn_modexact_1_odd' by `mpn_gcd_1' and `mpz_kronecker_ui'
+the use of 'mpn_modexact_1_odd' by 'mpn_gcd_1' and 'mpz_kronecker_ui'
 etc (*note Greatest Common Divisor Algorithms::).
 
-   Montgomery's REDC method for modular multiplications uses operands
-of the form of x*b^-n and y*b^-n and on calculating (x*b^-n)*(y*b^-n)
-uses the factor of b^n in the exact remainder to reach a product in the
-same form (x*y)*b^-n (*note Modular Powering Algorithm::).
+   Montgomery's REDC method for modular multiplications uses operands of
+the form of x*b^-n and y*b^-n and on calculating (x*b^-n)*(y*b^-n) uses
+the factor of b^n in the exact remainder to reach a product in the same
+form (x*y)*b^-n (*note Modular Powering Algorithm::).
 
    Notice that r generally gives no useful information about the
 ordinary remainder a mod d since b^n mod d could be anything.  If
 however b^n == 1 mod d, then r is the negative of the ordinary
 remainder.  This occurs whenever d is a factor of b^n-1, as for example
-with 3 in `mpn_divexact_by3'.  For a 32 or 64 bit limb other such
+with 3 in 'mpn_divexact_by3'.  For a 32 or 64 bit limb other such
 factors include 5, 17 and 257, but no particular use has been found for
 this.
 
@@ -6858,16 +6817,16 @@ File: gmp.info,  Node: Small Quotient Division,  Prev: Exact Remainder,  Up: Div
 16.2.7 Small Quotient Division
 ------------------------------
 
-An NxM division where the number of quotient limbs Q=N-M is small can
-be optimized somewhat.
+An NxM division where the number of quotient limbs Q=N-M is small can be
+optimized somewhat.
 
    An ordinary basecase division normalizes the divisor by shifting it
 to make the high bit set, shifting the dividend accordingly, and
-shifting the remainder back down at the end of the calculation.  This
-is wasteful if only a few quotient limbs are to be formed.  Instead a
-division of just the top 2*Q limbs of the dividend by the top Q limbs
-of the divisor can be used to form a trial quotient.  This requires
-only those limbs normalized, not the whole of the divisor and dividend.
+shifting the remainder back down at the end of the calculation.  This is
+wasteful if only a few quotient limbs are to be formed.  Instead a
+division of just the top 2*Q limbs of the dividend by the top Q limbs of
+the divisor can be used to form a trial quotient.  This requires only
+those limbs normalized, not the whole of the divisor and dividend.
 
    A multiply and subtract then applies the trial quotient to the M-Q
 unused limbs of the divisor and N-Q dividend limbs (which includes Q
@@ -6878,11 +6837,11 @@ limbs that will arise from the subtraction.  An addback is done if the
 quotient still turns out to be 1 too big.
 
    This whole procedure is essentially the same as one step of the
-basecase algorithm done in a Q limb base, though with the trial
-quotient test done only with the high limbs, not an entire Q limb
-"digit" product.  The correctness of this weaker test can be
-established by following the argument of Knuth section 4.3.1 exercise
-20 but with the v2*q>b*r+u2 condition appropriately relaxed.
+basecase algorithm done in a Q limb base, though with the trial quotient
+test done only with the high limbs, not an entire Q limb "digit"
+product.  The correctness of this weaker test can be established by
+following the argument of Knuth section 4.3.1 exercise 20 but with the
+v2*q>b*r+u2 condition appropriately relaxed.
 
 
 File: gmp.info,  Node: Greatest Common Divisor Algorithms,  Next: Powering Algorithms,  Prev: Division Algorithms,  Up: Algorithms
@@ -6912,25 +6871,25 @@ simply consists of successively reducing odd operands a and b using
      strip factors of 2 from a
 
    The Euclidean GCD algorithm, as per Knuth algorithms E and A,
-repeatedly computes the quotient q = floor(a/b) and replaces a,b by v,
-u - q v. The binary algorithm has so far been found to be faster than
-the Euclidean algorithm everywhere.  One reason the binary method does
-well is that the implied quotient at each step is usually small, so
-often only one or two subtractions are needed to get the same effect as
-a division.  Quotients 1, 2 and 3 for example occur 67.7% of the time,
-see Knuth section 4.5.3 Theorem E.
-
-   When the implied quotient is large, meaning b is much smaller than
-a, then a division is worthwhile.  This is the basis for the initial a
-mod b reductions in `mpn_gcd' and `mpn_gcd_1' (the latter for both Nx1
-and 1x1 cases).  But after that initial reduction, big quotients occur
-too rarely to make it worth checking for them.
-
-
-   The final 1x1 GCD in `mpn_gcd_1' is done in the generic C code as
-described above.  For two N-bit operands, the algorithm takes about
-0.68 iterations per bit.  For optimum performance some attention needs
-to be paid to the way the factors of 2 are stripped from a.
+repeatedly computes the quotient q = floor(a/b) and replaces a,b by v, u
+- q v.  The binary algorithm has so far been found to be faster than the
+Euclidean algorithm everywhere.  One reason the binary method does well
+is that the implied quotient at each step is usually small, so often
+only one or two subtractions are needed to get the same effect as a
+division.  Quotients 1, 2 and 3 for example occur 67.7% of the time, see
+Knuth section 4.5.3 Theorem E.
+
+   When the implied quotient is large, meaning b is much smaller than a,
+then a division is worthwhile.  This is the basis for the initial a mod
+b reductions in 'mpn_gcd' and 'mpn_gcd_1' (the latter for both Nx1 and
+1x1 cases).  But after that initial reduction, big quotients occur too
+rarely to make it worth checking for them.
+
+
+   The final 1x1 GCD in 'mpn_gcd_1' is done in the generic C code as
+described above.  For two N-bit operands, the algorithm takes about 0.68
+iterations per bit.  For optimum performance some attention needs to be
+paid to the way the factors of 2 are stripped from a.
 
    Firstly it may be noted that in twos complement the number of low
 zero bits on a-b is the same as b-a, so counting or testing can begin on
@@ -6939,8 +6898,8 @@ a-b without waiting for abs(a-b) to be determined.
    A loop stripping low zero bits tends not to branch predict well,
 since the condition is data dependent.  But on average there's only a
 few low zeros, so an option is to strip one or two bits arithmetically
-then loop for more (as done for AMD K6).  Or use a lookup table to get
-a count for several bits then loop for more (as done for AMD K7).  An
+then loop for more (as done for AMD K6).  Or use a lookup table to get a
+count for several bits then loop for more (as done for AMD K7).  An
 alternative approach is to keep just one of a or b odd and iterate
 
      a,b = abs(a-b), min(a,b)
@@ -6968,90 +6927,88 @@ File: gmp.info,  Node: Lehmer's Algorithm,  Next: Subquadratic GCD,  Prev: Binar
 
 Lehmer's improvement of the Euclidean algorithms is based on the
 observation that the initial part of the quotient sequence depends only
-on the most significant parts of the inputs. The variant of Lehmer's
+on the most significant parts of the inputs.  The variant of Lehmer's
 algorithm used in GMP splits off the most significant two limbs, as
-suggested, e.g., in "A Double-Digit Lehmer-Euclid Algorithm" by
-Jebelean (*note References::). The quotients of two double-limb inputs
-are collected as a 2 by 2 matrix with single-limb elements. This is
-done by the function `mpn_hgcd2'. The resulting matrix is applied to
-the inputs using `mpn_mul_1' and `mpn_submul_1'. Each iteration usually
-reduces the inputs by almost one limb. In the rare case of a large
-quotient, no progress can be made by examining just the most
-significant two limbs, and the quotient is computed using plain
-division.
+suggested, e.g., in "A Double-Digit Lehmer-Euclid Algorithm" by Jebelean
+(*note References::).  The quotients of two double-limb inputs are
+collected as a 2 by 2 matrix with single-limb elements.  This is done by
+the function 'mpn_hgcd2'.  The resulting matrix is applied to the inputs
+using 'mpn_mul_1' and 'mpn_submul_1'.  Each iteration usually reduces
+the inputs by almost one limb.  In the rare case of a large quotient, no
+progress can be made by examining just the most significant two limbs,
+and the quotient is computed using plain division.
 
    The resulting algorithm is asymptotically O(N^2), just as the
-Euclidean algorithm and the binary algorithm. The quadratic part of the
-work are the calls to `mpn_mul_1' and `mpn_submul_1'. For small sizes,
-the linear work is also significant. There are roughly N calls to the
-`mpn_hgcd2' function. This function uses a couple of important
+Euclidean algorithm and the binary algorithm.  The quadratic part of the
+work are the calls to 'mpn_mul_1' and 'mpn_submul_1'.  For small sizes,
+the linear work is also significant.  There are roughly N calls to the
+'mpn_hgcd2' function.  This function uses a couple of important
 optimizations:
 
-   * It uses the same relaxed notion of correctness as `mpn_hgcd' (see
-     next section). This means that when called with the most
+   * It uses the same relaxed notion of correctness as 'mpn_hgcd' (see
+     next section).  This means that when called with the most
      significant two limbs of two large numbers, the returned matrix
-     does not always correspond exactly to the initial quotient
-     sequence for the two large numbers; the final quotient may
-     sometimes be one off.
+     does not always correspond exactly to the initial quotient sequence
+     for the two large numbers; the final quotient may sometimes be one
+     off.
 
    * It takes advantage of the fact the quotients are usually small.
      The division operator is not used, since the corresponding
-     assembler instruction is very slow on most architectures. (This
-     code could probably be improved further, it uses many branches
-     that are unfriendly to prediction).
+     assembler instruction is very slow on most architectures.  (This
+     code could probably be improved further, it uses many branches that
+     are unfriendly to prediction).
 
    * It switches from double-limb calculations to single-limb
      calculations half-way through, when the input numbers have been
      reduced in size from two limbs to one and a half.
 
-
 
 File: gmp.info,  Node: Subquadratic GCD,  Next: Extended GCD,  Prev: Lehmer's Algorithm,  Up: Greatest Common Divisor Algorithms
 
 16.3.3 Subquadratic GCD
 -----------------------
 
-For inputs larger than `GCD_DC_THRESHOLD', GCD is computed via the HGCD
+For inputs larger than 'GCD_DC_THRESHOLD', GCD is computed via the HGCD
 (Half GCD) function, as a generalization to Lehmer's algorithm.
 
-   Let the inputs a,b be of size N limbs each. Put S = floor(N/2) + 1.
+   Let the inputs a,b be of size N limbs each.  Put S = floor(N/2) + 1.
 Then HGCD(a,b) returns a transformation matrix T with non-negative
-elements, and reduced numbers (c;d) = T^-1 (a;b). The reduced numbers
+elements, and reduced numbers (c;d) = T^{-1} (a;b).  The reduced numbers
 c,d must be larger than S limbs, while their difference abs(c-d) must
-fit in S limbs. The matrix elements will also be of size roughly N/2.
+fit in S limbs.  The matrix elements will also be of size roughly N/2.
 
    The HGCD base case uses Lehmer's algorithm, but with the above stop
 condition that returns reduced numbers and the corresponding
-transformation matrix half-way through. For inputs larger than
-`HGCD_THRESHOLD', HGCD is computed recursively, using the divide and
+transformation matrix half-way through.  For inputs larger than
+'HGCD_THRESHOLD', HGCD is computed recursively, using the divide and
 conquer algorithm in "On Schnhage's algorithm and subquadratic integer
-GCD computation" by Mller (*note References::). The recursive
+GCD computation" by Mller (*note References::).  The recursive
 algorithm consists of these main steps.
 
-   * Call HGCD recursively, on the most significant N/2 limbs. Apply the
-     resulting matrix T_1 to the full numbers, reducing them to a size
-     just above 3N/2.
+   * Call HGCD recursively, on the most significant N/2 limbs.  Apply
+     the resulting matrix T_1 to the full numbers, reducing them to a
+     size just above 3N/2.
 
    * Perform a small number of division or subtraction steps to reduce
-     the numbers to size below 3N/2. This is essential mainly for the
+     the numbers to size below 3N/2.  This is essential mainly for the
      unlikely case of large quotients.
 
    * Call HGCD recursively, on the most significant N/2 limbs of the
-     reduced numbers. Apply the resulting matrix T_2 to the full
+     reduced numbers.  Apply the resulting matrix T_2 to the full
      numbers, reducing them to a size just above N/2.
 
    * Compute T = T_1 T_2.
 
-   * Perform a small number of division and subtraction steps to
-     satisfy the requirements, and return.
+   * Perform a small number of division and subtraction steps to satisfy
+     the requirements, and return.
 
    GCD is then implemented as a loop around HGCD, similarly to Lehmer's
-algorithm. Where Lehmer repeatedly chops off the top two limbs, calls
-`mpn_hgcd2', and applies the resulting matrix to the full numbers, the
+algorithm.  Where Lehmer repeatedly chops off the top two limbs, calls
+'mpn_hgcd2', and applies the resulting matrix to the full numbers, the
 subquadratic GCD chops off the most significant third of the limbs (the
 proportion is a tuning parameter, and 1/3 seems to be more efficient
-than, e.g, 1/2), calls `mpn_hgcd', and applies the resulting matrix.
-Once the input numbers are reduced to size below `GCD_DC_THRESHOLD',
+than, e.g, 1/2), calls 'mpn_hgcd', and applies the resulting matrix.
+Once the input numbers are reduced to size below 'GCD_DC_THRESHOLD',
 Lehmer's algorithm is used for the rest of the work.
 
    The asymptotic running time of both HGCD and GCD is O(M(N)*log(N)),
@@ -7064,23 +7021,23 @@ File: gmp.info,  Node: Extended GCD,  Next: Jacobi Symbol,  Prev: Subquadratic G
 -------------------
 
 The extended GCD function, or GCDEXT, calculates gcd(a,b) and also
-cofactors x and y satisfying a*x+b*y=gcd(a,b). All the algorithms used
-for plain GCD are extended to handle this case. The binary algorithm is
-used only for single-limb GCDEXT.  Lehmer's algorithm is used for sizes
-up to `GCDEXT_DC_THRESHOLD'. Above this threshold, GCDEXT is
+cofactors x and y satisfying a*x+b*y=gcd(a,b).  All the algorithms used
+for plain GCD are extended to handle this case.  The binary algorithm is
+used only for single-limb GCDEXT. Lehmer's algorithm is used for sizes
+up to 'GCDEXT_DC_THRESHOLD'.  Above this threshold, GCDEXT is
 implemented as a loop around HGCD, but with more book-keeping to keep
-track of the cofactors. This gives the same asymptotic running time as
+track of the cofactors.  This gives the same asymptotic running time as
 for GCD and HGCD, O(M(N)*log(N))
 
    One difference to plain GCD is that while the inputs a and b are
 reduced as the algorithm proceeds, the cofactors x and y grow in size.
-This makes the tuning of the chopping-point more difficult. The current
+This makes the tuning of the chopping-point more difficult.  The current
 code chops off the most significant half of the inputs for the call to
-HGCD in the first iteration, and the most significant two thirds for
-the remaining calls. This strategy could surely be improved. Also the
-stop condition for the loop, where Lehmer's algorithm is invoked once
-the inputs are reduced below `GCDEXT_DC_THRESHOLD', could maybe be
-improved by taking into account the current size of the cofactors.
+HGCD in the first iteration, and the most significant two thirds for the
+remaining calls.  This strategy could surely be improved.  Also the stop
+condition for the loop, where Lehmer's algorithm is invoked once the
+inputs are reduced below 'GCDEXT_DC_THRESHOLD', could maybe be improved
+by taking into account the current size of the cofactors.
 
 
 File: gmp.info,  Node: Jacobi Symbol,  Prev: Extended GCD,  Up: Greatest Common Divisor Algorithms
@@ -7088,20 +7045,20 @@ File: gmp.info,  Node: Jacobi Symbol,  Prev: Extended GCD,  Up: Greatest Common
 16.3.5 Jacobi Symbol
 --------------------
 
-`mpz_jacobi' and `mpz_kronecker' are currently implemented with a
-simple binary algorithm similar to that described for the GCDs (*note
-Binary GCD::).  They're not very fast when both inputs are large.
-Lehmer's multi-step improvement or a binary based multi-step algorithm
-is likely to be better.
+'mpz_jacobi' and 'mpz_kronecker' are currently implemented with a simple
+binary algorithm similar to that described for the GCDs (*note Binary
+GCD::).  They're not very fast when both inputs are large.  Lehmer's
+multi-step improvement or a binary based multi-step algorithm is likely
+to be better.
 
    When one operand fits a single limb, and that includes
-`mpz_kronecker_ui' and friends, an initial reduction is done with
-either `mpn_mod_1' or `mpn_modexact_1_odd', followed by the binary
-algorithm on a single limb.  The binary algorithm is well suited to a
-single limb, and the whole calculation in this case is quite efficient.
+'mpz_kronecker_ui' and friends, an initial reduction is done with either
+'mpn_mod_1' or 'mpn_modexact_1_odd', followed by the binary algorithm on
+a single limb.  The binary algorithm is well suited to a single limb,
+and the whole calculation in this case is quite efficient.
 
-   In all the routines sign changes for the result are accumulated
-using some bit twiddling, avoiding table lookups or conditional jumps.
+   In all the routines sign changes for the result are accumulated using
+some bit twiddling, avoiding table lookups or conditional jumps.
 
 
 File: gmp.info,  Node: Powering Algorithms,  Next: Root Extraction Algorithms,  Prev: Greatest Common Divisor Algorithms,  Up: Algorithms
@@ -7120,11 +7077,11 @@ File: gmp.info,  Node: Normal Powering Algorithm,  Next: Modular Powering Algori
 16.4.1 Normal Powering
 ----------------------
 
-Normal `mpz' or `mpf' powering uses a simple binary algorithm,
+Normal 'mpz' or 'mpf' powering uses a simple binary algorithm,
 successively squaring and then multiplying by the base when a 1 bit is
 seen in the exponent, as per Knuth section 4.6.3.  The "left to right"
-variant described there is used rather than algorithm A, since it's
-just as easy and can be done with somewhat less temporary memory.
+variant described there is used rather than algorithm A, since it's just
+as easy and can be done with somewhat less temporary memory.
 
 
 File: gmp.info,  Node: Modular Powering Algorithm,  Prev: Normal Powering Algorithm,  Up: Powering Algorithms
@@ -7168,8 +7125,8 @@ Paul Zimmermann (*note References::).
 
    An input n is split into four parts of k bits each, so with b=2^k we
 have n = a3*b^3 + a2*b^2 + a1*b + a0.  Part a3 must be "normalized" so
-that either the high or second highest bit is set.  In GMP, k is kept
-on a limb boundary and the input is left shifted (by an even number of
+that either the high or second highest bit is set.  In GMP, k is kept on
+a limb boundary and the input is left shifted (by an even number of
 bits) to normalize.
 
    The square root of the high two parts is taken, by recursive
@@ -7192,14 +7149,14 @@ correct or 1 too big.  r is negative in the latter case, so
        r = r + 2*s - 1
        s = s - 1
 
-   The algorithm is expressed in a divide and conquer form, but as
-noted in the paper it can also be viewed as a discrete variant of
-Newton's method, or as a variation on the schoolboy method (no longer
-taught) for square roots two digits at a time.
+   The algorithm is expressed in a divide and conquer form, but as noted
+in the paper it can also be viewed as a discrete variant of Newton's
+method, or as a variation on the schoolboy method (no longer taught) for
+square roots two digits at a time.
 
    If the remainder r is not required then usually only a few high limbs
-of r and u need to be calculated to determine whether an adjustment to
-s is required.  This optimization is not currently implemented.
+of r and u need to be calculated to determine whether an adjustment to s
+is required.  This optimization is not currently implemented.
 
    In the Karatsuba multiplication range this algorithm is
 O(1.5*M(N/2)), where M(n) is the time to multiply two numbers of n
@@ -7208,8 +7165,8 @@ O(6*M(N/2)).  In practice a factor of about 1.5 to 1.8 is found in the
 Karatsuba and Toom-3 ranges, growing to 2 or 3 in the FFT range.
 
    The algorithm does all its calculations in integers and the resulting
-`mpn_sqrtrem' is used for both `mpz_sqrt' and `mpf_sqrt'.  The extended
-precision given by `mpf_sqrt_ui' is obtained by padding with zero limbs.
+'mpn_sqrtrem' is used for both 'mpz_sqrt' and 'mpf_sqrt'.  The extended
+precision given by 'mpf_sqrt_ui' is obtained by padding with zero limbs.
 
 
 File: gmp.info,  Node: Nth Root Algorithm,  Next: Perfect Square Algorithm,  Prev: Square Root Algorithm,  Up: Root Extraction Algorithms
@@ -7226,10 +7183,10 @@ iteration, where A is the input and n is the root to be taken.
 
    The initial approximation a[1] is generated bitwise by successively
 powering a trial root with or without new 1 bits, aiming to be just
-above the true root.  The iteration converges quadratically when
-started from a good approximation.  When n is large more initial bits
-are needed to get good convergence.  The current implementation is not
-particularly well optimized.
+above the true root.  The iteration converges quadratically when started
+from a good approximation.  When n is large more initial bits are needed
+to get good convergence.  The current implementation is not particularly
+well optimized.
 
 
 File: gmp.info,  Node: Perfect Square Algorithm,  Next: Perfect Power Algorithm,  Prev: Nth Root Algorithm,  Up: Root Extraction Algorithms
@@ -7240,37 +7197,37 @@ File: gmp.info,  Node: Perfect Square Algorithm,  Next: Perfect Power Algorithm,
 A significant fraction of non-squares can be quickly identified by
 checking whether the input is a quadratic residue modulo small integers.
 
-   `mpz_perfect_square_p' first tests the input mod 256, which means
-just examining the low byte.  Only 44 different values occur for
-squares mod 256, so 82.8% of inputs can be immediately identified as
+   'mpz_perfect_square_p' first tests the input mod 256, which means
+just examining the low byte.  Only 44 different values occur for squares
+mod 256, so 82.8% of inputs can be immediately identified as
 non-squares.
 
-   On a 32-bit system similar tests are done mod 9, 5, 7, 13 and 17,
-for a total 99.25% of inputs identified as non-squares.  On a 64-bit
-system 97 is tested too, for a total 99.62%.
+   On a 32-bit system similar tests are done mod 9, 5, 7, 13 and 17, for
+a total 99.25% of inputs identified as non-squares.  On a 64-bit system
+97 is tested too, for a total 99.62%.
 
    These moduli are chosen because they're factors of 2^24-1 (or 2^48-1
 for 64-bits), and such a remainder can be quickly taken just using
-additions (see `mpn_mod_34lsub1').
+additions (see 'mpn_mod_34lsub1').
 
-   When nails are in use moduli are instead selected by the `gen-psqr.c'
-program and applied with an `mpn_mod_1'.  The same 2^24-1 or 2^48-1
+   When nails are in use moduli are instead selected by the 'gen-psqr.c'
+program and applied with an 'mpn_mod_1'.  The same 2^24-1 or 2^48-1
 could be done with nails using some extra bit shifts, but this is not
 currently implemented.
 
-   In any case each modulus is applied to the `mpn_mod_34lsub1' or
-`mpn_mod_1' remainder and a table lookup identifies non-squares.  By
-using a "modexact" style calculation, and suitably permuted tables,
-just one multiply each is required, see the code for details.  Moduli
-are also combined to save operations, so long as the lookup tables
-don't become too big.  `gen-psqr.c' does all the pre-calculations.
+   In any case each modulus is applied to the 'mpn_mod_34lsub1' or
+'mpn_mod_1' remainder and a table lookup identifies non-squares.  By
+using a "modexact" style calculation, and suitably permuted tables, just
+one multiply each is required, see the code for details.  Moduli are
+also combined to save operations, so long as the lookup tables don't
+become too big.  'gen-psqr.c' does all the pre-calculations.
 
    A square root must still be taken for any value that passes these
 tests, to verify it's really a square and not one of the small fraction
 of non-squares that get through (ie. a pseudo-square to all the tested
 bases).
 
-   Clearly more residue tests could be done, `mpz_perfect_square_p' only
+   Clearly more residue tests could be done, 'mpz_perfect_square_p' only
 uses a compact and efficient set.  Big inputs would probably benefit
 from more residue testing, small inputs might be better off with less.
 The assumed distribution of squares versus non-squares in the input
@@ -7283,7 +7240,7 @@ File: gmp.info,  Node: Perfect Power Algorithm,  Prev: Perfect Square Algorithm,
 --------------------
 
 Detecting perfect powers is required by some factorization algorithms.
-Currently `mpz_perfect_power_p' is implemented using repeated Nth root
+Currently 'mpz_perfect_power_p' is implemented using repeated Nth root
 extractions, though naturally only prime roots need to be considered.
 (*Note Nth Root Algorithm::.)
 
@@ -7313,11 +7270,11 @@ File: gmp.info,  Node: Binary to Radix,  Next: Radix to Binary,  Prev: Radix Con
 16.6.1 Binary to Radix
 ----------------------
 
-Conversions from binary to a power-of-2 radix use a simple and fast
-O(N) bit extraction algorithm.
+Conversions from binary to a power-of-2 radix use a simple and fast O(N)
+bit extraction algorithm.
 
    Conversions from binary to other radices use one of two algorithms.
-Sizes below `GET_STR_PRECOMPUTE_THRESHOLD' use a basic O(N^2) method.
+Sizes below 'GET_STR_PRECOMPUTE_THRESHOLD' use a basic O(N^2) method.
 Repeated divisions by b^n are made, where b is the radix and n is the
 biggest power that fits in a limb.  But instead of simply using the
 remainder r from such divisions, an extra divide step is done to give a
@@ -7326,42 +7283,42 @@ extracted using multiplications by b rather than divisions.  Special
 case code is provided for decimal, allowing multiplications by 10 to
 optimize to shifts and adds.
 
-   Above `GET_STR_PRECOMPUTE_THRESHOLD' a sub-quadratic algorithm is
+   Above 'GET_STR_PRECOMPUTE_THRESHOLD' a sub-quadratic algorithm is
 used.  For an input t, powers b^(n*2^i) of the radix are calculated,
 until a power between t and sqrt(t) is reached.  t is then divided by
 that largest power, giving a quotient which is the digits above that
 power, and a remainder which is those below.  These two parts are in
-turn divided by the second highest power, and so on recursively.  When
-a piece has been divided down to less than `GET_STR_DC_THRESHOLD'
-limbs, the basecase algorithm described above is used.
+turn divided by the second highest power, and so on recursively.  When a
+piece has been divided down to less than 'GET_STR_DC_THRESHOLD' limbs,
+the basecase algorithm described above is used.
 
-   The advantage of this algorithm is that big divisions can make use
-of the sub-quadratic divide and conquer division (*note Divide and
-Conquer Division::), and big divisions tend to have less overheads than
-lots of separate single limb divisions anyway.  But in any case the
-cost of calculating the powers b^(n*2^i) must first be overcome.
+   The advantage of this algorithm is that big divisions can make use of
+the sub-quadratic divide and conquer division (*note Divide and Conquer
+Division::), and big divisions tend to have less overheads than lots of
+separate single limb divisions anyway.  But in any case the cost of
+calculating the powers b^(n*2^i) must first be overcome.
 
-   `GET_STR_PRECOMPUTE_THRESHOLD' and `GET_STR_DC_THRESHOLD' represent
+   'GET_STR_PRECOMPUTE_THRESHOLD' and 'GET_STR_DC_THRESHOLD' represent
 the same basic thing, the point where it becomes worth doing a big
-division to cut the input in half.  `GET_STR_PRECOMPUTE_THRESHOLD'
+division to cut the input in half.  'GET_STR_PRECOMPUTE_THRESHOLD'
 includes the cost of calculating the radix power required, whereas
-`GET_STR_DC_THRESHOLD' assumes that's already available, which is the
+'GET_STR_DC_THRESHOLD' assumes that's already available, which is the
 case when recursing.
 
    Since the base case produces digits from least to most significant
 but they want to be stored from most to least, it's necessary to
 calculate in advance how many digits there will be, or at least be sure
 not to underestimate that.  For GMP the number of input bits is
-multiplied by `chars_per_bit_exactly' from `mp_bases', rounding up.
-The result is either correct or one too big.
+multiplied by 'chars_per_bit_exactly' from 'mp_bases', rounding up.  The
+result is either correct or one too big.
 
    Examining some of the high bits of the input could increase the
 chance of getting the exact number of digits, but an exact result every
 time would not be practical, since in general the difference between
 numbers 100... and 99... is only in the last few bits and the work to
-identify 99...  might well be almost as much as a full conversion.
+identify 99... might well be almost as much as a full conversion.
 
-   `mpf_get_str' doesn't currently use the algorithm described here, it
+   'mpf_get_str' doesn't currently use the algorithm described here, it
 multiplies or divides by a power of b to move the radix point to the
 just above the highest non-zero digit (or at worst one above that
 location), then multiplies by b^n to bring out digits.  This is O(N^2)
@@ -7395,37 +7352,36 @@ algorithms used before GMP 4.3.*
 O(N) bitwise concatenation algorithm.
 
    Conversions from other radices use one of two algorithms.  Sizes
-below `SET_STR_PRECOMPUTE_THRESHOLD' use a basic O(N^2) method.  Groups
+below 'SET_STR_PRECOMPUTE_THRESHOLD' use a basic O(N^2) method.  Groups
 of n digits are converted to limbs, where n is the biggest power of the
 base b which will fit in a limb, then those groups are accumulated into
-the result by multiplying by b^n and adding.  This saves
-multi-precision operations, as per Knuth section 4.4 part E (*note
-References::).  Some special case code is provided for decimal, giving
-the compiler a chance to optimize multiplications by 10.
+the result by multiplying by b^n and adding.  This saves multi-precision
+operations, as per Knuth section 4.4 part E (*note References::).  Some
+special case code is provided for decimal, giving the compiler a chance
+to optimize multiplications by 10.
 
-   Above `SET_STR_PRECOMPUTE_THRESHOLD' a sub-quadratic algorithm is
+   Above 'SET_STR_PRECOMPUTE_THRESHOLD' a sub-quadratic algorithm is
 used.  First groups of n digits are converted into limbs.  Then adjacent
 limbs are combined into limb pairs with x*b^n+y, where x and y are the
 limbs.  Adjacent limb pairs are combined into quads similarly with
-x*b^(2n)+y.  This continues until a single block remains, that being
-the result.
+x*b^(2n)+y.  This continues until a single block remains, that being the
+result.
 
    The advantage of this method is that the multiplications for each x
 are big blocks, allowing Karatsuba and higher algorithms to be used.
 But the cost of calculating the powers b^(n*2^i) must be overcome.
-`SET_STR_PRECOMPUTE_THRESHOLD' usually ends up quite big, around 5000
+'SET_STR_PRECOMPUTE_THRESHOLD' usually ends up quite big, around 5000
 digits, and on some processors much bigger still.
 
-   `SET_STR_PRECOMPUTE_THRESHOLD' is based on the input digits (and
+   'SET_STR_PRECOMPUTE_THRESHOLD' is based on the input digits (and
 tuned for decimal), though it might be better based on a limb count, so
 as to be independent of the base.  But that sort of count isn't used by
 the base case and so would need some sort of initial calculation or
 estimate.
 
-   The main reason `SET_STR_PRECOMPUTE_THRESHOLD' is so much bigger
-than the corresponding `GET_STR_PRECOMPUTE_THRESHOLD' is that
-`mpn_mul_1' is much faster than `mpn_divrem_1' (often by a factor of 5,
-or more).
+   The main reason 'SET_STR_PRECOMPUTE_THRESHOLD' is so much bigger than
+the corresponding 'GET_STR_PRECOMPUTE_THRESHOLD' is that 'mpn_mul_1' is
+much faster than 'mpn_divrem_1' (often by a factor of 5, or more).
 
 
 File: gmp.info,  Node: Other Algorithms,  Next: Assembly Coding,  Prev: Radix Conversion Algorithms,  Up: Algorithms
@@ -7448,7 +7404,7 @@ File: gmp.info,  Node: Prime Testing Algorithm,  Next: Factorial Algorithm,  Pre
 16.7.1 Prime Testing
 --------------------
 
-The primality testing in `mpz_probab_prime_p' (*note Number Theoretic
+The primality testing in 'mpz_probab_prime_p' (*note Number Theoretic
 Functions::) first does some trial division by small factors and then
 uses the Miller-Rabin probabilistic primality testing algorithm, as
 described in Knuth section 4.5.4 algorithm P (*note References::).
@@ -7459,10 +7415,10 @@ algorithm selects a random base x and tests whether x^q mod n is 1 or
 prime, if not then n is definitely composite.
 
    Any prime n will pass the test, but some composites do too.  Such
-composites are known as strong pseudoprimes to base x.  No n is a
-strong pseudoprime to more than 1/4 of all bases (see Knuth exercise
-22), hence with x chosen at random there's no more than a 1/4 chance a
-"probable prime" will in fact be composite.
+composites are known as strong pseudoprimes to base x.  No n is a strong
+pseudoprime to more than 1/4 of all bases (see Knuth exercise 22), hence
+with x chosen at random there's no more than a 1/4 chance a "probable
+prime" will in fact be composite.
 
    In fact strong pseudoprimes are quite rare, making the test much more
 powerful than this analysis would suggest, but 1/4 is all that's proven
@@ -7474,19 +7430,19 @@ File: gmp.info,  Node: Factorial Algorithm,  Next: Binomial Coefficients Algorit
 16.7.2 Factorial
 ----------------
 
-Factorials are calculated by a combination of removal of twos,
-powering, and binary splitting.  The procedure can be best illustrated
-with an example,
+Factorials are calculated by a combination of removal of twos, powering,
+and binary splitting.  The procedure can be best illustrated with an
+example,
 
      23! = 1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23
 
 has factors of two removed,
 
-     23! = 2^19.1.1.3.1.5.3.7.1.9.5.11.3.13.7.15.1.17.9.19.5.21.11.23
+     23! = 2^{19}.1.1.3.1.5.3.7.1.9.5.11.3.13.7.15.1.17.9.19.5.21.11.23
 
 and the resulting terms collected up according to their multiplicity,
 
-     23! = 2^19.(3.5)^3.(7.9.11)^2.(13.15.17.19.21.23)
+     23! = 2^{19}.(3.5)^3.(7.9.11)^2.(13.15.17.19.21.23)
 
    Each sequence such as 13.15.17.19.21.23 is evaluated by splitting
 into every second term, as for instance (13.17.21).(15.19.23), and the
@@ -7495,14 +7451,13 @@ some bit twiddling.
 
    Such splitting is more efficient than repeated Nx1 multiplies since
 it forms big multiplies, allowing Karatsuba and higher algorithms to be
-used.  And even below the Karatsuba threshold a big block of work can
-be more efficient for the basecase algorithm.
+used.  And even below the Karatsuba threshold a big block of work can be
+more efficient for the basecase algorithm.
 
    Splitting into subsequences of every second term keeps the resulting
 products more nearly equal in size than would the simpler approach of
-say taking the first half and second half of the sequence.  Nearly
-equal products are more efficient for the current multiply
-implementation.
+say taking the first half and second half of the sequence.  Nearly equal
+products are more efficient for the current multiply implementation.
 
 
 File: gmp.info,  Node: Binomial Coefficients Algorithm,  Next: Fibonacci Numbers Algorithm,  Prev: Factorial Algorithm,  Up: Other Algorithms
@@ -7521,9 +7476,9 @@ product simply from i=2 to i=k.
    It's easy to show that each denominator i will divide the product so
 far, so the exact division algorithm is used (*note Exact Division::).
 
-   The numerators n-k+i and denominators i are first accumulated into
-as many fit a limb, to save multi-precision operations, though for
-`mpz_bin_ui' this applies only to the divisors, since n is an `mpz_t'
+   The numerators n-k+i and denominators i are first accumulated into as
+many fit a limb, to save multi-precision operations, though for
+'mpz_bin_ui' this applies only to the divisors, since n is an 'mpz_t'
 and n-k+i in general won't fit in a limb at all.
 
 
@@ -7532,12 +7487,12 @@ File: gmp.info,  Node: Fibonacci Numbers Algorithm,  Next: Lucas Numbers Algorit
 16.7.4 Fibonacci Numbers
 ------------------------
 
-The Fibonacci functions `mpz_fib_ui' and `mpz_fib2_ui' are designed for
+The Fibonacci functions 'mpz_fib_ui' and 'mpz_fib2_ui' are designed for
 calculating isolated F[n] or F[n],F[n-1] values efficiently.
 
-   For small n, a table of single limb values in `__gmp_fib_table' is
-used.  On a 32-bit limb this goes up to F[47], or on a 64-bit limb up
-to F[93].  For convenience the table starts at F[-1].
+   For small n, a table of single limb values in '__gmp_fib_table' is
+used.  On a 32-bit limb this goes up to F[47], or on a 64-bit limb up to
+F[93].  For convenience the table starts at F[-1].
 
    Beyond the table, values are generated with a binary powering
 algorithm, calculating a pair F[n] and F[n-1] working from high to low
@@ -7560,13 +7515,13 @@ be faster for only about 10 or 20 values of n, and including a block of
 code for just those doesn't seem worthwhile.  If they really mattered
 it'd be better to extend the data table.
 
-   Using a table avoids lots of calculations on small numbers, and
-makes small n go fast.  A bigger table would make more small n go fast,
-it's just a question of balancing size against desired speed.  For GMP
-the code is kept compact, with the emphasis primarily on a good
-powering algorithm.
+   Using a table avoids lots of calculations on small numbers, and makes
+small n go fast.  A bigger table would make more small n go fast, it's
+just a question of balancing size against desired speed.  For GMP the
+code is kept compact, with the emphasis primarily on a good powering
+algorithm.
 
-   `mpz_fib2_ui' returns both F[n] and F[n-1], but `mpz_fib_ui' is only
+   'mpz_fib2_ui' returns both F[n] and F[n-1], but 'mpz_fib_ui' is only
 interested in F[n].  In this case the last step of the algorithm can
 become one multiply instead of two squares.  One of the following two
 formulas is used, according as n is odd or even.
@@ -7579,7 +7534,7 @@ formulas is used, according as n is odd or even.
 For interest, the 2*(-1)^k term both here and above can be applied just
 to the low limb of the calculation, without a carry or borrow into
 further limbs, which saves some code size.  See comments with
-`mpz_fib_ui' and the internal `mpn_fib2_ui' for how this is done.
+'mpz_fib_ui' and the internal 'mpn_fib2_ui' for how this is done.
 
 
 File: gmp.info,  Node: Lucas Numbers Algorithm,  Next: Random Number Algorithms,  Prev: Fibonacci Numbers Algorithm,  Up: Other Algorithms
@@ -7587,20 +7542,20 @@ File: gmp.info,  Node: Lucas Numbers Algorithm,  Next: Random Number Algorithms,
 16.7.5 Lucas Numbers
 --------------------
 
-`mpz_lucnum2_ui' derives a pair of Lucas numbers from a pair of
+'mpz_lucnum2_ui' derives a pair of Lucas numbers from a pair of
 Fibonacci numbers with the following simple formulas.
 
      L[k]   =   F[k] + 2*F[k-1]
      L[k-1] = 2*F[k] -   F[k-1]
 
-   `mpz_lucnum_ui' is only interested in L[n], and some work can be
+   'mpz_lucnum_ui' is only interested in L[n], and some work can be
 saved.  Trailing zero bits on n can be handled with a single square
 each.
 
      L[2k] = L[k]^2 - 2*(-1)^k
 
    And the lowest 1 bit can be handled with one multiply of a pair of
-Fibonacci numbers, similar to what `mpz_fib_ui' does.
+Fibonacci numbers, similar to what 'mpz_fib_ui' does.
 
      L[2k+1] = 5*F[k-1]*(2*F[k]+F[k-1]) - 4*(-1)^k
 
@@ -7610,21 +7565,21 @@ File: gmp.info,  Node: Random Number Algorithms,  Prev: Lucas Numbers Algorithm,
 16.7.6 Random Numbers
 ---------------------
 
-For the `urandomb' functions, random numbers are generated simply by
+For the 'urandomb' functions, random numbers are generated simply by
 concatenating bits produced by the generator.  As long as the generator
 has good randomness properties this will produce well-distributed N bit
 numbers.
 
-   For the `urandomm' functions, random numbers in a range 0<=R<N are
+   For the 'urandomm' functions, random numbers in a range 0<=R<N are
 generated by taking values R of ceil(log2(N)) bits each until one
-satisfies R<N.  This will normally require only one or two attempts,
-but the attempts are limited in case the generator is somehow
-degenerate and produces only 1 bits or similar.
+satisfies R<N. This will normally require only one or two attempts, but
+the attempts are limited in case the generator is somehow degenerate and
+produces only 1 bits or similar.
 
    The Mersenne Twister generator is by Matsumoto and Nishimura (*note
 References::).  It has a non-repeating period of 2^19937-1, which is a
-Mersenne prime, hence the name of the generator.  The state is 624
-words of 32-bits each, which is iterated with one XOR and shift for each
+Mersenne prime, hence the name of the generator.  The state is 624 words
+of 32-bits each, which is iterated with one XOR and shift for each
 32-bit word generated, making the algorithm very fast.  Randomness
 properties are also very good and this is the default algorithm used by
 GMP.
@@ -7632,21 +7587,20 @@ GMP.
    Linear congruential generators are described in many text books, for
 instance Knuth volume 2 (*note References::).  With a modulus M and
 parameters A and C, a integer state S is iterated by the formula S <-
-A*S+C mod M.  At each step the new state is a linear function of the
+A*S+C mod M. At each step the new state is a linear function of the
 previous, mod M, hence the name of the generator.
 
    In GMP only moduli of the form 2^N are supported, and the current
 implementation is not as well optimized as it could be.  Overheads are
-significant when N is small, and when N is large clearly the multiply
-at each step will become slow.  This is not a big concern, since the
+significant when N is small, and when N is large clearly the multiply at
+each step will become slow.  This is not a big concern, since the
 Mersenne Twister generator is better in every respect and is therefore
 recommended for all normal applications.
 
    For both generators the current state can be deduced by observing
 enough output and applying some linear algebra (over GF(2) in the case
-of the Mersenne Twister).  This generally means raw output is
-unsuitable for cryptographic applications without further hashing or
-the like.
+of the Mersenne Twister).  This generally means raw output is unsuitable
+for cryptographic applications without further hashing or the like.
 
 
 File: gmp.info,  Node: Assembly Coding,  Prev: Other Algorithms,  Up: Algorithms
@@ -7654,14 +7608,14 @@ File: gmp.info,  Node: Assembly Coding,  Prev: Other Algorithms,  Up: Algorithms
 16.8 Assembly Coding
 ====================
 
-The assembly subroutines in GMP are the most significant source of
-speed at small to moderate sizes.  At larger sizes algorithm selection
-becomes more important, but of course speedups in low level routines
-will still speed up everything proportionally.
+The assembly subroutines in GMP are the most significant source of speed
+at small to moderate sizes.  At larger sizes algorithm selection becomes
+more important, but of course speedups in low level routines will still
+speed up everything proportionally.
 
    Carry handling and widening multiplies that are important for GMP
-can't be easily expressed in C.  GCC `asm' blocks help a lot and are
-provided in `longlong.h', but hand coding low level routines invariably
+can't be easily expressed in C.  GCC 'asm' blocks help a lot and are
+provided in 'longlong.h', but hand coding low level routines invariably
 offers a speedup over generic C by a factor of anything from 2 to 10.
 
 * Menu:
@@ -7683,21 +7637,21 @@ File: gmp.info,  Node: Assembly Code Organisation,  Next: Assembly Basics,  Prev
 16.8.1 Code Organisation
 ------------------------
 
-The various `mpn' subdirectories contain machine-dependent code, written
-in C or assembly.  The `mpn/generic' subdirectory contains default code,
+The various 'mpn' subdirectories contain machine-dependent code, written
+in C or assembly.  The 'mpn/generic' subdirectory contains default code,
 used when there's no machine-specific version of a particular file.
 
-   Each `mpn' subdirectory is for an ISA family.  Generally 32-bit and
+   Each 'mpn' subdirectory is for an ISA family.  Generally 32-bit and
 64-bit variants in a family cannot share code and have separate
 directories.  Within a family further subdirectories may exist for CPU
 variants.
 
-   In each directory a `nails' subdirectory may exist, holding code with
-nails support for that CPU variant.  A `NAILS_SUPPORT' directive in each
+   In each directory a 'nails' subdirectory may exist, holding code with
+nails support for that CPU variant.  A 'NAILS_SUPPORT' directive in each
 file indicates the nails values the code handles.  Nails code only
 exists where it's faster, or promises to be faster, than plain code.
-There's no effort put into nails if they're not going to enhance a
-given CPU.
+There's no effort put into nails if they're not going to enhance a given
+CPU.
 
 
 File: gmp.info,  Node: Assembly Basics,  Next: Assembly Carry Propagation,  Prev: Assembly Code Organisation,  Up: Assembly Coding
@@ -7705,20 +7659,20 @@ File: gmp.info,  Node: Assembly Basics,  Next: Assembly Carry Propagation,  Prev
 16.8.2 Assembly Basics
 ----------------------
 
-`mpn_addmul_1' and `mpn_submul_1' are the most important routines for
+'mpn_addmul_1' and 'mpn_submul_1' are the most important routines for
 overall GMP performance.  All multiplications and divisions come down to
-repeated calls to these.  `mpn_add_n', `mpn_sub_n', `mpn_lshift' and
-`mpn_rshift' are next most important.
+repeated calls to these.  'mpn_add_n', 'mpn_sub_n', 'mpn_lshift' and
+'mpn_rshift' are next most important.
 
    On some CPUs assembly versions of the internal functions
-`mpn_mul_basecase' and `mpn_sqr_basecase' give significant speedups,
+'mpn_mul_basecase' and 'mpn_sqr_basecase' give significant speedups,
 mainly through avoiding function call overheads.  They can also
 potentially make better use of a wide superscalar processor, as can
-bigger primitives like `mpn_addmul_2' or `mpn_addmul_4'.
+bigger primitives like 'mpn_addmul_2' or 'mpn_addmul_4'.
 
    The restrictions on overlaps between sources and destinations (*note
 Low-level Functions::) are designed to facilitate a variety of
-implementations.  For example, knowing `mpn_add_n' won't have partly
+implementations.  For example, knowing 'mpn_add_n' won't have partly
 overlapping sources and destination means reading can be done far ahead
 of writing on superscalar processors, and loops can be vectorized on a
 vector processor, depending on the carry handling.
@@ -7730,35 +7684,33 @@ File: gmp.info,  Node: Assembly Carry Propagation,  Next: Assembly Cache Handlin
 ------------------------
 
 The problem that presents most challenges in GMP is propagating carries
-from one limb to the next.  In functions like `mpn_addmul_1' and
-`mpn_add_n', carries are the only dependencies between limb operations.
+from one limb to the next.  In functions like 'mpn_addmul_1' and
+'mpn_add_n', carries are the only dependencies between limb operations.
 
-   On processors with carry flags, a straightforward CISC style `adc' is
-generally best.  AMD K6 `mpn_addmul_1' however is an example of an
+   On processors with carry flags, a straightforward CISC style 'adc' is
+generally best.  AMD K6 'mpn_addmul_1' however is an example of an
 unusual set of circumstances where a branch works out better.
 
-   On RISC processors generally an add and compare for overflow is
-used.  This sort of thing can be seen in `mpn/generic/aors_n.c'.  Some
-carry propagation schemes require 4 instructions, meaning at least 4
-cycles per limb, but other schemes may use just 1 or 2.  On wide
-superscalar processors performance may be completely determined by the
-number of dependent instructions between carry-in and carry-out for
-each limb.
+   On RISC processors generally an add and compare for overflow is used.
+This sort of thing can be seen in 'mpn/generic/aors_n.c'.  Some carry
+propagation schemes require 4 instructions, meaning at least 4 cycles
+per limb, but other schemes may use just 1 or 2.  On wide superscalar
+processors performance may be completely determined by the number of
+dependent instructions between carry-in and carry-out for each limb.
 
    On vector processors good use can be made of the fact that a carry
 bit only very rarely propagates more than one limb.  When adding a
 single bit to a limb, there's only a carry out if that limb was
-`0xFF...FF' which on random data will be only 1 in 2^mp_bits_per_limb.
-`mpn/cray/add_n.c' is an example of this, it adds all limbs in
-parallel, adds one set of carry bits in parallel and then only rarely
-needs to fall through to a loop propagating further carries.
+'0xFF...FF' which on random data will be only 1 in 2^mp_bits_per_limb.
+'mpn/cray/add_n.c' is an example of this, it adds all limbs in parallel,
+adds one set of carry bits in parallel and then only rarely needs to
+fall through to a loop propagating further carries.
 
-   On the x86s, GCC (as of version 2.95.2) doesn't generate
-particularly good code for the RISC style idioms that are necessary to
-handle carry bits in C.  Often conditional jumps are generated where
-`adc' or `sbb' forms would be better.  And so unfortunately almost any
-loop involving carry bits needs to be coded in assembly for best
-results.
+   On the x86s, GCC (as of version 2.95.2) doesn't generate particularly
+good code for the RISC style idioms that are necessary to handle carry
+bits in C.  Often conditional jumps are generated where 'adc' or 'sbb'
+forms would be better.  And so unfortunately almost any loop involving
+carry bits needs to be coded in assembly for best results.
 
 
 File: gmp.info,  Node: Assembly Cache Handling,  Next: Assembly Functional Units,  Prev: Assembly Carry Propagation,  Up: Assembly Coding
@@ -7769,19 +7721,19 @@ File: gmp.info,  Node: Assembly Cache Handling,  Next: Assembly Functional Units
 GMP aims to perform well both on operands that fit entirely in L1 cache
 and those which don't.
 
-   Basic routines like `mpn_add_n' or `mpn_lshift' are often used on
+   Basic routines like 'mpn_add_n' or 'mpn_lshift' are often used on
 large operands, so L2 and main memory performance is important for them.
-`mpn_mul_1' and `mpn_addmul_1' are mostly used for multiply and square
+'mpn_mul_1' and 'mpn_addmul_1' are mostly used for multiply and square
 basecases, so L1 performance matters most for them, unless assembly
-versions of `mpn_mul_basecase' and `mpn_sqr_basecase' exist, in which
+versions of 'mpn_mul_basecase' and 'mpn_sqr_basecase' exist, in which
 case the remaining uses are mostly for larger operands.
 
    For L2 or main memory operands, memory access times will almost
 certainly be more than the calculation time.  The aim therefore is to
 maximize memory throughput, by starting a load of the next cache line
-while processing the contents of the previous one.  Clearly this is
-only possible if the chip has a lock-up free cache or some sort of
-prefetch instruction.  Most current chips have both these features.
+while processing the contents of the previous one.  Clearly this is only
+possible if the chip has a lock-up free cache or some sort of prefetch
+instruction.  Most current chips have both these features.
 
    Prefetching sources combines well with loop unrolling, since a
 prefetch can be initiated once per unrolled loop (or more than once if
@@ -7790,16 +7742,16 @@ the loop covers more than one cache line).
    On CPUs without write-allocate caches, prefetching destinations will
 ensure individual stores don't go further down the cache hierarchy,
 limiting bandwidth.  Of course for calculations which are slow anyway,
-like `mpn_divrem_1', write-throughs might be fine.
+like 'mpn_divrem_1', write-throughs might be fine.
 
    The distance ahead to prefetch will be determined by memory latency
 versus throughput.  The aim of course is to have data arriving
 continuously, at peak throughput.  Some CPUs have limits on the number
 of fetches or prefetches in progress.
 
-   If a special prefetch instruction doesn't exist then a plain load
-can be used, but in that case care must be taken not to attempt to read
-past the end of an operand, since that might produce a segmentation
+   If a special prefetch instruction doesn't exist then a plain load can
+be used, but in that case care must be taken not to attempt to read past
+the end of an operand, since that might produce a segmentation
 violation.
 
    Some CPUs or systems have hardware that detects sequential memory
@@ -7820,18 +7772,18 @@ accommodate available resources.
    Loop control will generally require a counter and pointer updates,
 costing as much as 5 instructions, plus any delays a branch introduces.
 CPU addressing modes might reduce pointer updates, perhaps by allowing
-just one updating pointer and others expressed as offsets from it, or
-on CISC chips with all addressing done with the loop counter as a
-scaled index.
+just one updating pointer and others expressed as offsets from it, or on
+CISC chips with all addressing done with the loop counter as a scaled
+index.
 
    The final loop control cost can be amortised by processing several
 limbs in each iteration (*note Assembly Loop Unrolling::).  This at
 least ensures loop control isn't a big fraction the work done.
 
-   Memory throughput is always a limit.  If perhaps only one load or
-one store can be done per cycle then 3 cycles/limb will the top speed
-for "binary" operations like `mpn_add_n', and any code achieving that
-is optimal.
+   Memory throughput is always a limit.  If perhaps only one load or one
+store can be done per cycle then 3 cycles/limb will the top speed for
+"binary" operations like 'mpn_add_n', and any code achieving that is
+optimal.
 
    Integer resources can be freed up by having the loop counter in a
 float register, or by pressing the float units into use for some
@@ -7849,33 +7801,33 @@ File: gmp.info,  Node: Assembly Floating Point,  Next: Assembly SIMD Instruction
 ---------------------
 
 Floating point arithmetic is used in GMP for multiplications on CPUs
-with poor integer multipliers.  It's mostly useful for `mpn_mul_1',
-`mpn_addmul_1' and `mpn_submul_1' on 64-bit machines, and
-`mpn_mul_basecase' on both 32-bit and 64-bit machines.
+with poor integer multipliers.  It's mostly useful for 'mpn_mul_1',
+'mpn_addmul_1' and 'mpn_submul_1' on 64-bit machines, and
+'mpn_mul_basecase' on both 32-bit and 64-bit machines.
 
    With IEEE 53-bit double precision floats, integer multiplications
 producing up to 53 bits will give exact results.  Breaking a 64x64
-multiplication into eight 16x32->48 bit pieces is convenient.  With
-some care though six 21x32->53 bit products can be used, if one of the
-lower two 21-bit pieces also uses the sign bit.
+multiplication into eight 16x32->48 bit pieces is convenient.  With some
+care though six 21x32->53 bit products can be used, if one of the lower
+two 21-bit pieces also uses the sign bit.
 
-   For the `mpn_mul_1' family of functions on a 64-bit machine, the
-invariant single limb is split at the start, into 3 or 4 pieces.
-Inside the loop, the bignum operand is split into 32-bit pieces.  Fast
+   For the 'mpn_mul_1' family of functions on a 64-bit machine, the
+invariant single limb is split at the start, into 3 or 4 pieces.  Inside
+the loop, the bignum operand is split into 32-bit pieces.  Fast
 conversion of these unsigned 32-bit pieces to floating point is highly
 machine-dependent.  In some cases, reading the data into the integer
-unit, zero-extending to 64-bits, then transferring to the floating
-point unit back via memory is the only option.
+unit, zero-extending to 64-bits, then transferring to the floating point
+unit back via memory is the only option.
 
-   Converting partial products back to 64-bit limbs is usually best
-done as a signed conversion.  Since all values are smaller than 2^53,
-signed and unsigned are the same, but most processors lack unsigned
+   Converting partial products back to 64-bit limbs is usually best done
+as a signed conversion.  Since all values are smaller than 2^53, signed
+and unsigned are the same, but most processors lack unsigned
 conversions.
 
 
 
-   Here is a diagram showing 16x32 bit products for an `mpn_mul_1' or
-`mpn_addmul_1' with a 64-bit limb.  The single limb operand V is split
+   Here is a diagram showing 16x32 bit products for an 'mpn_mul_1' or
+'mpn_addmul_1' with a 64-bit limb.  The single limb operand V is split
 into four 16-bit parts.  The multi-limb operand U is split in the loop
 into two 32-bit parts.
 
@@ -7914,9 +7866,9 @@ into two 32-bit parts.
      | u32 x v48 |                        r80
      +-----------+
 
-   p32 and r32 can be summed using floating-point addition, and
-likewise p48 and r48.  p00 and p16 can be summed with r64 and r80 from
-the previous iteration.
+   p32 and r32 can be summed using floating-point addition, and likewise
+p48 and r48.  p00 and p16 can be summed with r64 and r80 from the
+previous iteration.
 
    For each loop then, four 49-bit quantities are transferred to the
 integer unit, aligned as follows,
@@ -7952,13 +7904,13 @@ for propagating the sort of carries that arise in GMP.
 
    SIMD multiplications of say four 16x16 bit multiplies only do as much
 work as one 32x32 from GMP's point of view, and need some shifts and
-adds besides.  But of course if say the SIMD form is fully pipelined
-and uses less instruction decoding then it may still be worthwhile.
+adds besides.  But of course if say the SIMD form is fully pipelined and
+uses less instruction decoding then it may still be worthwhile.
 
-   On the x86 chips, MMX has so far found a use in `mpn_rshift' and
-`mpn_lshift', and is used in a special case for 16-bit multipliers in
-the P55 `mpn_mul_1'.  SSE2 is used for Pentium 4 `mpn_mul_1',
-`mpn_addmul_1', and `mpn_submul_1'.
+   On the x86 chips, MMX has so far found a use in 'mpn_rshift' and
+'mpn_lshift', and is used in a special case for 16-bit multipliers in
+the P55 'mpn_mul_1'.  SSE2 is used for Pentium 4 'mpn_mul_1',
+'mpn_addmul_1', and 'mpn_submul_1'.
 
 
 File: gmp.info,  Node: Assembly Software Pipelining,  Next: Assembly Loop Unrolling,  Prev: Assembly SIMD Instructions,  Up: Assembly Coding
@@ -7968,8 +7920,8 @@ File: gmp.info,  Node: Assembly Software Pipelining,  Next: Assembly Loop Unroll
 
 Software pipelining consists of scheduling instructions around the
 branch point in a loop.  For example a loop might issue a load not for
-use in the present iteration but the next, thereby allowing extra
-cycles for the data to arrive from memory.
+use in the present iteration but the next, thereby allowing extra cycles
+for the data to arrive from memory.
 
    Naturally this is wanted only when doing things like loads or
 multiplies that take several cycles to complete, and only where a CPU
@@ -7980,10 +7932,10 @@ meantime.
 each stage and each loop iteration moves them along one stage.  This is
 like juggling.
 
-   If the latency of some instruction is greater than the loop time
-then it will be necessary to unroll, so one register has a result ready
-to use while another (or multiple others) are still in progress.
-(*note Assembly Loop Unrolling::).
+   If the latency of some instruction is greater than the loop time then
+it will be necessary to unroll, so one register has a result ready to
+use while another (or multiple others) are still in progress.  (*note
+Assembly Loop Unrolling::).
 
 
 File: gmp.info,  Node: Assembly Loop Unrolling,  Next: Assembly Writing Guide,  Prev: Assembly Software Pipelining,  Up: Assembly Coding
@@ -7995,32 +7947,32 @@ Loop unrolling consists of replicating code so that several limbs are
 processed in each loop.  At a minimum this reduces loop overheads by a
 corresponding factor, but it can also allow better register usage, for
 example alternately using one register combination and then another.
-Judicious use of `m4' macros can help avoid lots of duplication in the
+Judicious use of 'm4' macros can help avoid lots of duplication in the
 source code.
 
    Any amount of unrolling can be handled with a loop counter that's
 decremented by N each time, stopping when the remaining count is less
 than the further N the loop will process.  Or by subtracting N at the
-start, the termination condition becomes when the counter C is less
-than 0 (and the count of remaining limbs is C+N).
+start, the termination condition becomes when the counter C is less than
+0 (and the count of remaining limbs is C+N).
 
    Alternately for a power of 2 unroll the loop count and remainder can
-be established with a shift and mask.  This is convenient if also
-making a computed jump into the middle of a large loop.
+be established with a shift and mask.  This is convenient if also making
+a computed jump into the middle of a large loop.
 
    The limbs not a multiple of the unrolling can be handled in various
 ways, for example
 
    * A simple loop at the end (or the start) to process the excess.
-     Care will be wanted that it isn't too much slower than the
-     unrolled part.
+     Care will be wanted that it isn't too much slower than the unrolled
+     part.
 
    * A set of binary tests, for example after an 8-limb unrolling, test
      for 4 more limbs to process, then a further 2 more or not, and
      finally 1 more or not.  This will probably take more code space
      than a simple loop.
 
-   * A `switch' statement, providing separate code for each possible
+   * A 'switch' statement, providing separate code for each possible
      excess, for example an 8-limb unrolling would have separate code
      for 0 remaining, 1 remaining, etc, up to 7 remaining.  This might
      take a lot of code, but may be the best way to optimize all cases
@@ -8047,9 +7999,9 @@ Code it without unrolling or scheduling, to make sure it works.  On a
 greatly simplify later steps.
 
    Then note for each instruction the functional unit and/or issue port
-requirements.  If an instruction can use either of two units, like U0
-or U1 then make a category "U0/U1".  Count the total using each unit
-(or combined unit), and count all instructions.
+requirements.  If an instruction can use either of two units, like U0 or
+U1 then make a category "U0/U1".  Count the total using each unit (or
+combined unit), and count all instructions.
 
    Figure out from those counts the best possible loop time.  The goal
 will be to find a perfect schedule where instruction latencies are
@@ -8057,20 +8009,20 @@ completely hidden.  The total instruction count might be the limiting
 factor, or perhaps a particular functional unit.  It might be possible
 to tweak the instructions to help the limiting factor.
 
-   Suppose the loop time is N, then make N issue buckets, with the
-final loop branch at the end of the last.  Now fill the buckets with
-dummy instructions using the functional units desired.  Run this to
-make sure the intended speed is reached.
+   Suppose the loop time is N, then make N issue buckets, with the final
+loop branch at the end of the last.  Now fill the buckets with dummy
+instructions using the functional units desired.  Run this to make sure
+the intended speed is reached.
 
    Now replace the dummy instructions with the real instructions from
-the slow but correct loop you started with.  The first will typically
-be a load instruction.  Then the instruction using that value is placed
-in a bucket an appropriate distance down.  Run the loop again, to check
-it still runs at target speed.
+the slow but correct loop you started with.  The first will typically be
+a load instruction.  Then the instruction using that value is placed in
+a bucket an appropriate distance down.  Run the loop again, to check it
+still runs at target speed.
 
    Keep placing instructions, frequently measuring the loop.  After a
-few you will need to wrap around from the last bucket back to the top
-of the loop.  If you used the new-register for new-value strategy above
+few you will need to wrap around from the last bucket back to the top of
+the loop.  If you used the new-register for new-value strategy above
 then there will be no register conflicts.  If not then take care not to
 clobber something already in use.  Changing registers at this time is
 very error prone.
@@ -8086,8 +8038,8 @@ start and delete those instructions which don't have valid antecedents,
 and at the end replicate and delete those whose results are unwanted
 (including any further loads).
 
-   The loop will have a minimum number of limbs loaded and processed,
-so the feed-in code must test if the request size is smaller and skip
+   The loop will have a minimum number of limbs loaded and processed, so
+the feed-in code must test if the request size is smaller and skip
 either to a suitable part of the wind-down or to special code for small
 sizes.
 
@@ -8116,49 +8068,49 @@ File: gmp.info,  Node: Integer Internals,  Next: Rational Internals,  Prev: Inte
 17.1 Integer Internals
 ======================
 
-`mpz_t' variables represent integers using sign and magnitude, in space
+'mpz_t' variables represent integers using sign and magnitude, in space
 dynamically allocated and reallocated.  The fields are as follows.
 
-`_mp_size'
+'_mp_size'
      The number of limbs, or the negative of that when representing a
-     negative integer.  Zero is represented by `_mp_size' set to zero,
-     in which case the `_mp_d' data is unused.
+     negative integer.  Zero is represented by '_mp_size' set to zero,
+     in which case the '_mp_d' data is unused.
 
-`_mp_d'
+'_mp_d'
      A pointer to an array of limbs which is the magnitude.  These are
-     stored "little endian" as per the `mpn' functions, so `_mp_d[0]'
-     is the least significant limb and `_mp_d[ABS(_mp_size)-1]' is the
-     most significant.  Whenever `_mp_size' is non-zero, the most
-     significant limb is non-zero.
+     stored "little endian" as per the 'mpn' functions, so '_mp_d[0]' is
+     the least significant limb and '_mp_d[ABS(_mp_size)-1]' is the most
+     significant.  Whenever '_mp_size' is non-zero, the most significant
+     limb is non-zero.
 
      Currently there's always at least one limb allocated, so for
-     instance `mpz_set_ui' never needs to reallocate, and `mpz_get_ui'
-     can fetch `_mp_d[0]' unconditionally (though its value is then
-     only wanted if `_mp_size' is non-zero).
-
-`_mp_alloc'
-     `_mp_alloc' is the number of limbs currently allocated at `_mp_d',
-     and naturally `_mp_alloc >= ABS(_mp_size)'.  When an `mpz' routine
-     is about to (or might be about to) increase `_mp_size', it checks
-     `_mp_alloc' to see whether there's enough space, and reallocates
-     if not.  `MPZ_REALLOC' is generally used for this.
-
-   The various bitwise logical functions like `mpz_and' behave as if
+     instance 'mpz_set_ui' never needs to reallocate, and 'mpz_get_ui'
+     can fetch '_mp_d[0]' unconditionally (though its value is then only
+     wanted if '_mp_size' is non-zero).
+
+'_mp_alloc'
+     '_mp_alloc' is the number of limbs currently allocated at '_mp_d',
+     and naturally '_mp_alloc >= ABS(_mp_size)'.  When an 'mpz' routine
+     is about to (or might be about to) increase '_mp_size', it checks
+     '_mp_alloc' to see whether there's enough space, and reallocates if
+     not.  'MPZ_REALLOC' is generally used for this.
+
+   The various bitwise logical functions like 'mpz_and' behave as if
 negative values were twos complement.  But sign and magnitude is always
 used internally, and necessary adjustments are made during the
 calculations.  Sometimes this isn't pretty, but sign and magnitude are
 best for other routines.
 
-   Some internal temporary variables are setup with `MPZ_TMP_INIT' and
-these have `_mp_d' space obtained from `TMP_ALLOC' rather than the
-memory allocation functions.  Care is taken to ensure that these are
-big enough that no reallocation is necessary (since it would have
+   Some internal temporary variables are setup with 'MPZ_TMP_INIT' and
+these have '_mp_d' space obtained from 'TMP_ALLOC' rather than the
+memory allocation functions.  Care is taken to ensure that these are big
+enough that no reallocation is necessary (since it would have
 unpredictable consequences).
 
-   `_mp_size' and `_mp_alloc' are `int', although `mp_size_t' is
-usually a `long'.  This is done to make the fields just 32 bits on some
-64 bits systems, thereby saving a few bytes of data space but still
-providing plenty of range.
+   '_mp_size' and '_mp_alloc' are 'int', although 'mp_size_t' is usually
+a 'long'.  This is done to make the fields just 32 bits on some 64 bits
+systems, thereby saving a few bytes of data space but still providing
+plenty of range.
 
 
 File: gmp.info,  Node: Rational Internals,  Next: Float Internals,  Prev: Integer Internals,  Up: Internals
@@ -8166,26 +8118,26 @@ File: gmp.info,  Node: Rational Internals,  Next: Float Internals,  Prev: Intege
 17.2 Rational Internals
 =======================
 
-`mpq_t' variables represent rationals using an `mpz_t' numerator and
+'mpq_t' variables represent rationals using an 'mpz_t' numerator and
 denominator (*note Integer Internals::).
 
-   The canonical form adopted is denominator positive (and non-zero),
-no common factors between numerator and denominator, and zero uniquely
+   The canonical form adopted is denominator positive (and non-zero), no
+common factors between numerator and denominator, and zero uniquely
 represented as 0/1.
 
    It's believed that casting out common factors at each stage of a
 calculation is best in general.  A GCD is an O(N^2) operation so it's
-better to do a few small ones immediately than to delay and have to do
-a big one later.  Knowing the numerator and denominator have no common
-factors can be used for example in `mpq_mul' to make only two cross
-GCDs necessary, not four.
+better to do a few small ones immediately than to delay and have to do a
+big one later.  Knowing the numerator and denominator have no common
+factors can be used for example in 'mpq_mul' to make only two cross GCDs
+necessary, not four.
 
    This general approach to common factors is badly sub-optimal in the
 presence of simple factorizations or little prospect for cancellation,
 but GMP has no way to know when this will occur.  As per *note
-Efficiency::, that's left to applications.  The `mpq_t' framework might
-still suit, with `mpq_numref' and `mpq_denref' for direct access to the
-numerator and denominator, or of course `mpz_t' variables can be used
+Efficiency::, that's left to applications.  The 'mpq_t' framework might
+still suit, with 'mpq_numref' and 'mpq_denref' for direct access to the
+numerator and denominator, or of course 'mpz_t' variables can be used
 directly.
 
 
@@ -8197,7 +8149,7 @@ File: gmp.info,  Node: Float Internals,  Next: Raw Output Internals,  Prev: Rati
 Efficient calculation is the primary aim of GMP floats and the use of
 whole limbs and simple rounding facilitates this.
 
-   `mpf_t' floats have a variable precision mantissa and a single
+   'mpf_t' floats have a variable precision mantissa and a single
 machine word signed exponent.  The mantissa is represented using sign
 and magnitude.
 
@@ -8213,35 +8165,36 @@ and magnitude.
 
        <-------- _mp_size --------->
 
+
 The fields are as follows.
 
-`_mp_size'
+'_mp_size'
      The number of limbs currently in use, or the negative of that when
-     representing a negative value.  Zero is represented by `_mp_size'
-     and `_mp_exp' both set to zero, and in that case the `_mp_d' data
-     is unused.  (In the future `_mp_exp' might be undefined when
+     representing a negative value.  Zero is represented by '_mp_size'
+     and '_mp_exp' both set to zero, and in that case the '_mp_d' data
+     is unused.  (In the future '_mp_exp' might be undefined when
      representing zero.)
 
-`_mp_prec'
+'_mp_prec'
      The precision of the mantissa, in limbs.  In any calculation the
-     aim is to produce `_mp_prec' limbs of result (the most significant
+     aim is to produce '_mp_prec' limbs of result (the most significant
      being non-zero).
 
-`_mp_d'
+'_mp_d'
      A pointer to the array of limbs which is the absolute value of the
-     mantissa.  These are stored "little endian" as per the `mpn'
-     functions, so `_mp_d[0]' is the least significant limb and
-     `_mp_d[ABS(_mp_size)-1]' the most significant.
+     mantissa.  These are stored "little endian" as per the 'mpn'
+     functions, so '_mp_d[0]' is the least significant limb and
+     '_mp_d[ABS(_mp_size)-1]' the most significant.
 
      The most significant limb is always non-zero, but there are no
      other restrictions on its value, in particular the highest 1 bit
      can be anywhere within the limb.
 
-     `_mp_prec+1' limbs are allocated to `_mp_d', the extra limb being
+     '_mp_prec+1' limbs are allocated to '_mp_d', the extra limb being
      for convenience (see below).  There are no reallocations during a
-     calculation, only in a change of precision with `mpf_set_prec'.
+     calculation, only in a change of precision with 'mpf_set_prec'.
 
-`_mp_exp'
+'_mp_exp'
      The exponent, in limbs, determining the location of the implied
      radix point.  Zero means the radix point is just above the most
      significant limb.  Positive values mean a radix point offset
@@ -8252,11 +8205,11 @@ The fields are as follows.
      Naturally the exponent can be any value, it doesn't have to fall
      within the limbs as the diagram shows, it can be a long way above
      or a long way below.  Limbs other than those included in the
-     `{_mp_d,_mp_size}' data are treated as zero.
+     '{_mp_d,_mp_size}' data are treated as zero.
 
-   The `_mp_size' and `_mp_prec' fields are `int', although the
-`mp_size_t' type is usually a `long'.  The `_mp_exp' field is usually
-`long'.  This is done to make some fields just 32 bits on some 64 bits
+   The '_mp_size' and '_mp_prec' fields are 'int', although the
+'mp_size_t' type is usually a 'long'.  The '_mp_exp' field is usually
+'long'.  This is done to make some fields just 32 bits on some 64 bits
 systems, thereby saving a few bytes of data space but still providing
 plenty of precision and a very large range.
 
@@ -8264,92 +8217,89 @@ plenty of precision and a very large range.
 The following various points should be noted.
 
 Low Zeros
-     The least significant limbs `_mp_d[0]' etc can be zero, though
-     such low zeros can always be ignored.  Routines likely to produce
-     low zeros check and avoid them to save time in subsequent
-     calculations, but for most routines they're quite unlikely and
-     aren't checked.
+     The least significant limbs '_mp_d[0]' etc can be zero, though such
+     low zeros can always be ignored.  Routines likely to produce low
+     zeros check and avoid them to save time in subsequent calculations,
+     but for most routines they're quite unlikely and aren't checked.
 
 Mantissa Size Range
-     The `_mp_size' count of limbs in use can be less than `_mp_prec' if
+     The '_mp_size' count of limbs in use can be less than '_mp_prec' if
      the value can be represented in less.  This means low precision
-     values or small integers stored in a high precision `mpf_t' can
+     values or small integers stored in a high precision 'mpf_t' can
      still be operated on efficiently.
 
-     `_mp_size' can also be greater than `_mp_prec'.  Firstly a value is
-     allowed to use all of the `_mp_prec+1' limbs available at `_mp_d',
-     and secondly when `mpf_set_prec_raw' lowers `_mp_prec' it leaves
-     `_mp_size' unchanged and so the size can be arbitrarily bigger than
-     `_mp_prec'.
+     '_mp_size' can also be greater than '_mp_prec'.  Firstly a value is
+     allowed to use all of the '_mp_prec+1' limbs available at '_mp_d',
+     and secondly when 'mpf_set_prec_raw' lowers '_mp_prec' it leaves
+     '_mp_size' unchanged and so the size can be arbitrarily bigger than
+     '_mp_prec'.
 
 Rounding
-     All rounding is done on limb boundaries.  Calculating `_mp_prec'
+     All rounding is done on limb boundaries.  Calculating '_mp_prec'
      limbs with the high non-zero will ensure the application requested
      minimum precision is obtained.
 
-     The use of simple "trunc" rounding towards zero is efficient,
-     since there's no need to examine extra limbs and increment or
-     decrement.
+     The use of simple "trunc" rounding towards zero is efficient, since
+     there's no need to examine extra limbs and increment or decrement.
 
 Bit Shifts
      Since the exponent is in limbs, there are no bit shifts in basic
-     operations like `mpf_add' and `mpf_mul'.  When differing exponents
+     operations like 'mpf_add' and 'mpf_mul'.  When differing exponents
      are encountered all that's needed is to adjust pointers to line up
      the relevant limbs.
 
-     Of course `mpf_mul_2exp' and `mpf_div_2exp' will require bit
+     Of course 'mpf_mul_2exp' and 'mpf_div_2exp' will require bit
      shifts, but the choice is between an exponent in limbs which
      requires shifts there, or one in bits which requires them almost
      everywhere else.
 
-Use of `_mp_prec+1' Limbs
-     The extra limb on `_mp_d' (`_mp_prec+1' rather than just
-     `_mp_prec') helps when an `mpf' routine might get a carry from its
-     operation.  `mpf_add' for instance will do an `mpn_add' of
-     `_mp_prec' limbs.  If there's no carry then that's the result, but
+Use of '_mp_prec+1' Limbs
+     The extra limb on '_mp_d' ('_mp_prec+1' rather than just
+     '_mp_prec') helps when an 'mpf' routine might get a carry from its
+     operation.  'mpf_add' for instance will do an 'mpn_add' of
+     '_mp_prec' limbs.  If there's no carry then that's the result, but
      if there is a carry then it's stored in the extra limb of space and
-     `_mp_size' becomes `_mp_prec+1'.
+     '_mp_size' becomes '_mp_prec+1'.
 
-     Whenever `_mp_prec+1' limbs are held in a variable, the low limb
-     is not needed for the intended precision, only the `_mp_prec' high
+     Whenever '_mp_prec+1' limbs are held in a variable, the low limb is
+     not needed for the intended precision, only the '_mp_prec' high
      limbs.  But zeroing it out or moving the rest down is unnecessary.
      Subsequent routines reading the value will simply take the high
-     limbs they need, and this will be `_mp_prec' if their target has
+     limbs they need, and this will be '_mp_prec' if their target has
      that same precision.  This is no more than a pointer adjustment,
      and must be checked anyway since the destination precision can be
      different from the sources.
 
-     Copy functions like `mpf_set' will retain a full `_mp_prec+1' limbs
-     if available.  This ensures that a variable which has `_mp_size'
-     equal to `_mp_prec+1' will get its full exact value copied.
-     Strictly speaking this is unnecessary since only `_mp_prec' limbs
+     Copy functions like 'mpf_set' will retain a full '_mp_prec+1' limbs
+     if available.  This ensures that a variable which has '_mp_size'
+     equal to '_mp_prec+1' will get its full exact value copied.
+     Strictly speaking this is unnecessary since only '_mp_prec' limbs
      are needed for the application's requested precision, but it's
-     considered that an `mpf_set' from one variable into another of the
+     considered that an 'mpf_set' from one variable into another of the
      same precision ought to produce an exact copy.
 
 Application Precisions
-     `__GMPF_BITS_TO_PREC' converts an application requested precision
-     to an `_mp_prec'.  The value in bits is rounded up to a whole limb
+     '__GMPF_BITS_TO_PREC' converts an application requested precision
+     to an '_mp_prec'.  The value in bits is rounded up to a whole limb
      then an extra limb is added since the most significant limb of
-     `_mp_d' is only non-zero and therefore might contain only one bit.
+     '_mp_d' is only non-zero and therefore might contain only one bit.
 
-     `__GMPF_PREC_TO_BITS' does the reverse conversion, and removes the
-     extra limb from `_mp_prec' before converting to bits.  The net
-     effect of reading back with `mpf_get_prec' is simply the precision
-     rounded up to a multiple of `mp_bits_per_limb'.
+     '__GMPF_PREC_TO_BITS' does the reverse conversion, and removes the
+     extra limb from '_mp_prec' before converting to bits.  The net
+     effect of reading back with 'mpf_get_prec' is simply the precision
+     rounded up to a multiple of 'mp_bits_per_limb'.
 
      Note that the extra limb added here for the high only being
-     non-zero is in addition to the extra limb allocated to `_mp_d'.
-     For example with a 32-bit limb, an application request for 250
-     bits will be rounded up to 8 limbs, then an extra added for the
-     high being only non-zero, giving an `_mp_prec' of 9.  `_mp_d' then
-     gets 10 limbs allocated.  Reading back with `mpf_get_prec' will
-     take `_mp_prec' subtract 1 limb and multiply by 32, giving 256
-     bits.
+     non-zero is in addition to the extra limb allocated to '_mp_d'.
+     For example with a 32-bit limb, an application request for 250 bits
+     will be rounded up to 8 limbs, then an extra added for the high
+     being only non-zero, giving an '_mp_prec' of 9.  '_mp_d' then gets
+     10 limbs allocated.  Reading back with 'mpf_get_prec' will take
+     '_mp_prec' subtract 1 limb and multiply by 32, giving 256 bits.
 
      Strictly speaking, the fact the high limb has at least one bit
      means that a float with, say, 3 limbs of 32-bits each will be
-     holding at least 65 bits, but for the purposes of `mpf_t' it's
+     holding at least 65 bits, but for the purposes of 'mpf_t' it's
      considered simply to be 64 bits, a nice multiple of the limb size.
 
 
@@ -8358,29 +8308,29 @@ File: gmp.info,  Node: Raw Output Internals,  Next: C++ Interface Internals,  Pr
 17.4 Raw Output Internals
 =========================
 
-`mpz_out_raw' uses the following format.
+'mpz_out_raw' uses the following format.
 
      +------+------------------------+
      | size |       data bytes       |
      +------+------------------------+
 
    The size is 4 bytes written most significant byte first, being the
-number of subsequent data bytes, or the twos complement negative of
-that when a negative integer is represented.  The data bytes are the
-absolute value of the integer, written most significant byte first.
+number of subsequent data bytes, or the twos complement negative of that
+when a negative integer is represented.  The data bytes are the absolute
+value of the integer, written most significant byte first.
 
    The most significant data byte is always non-zero, so the output is
 the same on all systems, irrespective of limb size.
 
    In GMP 1, leading zero bytes were written to pad the data bytes to a
-multiple of the limb size.  `mpz_inp_raw' will still accept this, for
+multiple of the limb size.  'mpz_inp_raw' will still accept this, for
 compatibility.
 
    The use of "big endian" for both the size and data fields is
 deliberate, it makes the data easy to read in a hex dump of a file.
 Unfortunately it also means that the limb data must be reversed when
-reading or writing, so neither a big endian nor little endian system
-can just read and write `_mp_d'.
+reading or writing, so neither a big endian nor little endian system can
+just read and write '_mp_d'.
 
 
 File: gmp.info,  Node: C++ Interface Internals,  Prev: Raw Output Internals,  Up: Internals
@@ -8389,9 +8339,9 @@ File: gmp.info,  Node: C++ Interface Internals,  Prev: Raw Output Internals,  Up
 ============================
 
 A system of expression templates is used to ensure something like
-`a=b+c' turns into a simple call to `mpz_add' etc.  For `mpf_class' the
+'a=b+c' turns into a simple call to 'mpz_add' etc.  For 'mpf_class' the
 scheme also ensures the precision of the final destination is used for
-any temporaries within a statement like `f=w*x+y*z'.  These are
+any temporaries within a statement like 'f=w*x+y*z'.  These are
 important features which a naive implementation cannot provide.
 
    A simplified description of the scheme follows.  The true scheme is
@@ -8415,12 +8365,12 @@ And an "additive expression" object,
          <__gmp_binary_expr<mpf_class, mpf_class, __gmp_binary_plus> >(f, g);
      }
 
-   The seemingly redundant `__gmp_expr<__gmp_binary_expr<...>>' is used
+   The seemingly redundant '__gmp_expr<__gmp_binary_expr<...>>' is used
 to encapsulate any possible kind of expression into a single template
-type.  In fact even `mpf_class' etc are `typedef' specializations of
-`__gmp_expr'.
+type.  In fact even 'mpf_class' etc are 'typedef' specializations of
+'__gmp_expr'.
 
-   Next we define assignment of `__gmp_expr' to `mpf_class'.
+   Next we define assignment of '__gmp_expr' to 'mpf_class'.
 
      template <class T>
      mpf_class & mpf_class::operator=(const __gmp_expr<T> &expr)
@@ -8436,14 +8386,14 @@ type.  In fact even `mpf_class' etc are `typedef' specializations of
        Op::eval(f, expr.val1.get_mpf_t(), expr.val2.get_mpf_t());
      }
 
-   where `expr.val1' and `expr.val2' are references to the expression's
-operands (here `expr' is the `__gmp_binary_expr' stored within the
-`__gmp_expr').
+   where 'expr.val1' and 'expr.val2' are references to the expression's
+operands (here 'expr' is the '__gmp_binary_expr' stored within the
+'__gmp_expr').
 
    This way, the expression is actually evaluated only at the time of
-assignment, when the required precision (that of `f') is known.
-Furthermore the target `mpf_t' is now available, thus we can call
-`mpf_add' directly with `f' as the output argument.
+assignment, when the required precision (that of 'f') is known.
+Furthermore the target 'mpf_t' is now available, thus we can call
+'mpf_add' directly with 'f' as the output argument.
 
    Compound expressions are handled by defining operators taking
 subexpressions as their arguments, like this:
@@ -8458,7 +8408,7 @@ subexpressions as their arguments, like this:
          (expr1, expr2);
      }
 
-   And the corresponding specializations of `__gmp_expr::eval':
+   And the corresponding specializations of '__gmp_expr::eval':
 
      template <class T, class U, class Op>
      void __gmp_expr
@@ -8471,7 +8421,7 @@ subexpressions as their arguments, like this:
      }
 
    The expression is thus recursively evaluated to any level of
-complexity and all subexpressions are evaluated to the precision of `f'.
+complexity and all subexpressions are evaluated to the precision of 'f'.
 
 
 File: gmp.info,  Node: Contributors,  Next: References,  Prev: Internals,  Up: Top
@@ -8482,7 +8432,7 @@ Appendix A Contributors
 Torbjrn Granlund wrote the original GMP library and is still the main
 developer.  Code not explicitly attributed to others, was contributed by
 Torbjrn.  Several other individuals and organizations have contributed
-GMP.  Here is a list in chronological order on first contribution:
+GMP. Here is a list in chronological order on first contribution:
 
    Gunnar Sjdin and Hans Riesel helped with mathematical problems in
 early versions of the library.
@@ -8494,33 +8444,33 @@ first version of this manual.
 the library and made creative suggestions.
 
    John Amanatides of York University in Canada contributed the function
-`mpz_probab_prime_p'.
+'mpz_probab_prime_p'.
 
    Paul Zimmermann wrote the REDC-based mpz_powm code, the
 Schnhage-Strassen FFT multiply code, and the Karatsuba square root
 code.  He also improved the Toom3 code for GMP 4.2.  Paul sparked the
-development of GMP 2, with his comparisons between bignum packages.
-The ECMNET project Paul is organizing was a driving force behind many
-of the optimizations in GMP 3.  Paul also wrote the new GMP 4.3 nth
-root code (with Torbjrn).
+development of GMP 2, with his comparisons between bignum packages.  The
+ECMNET project Paul is organizing was a driving force behind many of the
+optimizations in GMP 3.  Paul also wrote the new GMP 4.3 nth root code
+(with Torbjrn).
 
    Ken Weber (Kent State University, Universidade Federal do Rio Grande
-do Sul) contributed now defunct versions of `mpz_gcd', `mpz_divexact',
-`mpn_gcd', and `mpn_bdivmod', partially supported by CNPq (Brazil)
-grant 301314194-2.
+do Sul) contributed now defunct versions of 'mpz_gcd', 'mpz_divexact',
+'mpn_gcd', and 'mpn_bdivmod', partially supported by CNPq (Brazil) grant
+301314194-2.
 
    Per Bothner of Cygnus Support helped to set up GMP to use Cygnus'
 configure.  He has also made valuable suggestions and tested numerous
 intermediary releases.
 
-   Joachim Hollman was involved in the design of the `mpf' interface,
-and in the `mpz' design revisions for version 2.
+   Joachim Hollman was involved in the design of the 'mpf' interface,
+and in the 'mpz' design revisions for version 2.
 
-   Bennet Yee contributed the initial versions of `mpz_jacobi' and
-`mpz_legendre'.
+   Bennet Yee contributed the initial versions of 'mpz_jacobi' and
+'mpz_legendre'.
 
-   Andreas Schwab contributed the files `mpn/m68k/lshift.S' and
-`mpn/m68k/rshift.S' (now in `.asm' form).
+   Andreas Schwab contributed the files 'mpn/m68k/lshift.S' and
+'mpn/m68k/rshift.S' (now in '.asm' form).
 
    Robert Harley of Inria, France and David Seal of ARM, England,
 suggested clever improvements for population count.  Robert also wrote
@@ -8528,29 +8478,28 @@ highly optimized Karatsuba and 3-way Toom multiplication functions for
 GMP 3, and contributed the ARM assembly code.
 
    Torsten Ekedahl of the Mathematical department of Stockholm
-University provided significant inspiration during several phases of
-the GMP development.  His mathematical expertise helped improve several
+University provided significant inspiration during several phases of the
+GMP development.  His mathematical expertise helped improve several
 algorithms.
 
    Linus Nordberg wrote the new configure system based on autoconf and
 implemented the new random functions.
 
-   Kevin Ryde worked on a large number of things: optimized x86 code,
-m4 asm macros, parameter tuning, speed measuring, the configure system,
+   Kevin Ryde worked on a large number of things: optimized x86 code, m4
+asm macros, parameter tuning, speed measuring, the configure system,
 function inlining, divisibility tests, bit scanning, Jacobi symbols,
 Fibonacci and Lucas number functions, printf and scanf functions, perl
-interface, demo expression parser, the algorithms chapter in the
-manual, `gmpasm-mode.el', and various miscellaneous improvements
-elsewhere.
+interface, demo expression parser, the algorithms chapter in the manual,
+'gmpasm-mode.el', and various miscellaneous improvements elsewhere.
 
    Kent Boortz made the Mac OS 9 port.
 
    Steve Root helped write the optimized alpha 21264 assembly code.
 
-   Gerardo Ballabio wrote the `gmpxx.h' C++ class interface and the C++
-`istream' input routines.
+   Gerardo Ballabio wrote the 'gmpxx.h' C++ class interface and the C++
+'istream' input routines.
 
-   Jason Moxham rewrote `mpz_fac_ui'.
+   Jason Moxham rewrote 'mpz_fac_ui'.
 
    Pedro Gimeno implemented the Mersenne Twister and made other random
 number improvements.
@@ -8559,25 +8508,24 @@ number improvements.
 quadratic Hensel division code, and (with Torbjrn) the new divide and
 conquer division code for GMP 4.3.  Niels also helped implement the new
 Toom multiply code for GMP 4.3 and implemented helper functions to
-simplify Toom evaluations for GMP 5.0.  He wrote the original version
-of mpn_mulmod_bnm1.
+simplify Toom evaluations for GMP 5.0.  He wrote the original version of
+mpn_mulmod_bnm1.
 
    Alberto Zanoni and Marco Bodrato suggested the unbalanced multiply
 strategy, and found the optimal strategies for evaluation and
 interpolation in Toom multiplication.
 
-   Marco Bodrato helped implement the new Toom multiply code for GMP
-4.3 and implemented most of the new Toom multiply and squaring code for
-5.0.  He is the main author of the current mpn_mulmod_bnm1 and
-mpn_mullo_n.  Marco also wrote the functions mpn_invert and
-mpn_invertappr.
+   Marco Bodrato helped implement the new Toom multiply code for GMP 4.3
+and implemented most of the new Toom multiply and squaring code for 5.0.
+He is the main author of the current mpn_mulmod_bnm1 and mpn_mullo_n.
+Marco also wrote the functions mpn_invert and mpn_invertappr.
 
-   David Harvey suggested the internal function `mpn_bdiv_dbm1',
+   David Harvey suggested the internal function 'mpn_bdiv_dbm1',
 implementing division relevant to Toom multiplication.  He also worked
 on fast assembly sequences, in particular on a fast AMD64
-`mpn_mul_basecase'.
+'mpn_mul_basecase'.
 
-   Martin Boij wrote `mpn_perfect_power_p'.
+   Martin Boij wrote 'mpn_perfect_power_p'.
 
    (This list is chronological, not ordered after significance.  If you
 have contributed to GMP but are not listed above, please tell
@@ -8590,8 +8538,8 @@ project POSSO (POlynomial System SOlving).
    The development of GMP 2, 3, and 4 was supported in part by the IDA
 Center for Computing Sciences.
 
-   Thanks go to Hans Thorsen for donating an SGI system for the GMP
-test system environment.
+   Thanks go to Hans Thorsen for donating an SGI system for the GMP test
+system environment.
 
 
 File: gmp.info,  Node: References,  Next: GNU Free Documentation License,  Prev: Contributors,  Up: Top
@@ -8608,48 +8556,48 @@ B.1 Books
 
    * Richard Crandall and Carl Pomerance, "Prime Numbers: A
      Computational Perspective", 2nd edition, Springer-Verlag, 2005.
-     `http://math.dartmouth.edu/~carlp/'
+     <http://math.dartmouth.edu/~carlp/>
 
    * Henri Cohen, "A Course in Computational Algebraic Number Theory",
      Graduate Texts in Mathematics number 138, Springer-Verlag, 1993.
-     `http://www.math.u-bordeaux.fr/~cohen/'
+     <http://www.math.u-bordeaux.fr/~cohen/>
 
    * Donald E. Knuth, "The Art of Computer Programming", volume 2,
      "Seminumerical Algorithms", 3rd edition, Addison-Wesley, 1998.
-     `http://www-cs-faculty.stanford.edu/~knuth/taocp.html'
+     <http://www-cs-faculty.stanford.edu/~knuth/taocp.html>
 
    * John D. Lipson, "Elements of Algebra and Algebraic Computing", The
      Benjamin Cummings Publishing Company Inc, 1981.
 
    * Alfred J. Menezes, Paul C. van Oorschot and Scott A. Vanstone,
      "Handbook of Applied Cryptography",
-     `http://www.cacr.math.uwaterloo.ca/hac/'
+     <http://www.cacr.math.uwaterloo.ca/hac/>
 
-   * Richard M. Stallman and the GCC Developer Community, "Using the
-     GNU Compiler Collection", Free Software Foundation, 2008,
-     available online `http://gcc.gnu.org/onlinedocs/', and in the GCC
-     package `ftp://ftp.gnu.org/gnu/gcc/'
+   * Richard M. Stallman and the GCC Developer Community, "Using the GNU
+     Compiler Collection", Free Software Foundation, 2008, available
+     online <http://gcc.gnu.org/onlinedocs/>, and in the GCC package
+     <ftp://ftp.gnu.org/gnu/gcc/>
 
 B.2 Papers
 ==========
 
    * Yves Bertot, Nicolas Magaud and Paul Zimmermann, "A Proof of GMP
      Square Root", Journal of Automated Reasoning, volume 29, 2002, pp.
-     225-252.  Also available online as INRIA Research Report 4475,
-     June 2001, `http://www.inria.fr/rrrt/rr-4475.html'
+     225-252.  Also available online as INRIA Research Report 4475, June
+     2001, <http://www.inria.fr/rrrt/rr-4475.html>
 
    * Christoph Burnikel and Joachim Ziegler, "Fast Recursive Division",
      Max-Planck-Institut fuer Informatik Research Report MPI-I-98-1-022,
-     `http://data.mpi-sb.mpg.de/internet/reports.nsf/NumberView/1998-1-022'
+     <http://data.mpi-sb.mpg.de/internet/reports.nsf/NumberView/1998-1-022>
 
    * Torbjrn Granlund and Peter L. Montgomery, "Division by Invariant
      Integers using Multiplication", in Proceedings of the SIGPLAN
      PLDI'94 Conference, June 1994.  Also available
-     `ftp://ftp.cwi.nl/pub/pmontgom/divcnst.psa4.gz' (and .psl.gz).
+     <ftp://ftp.cwi.nl/pub/pmontgom/divcnst.psa4.gz> (and .psl.gz).
 
    * Niels Mller and Torbjrn Granlund, "Improved division by invariant
      integers", IEEE Transactions on Computers, 11 June 2010.
-     `http://gmplib.org/~tege/division-paper.pdf'
+     <http://gmplib.org/~tege/division-paper.pdf>
 
    * Torbjrn Granlund and Niels Mller, "Division of integers large and
      small", to appear.
@@ -8657,36 +8605,35 @@ B.2 Papers
    * Tudor Jebelean, "An algorithm for exact division", Journal of
      Symbolic Computation, volume 15, 1993, pp. 169-180.  Research
      report version available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-35.ps.gz'
+     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-35.ps.gz>
 
    * Tudor Jebelean, "Exact Division with Karatsuba Complexity -
      Extended Abstract", RISC-Linz technical report 96-31,
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-31.ps.gz'
+     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-31.ps.gz>
 
    * Tudor Jebelean, "Practical Integer Division with Karatsuba
      Complexity", ISSAC 97, pp. 339-341.  Technical report available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-29.ps.gz'
+     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-29.ps.gz>
 
    * Tudor Jebelean, "A Generalization of the Binary GCD Algorithm",
      ISSAC 93, pp. 111-116.  Technical report version available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1993/93-01.ps.gz'
+     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1993/93-01.ps.gz>
 
-   * Tudor Jebelean, "A Double-Digit Lehmer-Euclid Algorithm for
-     Finding the GCD of Long Integers", Journal of Symbolic
-     Computation, volume 19, 1995, pp. 145-157.  Technical report
-     version also available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-69.ps.gz'
+   * Tudor Jebelean, "A Double-Digit Lehmer-Euclid Algorithm for Finding
+     the GCD of Long Integers", Journal of Symbolic Computation, volume
+     19, 1995, pp. 145-157.  Technical report version also available
+     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-69.ps.gz>
 
    * Werner Krandick and Tudor Jebelean, "Bidirectional Exact Integer
      Division", Journal of Symbolic Computation, volume 21, 1996, pp.
      441-455.  Early technical report version also available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1994/94-50.ps.gz'
+     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1994/94-50.ps.gz>
 
    * Makoto Matsumoto and Takuji Nishimura, "Mersenne Twister: A
      623-dimensionally equidistributed uniform pseudorandom number
      generator", ACM Transactions on Modelling and Computer Simulation,
      volume 8, January 1998, pp. 3-30.  Available online
-     `http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.ps.gz'
+     <http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.ps.gz>
      (or .pdf)
 
    * R. Moenck and A. Borodin, "Fast Modular Transforms via Division",
@@ -8696,8 +8643,8 @@ B.2 Papers
      volume 8, number 3, June 1974, pp. 366-386.
 
    * Niels Mller, "On Schnhage's algorithm and subquadratic integer
-     GCD   computation", in Mathematics of Computation, volume 77,
-     January 2008, pp.    589-607.
+     GCD computation", in Mathematics of Computation, volume 77, January
+     2008, pp. 589-607.
 
    * Peter L. Montgomery, "Modular Multiplication Without Trial
      Division", in Mathematics of Computation, volume 44, number 170,
@@ -8711,11 +8658,11 @@ B.2 Papers
      1995, pp. 111-122.
 
    * Paul Zimmermann, "Karatsuba Square Root", INRIA Research Report
-     3805, November 1999, `http://www.inria.fr/rrrt/rr-3805.html'
+     3805, November 1999, <http://www.inria.fr/rrrt/rr-3805.html>
 
    * Paul Zimmermann, "A Proof of GMP Fast Division and Square Root
      Implementations",
-     `http://www.loria.fr/~zimmerma/papers/proof-div-sqrt.ps.gz'
+     <http://www.loria.fr/~zimmerma/papers/proof-div-sqrt.ps.gz>
 
    * Dan Zuras, "On Squaring and Multiplying Large Integers", ARITH-11:
      IEEE Symposium on Computer Arithmetic, 1993, pp. 260 to 271.
@@ -8731,8 +8678,8 @@ Appendix C GNU Free Documentation License
 
                      Version 1.3, 3 November 2008
 
-     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
-     `http://fsf.org/'
+     Copyright  2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
+     <http://fsf.org/>
 
      Everyone is permitted to copy and distribute verbatim copies
      of this license document, but changing it is not allowed.
@@ -8757,21 +8704,21 @@ Appendix C GNU Free Documentation License
      free program should come with manuals providing the same freedoms
      that the software does.  But this License is not limited to
      software manuals; it can be used for any textual work, regardless
-     of subject matter or whether it is published as a printed book.
-     We recommend this License principally for works whose purpose is
+     of subject matter or whether it is published as a printed book.  We
+     recommend this License principally for works whose purpose is
      instruction or reference.
 
   1. APPLICABILITY AND DEFINITIONS
 
      This License applies to any manual or other work, in any medium,
-     that contains a notice placed by the copyright holder saying it
-     can be distributed under the terms of this License.  Such a notice
+     that contains a notice placed by the copyright holder saying it can
+     be distributed under the terms of this License.  Such a notice
      grants a world-wide, royalty-free license, unlimited in duration,
      to use that work under the conditions stated herein.  The
      "Document", below, refers to any such manual or work.  Any member
-     of the public is a licensee, and is addressed as "you".  You
-     accept the license if you copy, modify or distribute the work in a
-     way requiring permission under copyright law.
+     of the public is a licensee, and is addressed as "you".  You accept
+     the license if you copy, modify or distribute the work in a way
+     requiring permission under copyright law.
 
      A "Modified Version" of the Document means any work containing the
      Document or a portion of it, either copied verbatim, or with
@@ -8789,12 +8736,12 @@ Appendix C GNU Free Documentation License
      regarding them.
 
      The "Invariant Sections" are certain Secondary Sections whose
-     titles are designated, as being those of Invariant Sections, in
-     the notice that says that the Document is released under this
-     License.  If a section does not fit the above definition of
-     Secondary then it is not allowed to be designated as Invariant.
-     The Document may contain zero Invariant Sections.  If the Document
-     does not identify any Invariant Sections then there are none.
+     titles are designated, as being those of Invariant Sections, in the
+     notice that says that the Document is released under this License.
+     If a section does not fit the above definition of Secondary then it
+     is not allowed to be designated as Invariant.  The Document may
+     contain zero Invariant Sections.  If the Document does not identify
+     any Invariant Sections then there are none.
 
      The "Cover Texts" are certain short passages of text that are
      listed, as Front-Cover Texts or Back-Cover Texts, in the notice
@@ -8805,27 +8752,27 @@ Appendix C GNU Free Documentation License
      A "Transparent" copy of the Document means a machine-readable copy,
      represented in a format whose specification is available to the
      general public, that is suitable for revising the document
-     straightforwardly with generic text editors or (for images
-     composed of pixels) generic paint programs or (for drawings) some
-     widely available drawing editor, and that is suitable for input to
-     text formatters or for automatic translation to a variety of
-     formats suitable for input to text formatters.  A copy made in an
-     otherwise Transparent file format whose markup, or absence of
-     markup, has been arranged to thwart or discourage subsequent
-     modification by readers is not Transparent.  An image format is
-     not Transparent if used for any substantial amount of text.  A
-     copy that is not "Transparent" is called "Opaque".
+     straightforwardly with generic text editors or (for images composed
+     of pixels) generic paint programs or (for drawings) some widely
+     available drawing editor, and that is suitable for input to text
+     formatters or for automatic translation to a variety of formats
+     suitable for input to text formatters.  A copy made in an otherwise
+     Transparent file format whose markup, or absence of markup, has
+     been arranged to thwart or discourage subsequent modification by
+     readers is not Transparent.  An image format is not Transparent if
+     used for any substantial amount of text.  A copy that is not
+     "Transparent" is called "Opaque".
 
      Examples of suitable formats for Transparent copies include plain
      ASCII without markup, Texinfo input format, LaTeX input format,
-     SGML or XML using a publicly available DTD, and
-     standard-conforming simple HTML, PostScript or PDF designed for
-     human modification.  Examples of transparent image formats include
-     PNG, XCF and JPG.  Opaque formats include proprietary formats that
-     can be read and edited only by proprietary word processors, SGML or
-     XML for which the DTD and/or processing tools are not generally
-     available, and the machine-generated HTML, PostScript or PDF
-     produced by some word processors for output purposes only.
+     SGML or XML using a publicly available DTD, and standard-conforming
+     simple HTML, PostScript or PDF designed for human modification.
+     Examples of transparent image formats include PNG, XCF and JPG.
+     Opaque formats include proprietary formats that can be read and
+     edited only by proprietary word processors, SGML or XML for which
+     the DTD and/or processing tools are not generally available, and
+     the machine-generated HTML, PostScript or PDF produced by some word
+     processors for output purposes only.
 
      The "Title Page" means, for a printed book, the title page itself,
      plus such following pages as are needed to hold, legibly, the
@@ -8863,8 +8810,8 @@ Appendix C GNU Free Documentation License
      may not use technical measures to obstruct or control the reading
      or further copying of the copies you make or distribute.  However,
      you may accept compensation in exchange for copies.  If you
-     distribute a large enough number of copies you must also follow
-     the conditions in section 3.
+     distribute a large enough number of copies you must also follow the
+     conditions in section 3.
 
      You may also lend copies, under the same conditions stated above,
      and you may publicly display copies.
@@ -8878,12 +8825,11 @@ Appendix C GNU Free Documentation License
      these Cover Texts: Front-Cover Texts on the front cover, and
      Back-Cover Texts on the back cover.  Both covers must also clearly
      and legibly identify you as the publisher of these copies.  The
-     front cover must present the full title with all words of the
-     title equally prominent and visible.  You may add other material
-     on the covers in addition.  Copying with changes limited to the
-     covers, as long as they preserve the title of the Document and
-     satisfy these conditions, can be treated as verbatim copying in
-     other respects.
+     front cover must present the full title with all words of the title
+     equally prominent and visible.  You may add other material on the
+     covers in addition.  Copying with changes limited to the covers, as
+     long as they preserve the title of the Document and satisfy these
+     conditions, can be treated as verbatim copying in other respects.
 
      If the required texts for either cover are too voluminous to fit
      legibly, you should put the first ones listed (as many as fit
@@ -8891,40 +8837,39 @@ Appendix C GNU Free Documentation License
      adjacent pages.
 
      If you publish or distribute Opaque copies of the Document
-     numbering more than 100, you must either include a
-     machine-readable Transparent copy along with each Opaque copy, or
-     state in or with each Opaque copy a computer-network location from
-     which the general network-using public has access to download
-     using public-standard network protocols a complete Transparent
-     copy of the Document, free of added material.  If you use the
-     latter option, you must take reasonably prudent steps, when you
-     begin distribution of Opaque copies in quantity, to ensure that
-     this Transparent copy will remain thus accessible at the stated
-     location until at least one year after the last time you
-     distribute an Opaque copy (directly or through your agents or
-     retailers) of that edition to the public.
+     numbering more than 100, you must either include a machine-readable
+     Transparent copy along with each Opaque copy, or state in or with
+     each Opaque copy a computer-network location from which the general
+     network-using public has access to download using public-standard
+     network protocols a complete Transparent copy of the Document, free
+     of added material.  If you use the latter option, you must take
+     reasonably prudent steps, when you begin distribution of Opaque
+     copies in quantity, to ensure that this Transparent copy will
+     remain thus accessible at the stated location until at least one
+     year after the last time you distribute an Opaque copy (directly or
+     through your agents or retailers) of that edition to the public.
 
      It is requested, but not required, that you contact the authors of
-     the Document well before redistributing any large number of
-     copies, to give them a chance to provide you with an updated
-     version of the Document.
+     the Document well before redistributing any large number of copies,
+     to give them a chance to provide you with an updated version of the
+     Document.
 
   4. MODIFICATIONS
 
      You may copy and distribute a Modified Version of the Document
      under the conditions of sections 2 and 3 above, provided that you
-     release the Modified Version under precisely this License, with
-     the Modified Version filling the role of the Document, thus
-     licensing distribution and modification of the Modified Version to
-     whoever possesses a copy of it.  In addition, you must do these
-     things in the Modified Version:
+     release the Modified Version under precisely this License, with the
+     Modified Version filling the role of the Document, thus licensing
+     distribution and modification of the Modified Version to whoever
+     possesses a copy of it.  In addition, you must do these things in
+     the Modified Version:
 
        A. Use in the Title Page (and on the covers, if any) a title
-          distinct from that of the Document, and from those of
-          previous versions (which should, if there were any, be listed
-          in the History section of the Document).  You may use the
-          same title as a previous version if the original publisher of
-          that version gives permission.
+          distinct from that of the Document, and from those of previous
+          versions (which should, if there were any, be listed in the
+          History section of the Document).  You may use the same title
+          as a previous version if the original publisher of that
+          version gives permission.
 
        B. List on the Title Page, as authors, one or more persons or
           entities responsible for authorship of the modifications in
@@ -8954,31 +8899,30 @@ Appendix C GNU Free Documentation License
 
        I. Preserve the section Entitled "History", Preserve its Title,
           and add to it an item stating at least the title, year, new
-          authors, and publisher of the Modified Version as given on
-          the Title Page.  If there is no section Entitled "History" in
-          the Document, create one stating the title, year, authors,
-          and publisher of the Document as given on its Title Page,
-          then add an item describing the Modified Version as stated in
-          the previous sentence.
+          authors, and publisher of the Modified Version as given on the
+          Title Page.  If there is no section Entitled "History" in the
+          Document, create one stating the title, year, authors, and
+          publisher of the Document as given on its Title Page, then add
+          an item describing the Modified Version as stated in the
+          previous sentence.
 
        J. Preserve the network location, if any, given in the Document
           for public access to a Transparent copy of the Document, and
           likewise the network locations given in the Document for
-          previous versions it was based on.  These may be placed in
-          the "History" section.  You may omit a network location for a
-          work that was published at least four years before the
-          Document itself, or if the original publisher of the version
-          it refers to gives permission.
+          previous versions it was based on.  These may be placed in the
+          "History" section.  You may omit a network location for a work
+          that was published at least four years before the Document
+          itself, or if the original publisher of the version it refers
+          to gives permission.
 
        K. For any section Entitled "Acknowledgements" or "Dedications",
-          Preserve the Title of the section, and preserve in the
-          section all the substance and tone of each of the contributor
+          Preserve the Title of the section, and preserve in the section
+          all the substance and tone of each of the contributor
           acknowledgements and/or dedications given therein.
 
-       L. Preserve all the Invariant Sections of the Document,
-          unaltered in their text and in their titles.  Section numbers
-          or the equivalent are not considered part of the section
-          titles.
+       L. Preserve all the Invariant Sections of the Document, unaltered
+          in their text and in their titles.  Section numbers or the
+          equivalent are not considered part of the section titles.
 
        M. Delete any section Entitled "Endorsements".  Such a section
           may not be included in the Modified Version.
@@ -8991,11 +8935,11 @@ Appendix C GNU Free Documentation License
 
      If the Modified Version includes new front-matter sections or
      appendices that qualify as Secondary Sections and contain no
-     material copied from the Document, you may at your option
-     designate some or all of these sections as invariant.  To do this,
-     add their titles to the list of Invariant Sections in the Modified
-     Version's license notice.  These titles must be distinct from any
-     other section titles.
+     material copied from the Document, you may at your option designate
+     some or all of these sections as invariant.  To do this, add their
+     titles to the list of Invariant Sections in the Modified Version's
+     license notice.  These titles must be distinct from any other
+     section titles.
 
      You may add a section Entitled "Endorsements", provided it contains
      nothing but endorsements of your Modified Version by various
@@ -9004,15 +8948,15 @@ Appendix C GNU Free Documentation License
      definition of a standard.
 
      You may add a passage of up to five words as a Front-Cover Text,
-     and a passage of up to 25 words as a Back-Cover Text, to the end
-     of the list of Cover Texts in the Modified Version.  Only one
-     passage of Front-Cover Text and one of Back-Cover Text may be
-     added by (or through arrangements made by) any one entity.  If the
-     Document already includes a cover text for the same cover,
-     previously added by you or by arrangement made by the same entity
-     you are acting on behalf of, you may not add another; but you may
-     replace the old one, on explicit permission from the previous
-     publisher that added the old one.
+     and a passage of up to 25 words as a Back-Cover Text, to the end of
+     the list of Cover Texts in the Modified Version.  Only one passage
+     of Front-Cover Text and one of Back-Cover Text may be added by (or
+     through arrangements made by) any one entity.  If the Document
+     already includes a cover text for the same cover, previously added
+     by you or by arrangement made by the same entity you are acting on
+     behalf of, you may not add another; but you may replace the old
+     one, on explicit permission from the previous publisher that added
+     the old one.
 
      The author(s) and publisher(s) of the Document do not by this
      License give permission to use their names for publicity for or to
@@ -9022,8 +8966,8 @@ Appendix C GNU Free Documentation License
 
      You may combine the Document with other documents released under
      this License, under the terms defined in section 4 above for
-     modified versions, provided that you include in the combination
-     all of the Invariant Sections of all of the original documents,
+     modified versions, provided that you include in the combination all
+     of the Invariant Sections of all of the original documents,
      unmodified, and list them all as Invariant Sections of your
      combined work in its license notice, and that you preserve all
      their Warranty Disclaimers.
@@ -9050,20 +8994,20 @@ Appendix C GNU Free Documentation License
      documents released under this License, and replace the individual
      copies of this License in the various documents with a single copy
      that is included in the collection, provided that you follow the
-     rules of this License for verbatim copying of each of the
-     documents in all other respects.
+     rules of this License for verbatim copying of each of the documents
+     in all other respects.
 
      You may extract a single document from such a collection, and
      distribute it individually under this License, provided you insert
-     a copy of this License into the extracted document, and follow
-     this License in all other respects regarding verbatim copying of
-     that document.
+     a copy of this License into the extracted document, and follow this
+     License in all other respects regarding verbatim copying of that
+     document.
 
   7. AGGREGATION WITH INDEPENDENT WORKS
 
      A compilation of the Document or its derivatives with other
-     separate and independent documents or works, in or on a volume of
-     a storage or distribution medium, is called an "aggregate" if the
+     separate and independent documents or works, in or on a volume of a
+     storage or distribution medium, is called an "aggregate" if the
      copyright resulting from the compilation is not used to limit the
      legal rights of the compilation's users beyond what the individual
      works permit.  When the Document is included in an aggregate, this
@@ -9108,8 +9052,8 @@ Appendix C GNU Free Documentation License
 
      However, if you cease all violation of this License, then your
      license from a particular copyright holder is reinstated (a)
-     provisionally, unless and until the copyright holder explicitly
-     and finally terminates your license, and (b) permanently, if the
+     provisionally, unless and until the copyright holder explicitly and
+     finally terminates your license, and (b) permanently, if the
      copyright holder fails to notify you of the violation by some
      reasonable means prior to 60 days after the cessation.
 
@@ -9121,33 +9065,33 @@ Appendix C GNU Free Documentation License
      after your receipt of the notice.
 
      Termination of your rights under this section does not terminate
-     the licenses of parties who have received copies or rights from
-     you under this License.  If your rights have been terminated and
-     not permanently reinstated, receipt of a copy of some or all of
-     the same material does not give you any rights to use it.
+     the licenses of parties who have received copies or rights from you
+     under this License.  If your rights have been terminated and not
+     permanently reinstated, receipt of a copy of some or all of the
+     same material does not give you any rights to use it.
 
- 10. FUTURE REVISIONS OF THIS LICENSE
+  10. FUTURE REVISIONS OF THIS LICENSE
 
      The Free Software Foundation may publish new, revised versions of
      the GNU Free Documentation License from time to time.  Such new
      versions will be similar in spirit to the present version, but may
      differ in detail to address new problems or concerns.  See
-     `http://www.gnu.org/copyleft/'.
+     <http://www.gnu.org/copyleft/>.
 
      Each version of the License is given a distinguishing version
      number.  If the Document specifies that a particular numbered
      version of this License "or any later version" applies to it, you
      have the option of following the terms and conditions either of
      that specified version or of any later version that has been
-     published (not as a draft) by the Free Software Foundation.  If
-     the Document does not specify a version number of this License,
-     you may choose any version ever published (not as a draft) by the
-     Free Software Foundation.  If the Document specifies that a proxy
-     can decide which future versions of this License can be used, that
+     published (not as a draft) by the Free Software Foundation.  If the
+     Document does not specify a version number of this License, you may
+     choose any version ever published (not as a draft) by the Free
+     Software Foundation.  If the Document specifies that a proxy can
+     decide which future versions of this License can be used, that
      proxy's public statement of acceptance of a version permanently
      authorizes you to choose that version for the Document.
 
- 11. RELICENSING
+  11. RELICENSING
 
      "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
      World Wide Web server that publishes copyrightable works and also
@@ -9177,7 +9121,6 @@ Appendix C GNU Free Documentation License
      site under CC-BY-SA on the same site at any time before August 1,
      2009, provided the MMC is eligible for relicensing.
 
-
 ADDENDUM: How to use this License for your documents
 ====================================================
 
@@ -9194,7 +9137,7 @@ notices just after the title page:
        Free Documentation License''.
 
    If you have Invariant Sections, Front-Cover Texts and Back-Cover
-Texts, replace the "with...Texts." line with this:
+Texts, replace the "with...Texts."  line with this:
 
          with the Invariant Sections being LIST THEIR TITLES, with
          the Front-Cover Texts being LIST, and with the Back-Cover Texts
@@ -9205,9 +9148,9 @@ combination of the three, merge those two alternatives to suit the
 situation.
 
    If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License, to
-permit their use in free software.
+recommend releasing these examples in parallel under your choice of free
+software license, such as the GNU General Public License, to permit
+their use in free software.
 
 
 File: gmp.info,  Node: Concept Index,  Next: Function Index,  Prev: GNU Free Documentation License,  Up: Top
@@ -9220,19 +9163,19 @@ Concept Index
 
 * #include:                              Headers and Libraries.
                                                               (line   6)
-* --build:                               Build Options.       (line  52)
-* --disable-fft:                         Build Options.       (line 317)
-* --disable-shared:                      Build Options.       (line  45)
-* --disable-static:                      Build Options.       (line  45)
-* --enable-alloca:                       Build Options.       (line 278)
-* --enable-assert:                       Build Options.       (line 327)
-* --enable-cxx:                          Build Options.       (line 230)
-* --enable-fat:                          Build Options.       (line 164)
-* --enable-mpbsd:                        Build Options.       (line 322)
+* --build:                               Build Options.       (line  51)
+* --disable-fft:                         Build Options.       (line 311)
+* --disable-shared:                      Build Options.       (line  44)
+* --disable-static:                      Build Options.       (line  44)
+* --enable-alloca:                       Build Options.       (line 277)
+* --enable-assert:                       Build Options.       (line 321)
+* --enable-cxx:                          Build Options.       (line 229)
+* --enable-fat:                          Build Options.       (line 163)
+* --enable-mpbsd:                        Build Options.       (line 316)
+* --enable-profiling:                    Build Options.       (line 325)
 * --enable-profiling <1>:                Profiling.           (line   6)
-* --enable-profiling:                    Build Options.       (line 331)
 * --exec-prefix:                         Build Options.       (line  32)
-* --host:                                Build Options.       (line  66)
+* --host:                                Build Options.       (line  65)
 * --prefix:                              Build Options.       (line  32)
 * -finstrument-functions:                Profiling.           (line  66)
 * 2exp functions:                        Efficiency.          (line  43)
@@ -9240,22 +9183,23 @@ Concept Index
                                                               (line  80)
 * 80x86:                                 Notes for Particular Systems.
                                                               (line 126)
+* ABI:                                   Build Options.       (line 170)
 * ABI <1>:                               ABI and ISA.         (line   6)
-* ABI:                                   Build Options.       (line 171)
-* About this manual:                     Introduction to GMP. (line  58)
+* About this manual:                     Introduction to GMP. (line  57)
 * AC_CHECK_LIB:                          Autoconf.            (line  11)
-* AIX <1>:                               Notes for Particular Systems.
+* AIX:                                   ABI and ISA.         (line 166)
+* AIX <1>:                               ABI and ISA.         (line 181)
+* AIX <2>:                               Notes for Particular Systems.
                                                               (line   7)
-* AIX:                                   ABI and ISA.         (line 169)
 * Algorithms:                            Algorithms.          (line   6)
-* alloca:                                Build Options.       (line 278)
+* alloca:                                Build Options.       (line 277)
 * Allocation of memory:                  Custom Allocation.   (line   6)
 * AMD64:                                 ABI and ISA.         (line  44)
-* Anonymous FTP of latest version:       Introduction to GMP. (line  38)
+* Anonymous FTP of latest version:       Introduction to GMP. (line  37)
 * Application Binary Interface:          ABI and ISA.         (line   6)
-* Arithmetic functions <1>:              Float Arithmetic.    (line   6)
-* Arithmetic functions <2>:              Rational Arithmetic. (line   6)
 * Arithmetic functions:                  Integer Arithmetic.  (line   6)
+* Arithmetic functions <1>:              Rational Arithmetic. (line   6)
+* Arithmetic functions <2>:              Float Arithmetic.    (line   6)
 * ARM:                                   Notes for Particular Systems.
                                                               (line  20)
 * Assembly cache handling:               Assembly Cache Handling.
@@ -9275,21 +9219,21 @@ Concept Index
                                                               (line   6)
 * Assembly writing guide:                Assembly Writing Guide.
                                                               (line   6)
-* Assertion checking <1>:                Debugging.           (line  79)
-* Assertion checking:                    Build Options.       (line 327)
-* Assignment functions <1>:              Simultaneous Float Init & Assign.
+* Assertion checking:                    Build Options.       (line 321)
+* Assertion checking <1>:                Debugging.           (line  78)
+* Assignment functions:                  Assigning Integers.  (line   6)
+* Assignment functions <1>:              Simultaneous Integer Init & Assign.
                                                               (line   6)
-* Assignment functions <2>:              Assigning Floats.    (line   6)
-* Assignment functions <3>:              Initializing Rationals.
+* Assignment functions <2>:              Initializing Rationals.
                                                               (line   6)
-* Assignment functions <4>:              Simultaneous Integer Init & Assign.
+* Assignment functions <3>:              Assigning Floats.    (line   6)
+* Assignment functions <4>:              Simultaneous Float Init & Assign.
                                                               (line   6)
-* Assignment functions:                  Assigning Integers.  (line   6)
 * Autoconf:                              Autoconf.            (line   6)
 * Basics:                                GMP Basics.          (line   6)
+* Berkeley MP compatible functions:      Build Options.       (line 316)
 * Berkeley MP compatible functions <1>:  BSD Compatible Functions.
                                                               (line   6)
-* Berkeley MP compatible functions:      Build Options.       (line 322)
 * Binomial coefficient algorithm:        Binomial Coefficients Algorithm.
                                                               (line   6)
 * Binomial coefficient functions:        Number Theoretic Functions.
@@ -9299,14 +9243,14 @@ Concept Index
 * Bit manipulation functions:            Integer Logic and Bit Fiddling.
                                                               (line   6)
 * Bit scanning functions:                Integer Logic and Bit Fiddling.
-                                                              (line  38)
+                                                              (line  37)
 * Bit shift left:                        Integer Arithmetic.  (line  35)
-* Bit shift right:                       Integer Division.    (line  53)
+* Bit shift right:                       Integer Division.    (line  65)
 * Bits per limb:                         Useful Macros and Constants.
                                                               (line   7)
+* BSD MP compatible functions:           Build Options.       (line 316)
 * BSD MP compatible functions <1>:       BSD Compatible Functions.
                                                               (line   6)
-* BSD MP compatible functions:           Build Options.       (line 322)
 * Bug reporting:                         Reporting Bugs.      (line   6)
 * Build directory:                       Build Options.       (line  19)
 * Build notes for binary packaging:      Notes for Package Builds.
@@ -9316,36 +9260,36 @@ Concept Index
 * Build options:                         Build Options.       (line   6)
 * Build problems known:                  Known Build Problems.
                                                               (line   6)
-* Build system:                          Build Options.       (line  52)
+* Build system:                          Build Options.       (line  51)
 * Building GMP:                          Installing GMP.      (line   6)
 * Bus error:                             Debugging.           (line   7)
-* C compiler:                            Build Options.       (line 182)
-* C++ compiler:                          Build Options.       (line 254)
+* C compiler:                            Build Options.       (line 181)
+* C++ compiler:                          Build Options.       (line 253)
 * C++ interface:                         C++ Class Interface. (line   6)
 * C++ interface internals:               C++ Interface Internals.
                                                               (line   6)
 * C++ istream input:                     C++ Formatted Input. (line   6)
 * C++ ostream output:                    C++ Formatted Output.
                                                               (line   6)
-* C++ support:                           Build Options.       (line 230)
-* CC:                                    Build Options.       (line 182)
-* CC_FOR_BUILD:                          Build Options.       (line 217)
-* CFLAGS:                                Build Options.       (line 182)
-* Checker:                               Debugging.           (line 115)
-* checkergcc:                            Debugging.           (line 122)
+* C++ support:                           Build Options.       (line 229)
+* CC:                                    Build Options.       (line 181)
+* CC_FOR_BUILD:                          Build Options.       (line 216)
+* CFLAGS:                                Build Options.       (line 181)
+* Checker:                               Debugging.           (line 114)
+* checkergcc:                            Debugging.           (line 121)
 * Code organisation:                     Assembly Code Organisation.
                                                               (line   6)
 * Compaq C++:                            Notes for Particular Systems.
                                                               (line  25)
-* Comparison functions <1>:              Float Comparison.    (line   6)
-* Comparison functions <2>:              Comparing Rationals. (line   6)
 * Comparison functions:                  Integer Comparisons. (line   6)
+* Comparison functions <1>:              Comparing Rationals. (line   6)
+* Comparison functions <2>:              Float Comparison.    (line   6)
 * Compatibility with older versions:     Compatibility with older versions.
                                                               (line   6)
 * Conditions for copying GNU MP:         Copying.             (line   6)
 * Configuring GMP:                       Installing GMP.      (line   6)
 * Congruence algorithm:                  Exact Remainder.     (line  29)
-* Congruence functions:                  Integer Division.    (line 124)
+* Congruence functions:                  Integer Division.    (line 137)
 * Constants:                             Useful Macros and Constants.
                                                               (line   6)
 * Contributors:                          Contributors.        (line   6)
@@ -9353,18 +9297,18 @@ Concept Index
                                                               (line   6)
 * Conventions for variables:             Variable Conventions.
                                                               (line   6)
-* Conversion functions <1>:              Converting Floats.   (line   6)
-* Conversion functions <2>:              Rational Conversions.
-                                                              (line   6)
 * Conversion functions:                  Converting Integers. (line   6)
+* Conversion functions <1>:              Rational Conversions.
+                                                              (line   6)
+* Conversion functions <2>:              Converting Floats.   (line   6)
 * Copying conditions:                    Copying.             (line   6)
-* CPPFLAGS:                              Build Options.       (line 208)
-* CPU types <1>:                         Build Options.       (line 108)
+* CPPFLAGS:                              Build Options.       (line 207)
 * CPU types:                             Introduction to GMP. (line  24)
-* Cross compiling:                       Build Options.       (line  66)
+* CPU types <1>:                         Build Options.       (line 107)
+* Cross compiling:                       Build Options.       (line  65)
 * Custom allocation:                     Custom Allocation.   (line   6)
-* CXX:                                   Build Options.       (line 254)
-* CXXFLAGS:                              Build Options.       (line 254)
+* CXX:                                   Build Options.       (line 253)
+* CXXFLAGS:                              Build Options.       (line 253)
 * Cygwin:                                Notes for Particular Systems.
                                                               (line  43)
 * Darwin:                                Known Build Problems.
@@ -9375,39 +9319,44 @@ Concept Index
 * Digits in an integer:                  Miscellaneous Integer Functions.
                                                               (line  23)
 * Divisibility algorithm:                Exact Remainder.     (line  29)
-* Divisibility functions:                Integer Division.    (line 112)
+* Divisibility functions:                Integer Division.    (line 125)
+* Divisibility functions <1>:            Integer Division.    (line 137)
 * Divisibility testing:                  Efficiency.          (line  91)
 * Division algorithms:                   Division Algorithms. (line   6)
-* Division functions <1>:                Float Arithmetic.    (line  33)
-* Division functions <2>:                Rational Arithmetic. (line  22)
 * Division functions:                    Integer Division.    (line   6)
-* DJGPP <1>:                             Known Build Problems.
-                                                              (line  18)
+* Division functions <1>:                Rational Arithmetic. (line  22)
+* Division functions <2>:                Float Arithmetic.    (line  33)
 * DJGPP:                                 Notes for Particular Systems.
                                                               (line  43)
+* DJGPP <1>:                             Known Build Problems.
+                                                              (line  18)
 * DLLs:                                  Notes for Particular Systems.
                                                               (line  56)
-* DocBook:                               Build Options.       (line 354)
-* Documentation formats:                 Build Options.       (line 347)
+* DocBook:                               Build Options.       (line 348)
+* Documentation formats:                 Build Options.       (line 341)
 * Documentation license:                 GNU Free Documentation License.
                                                               (line   6)
-* DVI:                                   Build Options.       (line 350)
+* DVI:                                   Build Options.       (line 344)
 * Efficiency:                            Efficiency.          (line   6)
 * Emacs:                                 Emacs.               (line   6)
-* Exact division functions:              Integer Division.    (line 102)
+* Exact division functions:              Integer Division.    (line 115)
 * Exact remainder:                       Exact Remainder.     (line   6)
 * Example programs:                      Demonstration Programs.
                                                               (line   6)
 * Exec prefix:                           Build Options.       (line  32)
+* Execution profiling:                   Build Options.       (line 325)
 * Execution profiling <1>:               Profiling.           (line   6)
-* Execution profiling:                   Build Options.       (line 331)
-* Exponentiation functions <1>:          Float Arithmetic.    (line  41)
 * Exponentiation functions:              Integer Exponentiation.
                                                               (line   6)
+* Exponentiation functions <1>:          Float Arithmetic.    (line  41)
 * Export:                                Integer Import and Export.
                                                               (line  45)
 * Expression parsing demo:               Demonstration Programs.
                                                               (line  15)
+* Expression parsing demo <1>:           Demonstration Programs.
+                                                              (line  17)
+* Expression parsing demo <2>:           Demonstration Programs.
+                                                              (line  19)
 * Extended GCD:                          Number Theoretic Functions.
                                                               (line  45)
 * Factor removal functions:              Number Theoretic Functions.
@@ -9416,26 +9365,26 @@ Concept Index
 * Factorial functions:                   Number Theoretic Functions.
                                                               (line  95)
 * Factorization demo:                    Demonstration Programs.
-                                                              (line  25)
+                                                              (line  22)
 * Fast Fourier Transform:                FFT Multiplication.  (line   6)
-* Fat binary:                            Build Options.       (line 164)
+* Fat binary:                            Build Options.       (line 163)
+* FFT multiplication:                    Build Options.       (line 311)
 * FFT multiplication <1>:                FFT Multiplication.  (line   6)
-* FFT multiplication:                    Build Options.       (line 317)
 * Fibonacci number algorithm:            Fibonacci Numbers Algorithm.
                                                               (line   6)
 * Fibonacci sequence functions:          Number Theoretic Functions.
                                                               (line 108)
 * Float arithmetic functions:            Float Arithmetic.    (line   6)
+* Float assignment functions:            Assigning Floats.    (line   6)
 * Float assignment functions <1>:        Simultaneous Float Init & Assign.
                                                               (line   6)
-* Float assignment functions:            Assigning Floats.    (line   6)
 * Float comparison functions:            Float Comparison.    (line   6)
 * Float conversion functions:            Converting Floats.   (line   6)
 * Float functions:                       Floating-point Functions.
                                                               (line   6)
+* Float initialization functions:        Initializing Floats. (line   6)
 * Float initialization functions <1>:    Simultaneous Float Init & Assign.
                                                               (line   6)
-* Float initialization functions:        Initializing Floats. (line   6)
 * Float input and output functions:      I/O of Floats.       (line   6)
 * Float internals:                       Float Internals.     (line   6)
 * Float miscellaneous functions:         Miscellaneous Float Functions.
@@ -9456,29 +9405,29 @@ Concept Index
 * Formatted output:                      Formatted Output.    (line   6)
 * Free Documentation License:            GNU Free Documentation License.
                                                               (line   6)
-* frexp <1>:                             Converting Floats.   (line  23)
 * frexp:                                 Converting Integers. (line  42)
-* FTP of latest version:                 Introduction to GMP. (line  38)
+* frexp <1>:                             Converting Floats.   (line  23)
+* FTP of latest version:                 Introduction to GMP. (line  37)
 * Function classes:                      Function Classes.    (line   6)
 * FunctionCheck:                         Profiling.           (line  77)
-* GCC Checker:                           Debugging.           (line 115)
+* GCC Checker:                           Debugging.           (line 114)
 * GCD algorithms:                        Greatest Common Divisor Algorithms.
                                                               (line   6)
 * GCD extended:                          Number Theoretic Functions.
                                                               (line  45)
 * GCD functions:                         Number Theoretic Functions.
                                                               (line  30)
-* GDB:                                   Debugging.           (line  58)
-* Generic C:                             Build Options.       (line 153)
+* GDB:                                   Debugging.           (line  57)
+* Generic C:                             Build Options.       (line 152)
 * GMP Perl module:                       Demonstration Programs.
-                                                              (line  35)
+                                                              (line  28)
 * GMP version number:                    Useful Macros and Constants.
                                                               (line  12)
 * gmp.h:                                 Headers and Libraries.
                                                               (line   6)
 * gmpxx.h:                               C++ Interface General.
                                                               (line   8)
-* GNU Debugger:                          Debugging.           (line  58)
+* GNU Debugger:                          Debugging.           (line  57)
 * GNU Free Documentation License:        GNU Free Documentation License.
                                                               (line   6)
 * GNU strip:                             Known Build Problems.
@@ -9492,40 +9441,41 @@ Concept Index
                                                               (line  34)
 * Headers:                               Headers and Libraries.
                                                               (line   6)
-* Heap problems:                         Debugging.           (line  24)
-* Home page:                             Introduction to GMP. (line  34)
-* Host system:                           Build Options.       (line  66)
+* Heap problems:                         Debugging.           (line  23)
+* Home page:                             Introduction to GMP. (line  33)
+* Host system:                           Build Options.       (line  65)
 * HP-UX:                                 ABI and ISA.         (line  68)
+* HP-UX <1>:                             ABI and ISA.         (line 106)
 * HPPA:                                  ABI and ISA.         (line  68)
-* I/O functions <1>:                     I/O of Floats.       (line   6)
-* I/O functions <2>:                     I/O of Rationals.    (line   6)
 * I/O functions:                         I/O of Integers.     (line   6)
+* I/O functions <1>:                     I/O of Rationals.    (line   6)
+* I/O functions <2>:                     I/O of Floats.       (line   6)
 * i386:                                  Notes for Particular Systems.
                                                               (line 126)
-* IA-64:                                 ABI and ISA.         (line 107)
+* IA-64:                                 ABI and ISA.         (line 106)
 * Import:                                Integer Import and Export.
                                                               (line  11)
 * In-place operations:                   Efficiency.          (line  57)
 * Include files:                         Headers and Libraries.
                                                               (line   6)
 * info-lookup-symbol:                    Emacs.               (line   6)
-* Initialization functions <1>:          Random State Initialization.
+* Initialization functions:              Initializing Integers.
                                                               (line   6)
-* Initialization functions <2>:          Simultaneous Float Init & Assign.
+* Initialization functions <1>:          Simultaneous Integer Init & Assign.
                                                               (line   6)
-* Initialization functions <3>:          Initializing Floats. (line   6)
-* Initialization functions <4>:          Initializing Rationals.
+* Initialization functions <2>:          Initializing Rationals.
                                                               (line   6)
-* Initialization functions <5>:          Simultaneous Integer Init & Assign.
+* Initialization functions <3>:          Initializing Floats. (line   6)
+* Initialization functions <4>:          Simultaneous Float Init & Assign.
                                                               (line   6)
-* Initialization functions:              Initializing Integers.
+* Initialization functions <5>:          Random State Initialization.
                                                               (line   6)
 * Initializing and clearing:             Efficiency.          (line  21)
-* Input functions <1>:                   Formatted Input Functions.
-                                                              (line   6)
-* Input functions <2>:                   I/O of Floats.       (line   6)
-* Input functions <3>:                   I/O of Rationals.    (line   6)
 * Input functions:                       I/O of Integers.     (line   6)
+* Input functions <1>:                   I/O of Rationals.    (line   6)
+* Input functions <2>:                   I/O of Floats.       (line   6)
+* Input functions <3>:                   Formatted Input Functions.
+                                                              (line   6)
 * Install prefix:                        Build Options.       (line  32)
 * Installing GMP:                        Installing GMP.      (line   6)
 * Instruction Set Architecture:          ABI and ISA.         (line   6)
@@ -9533,9 +9483,9 @@ Concept Index
 * Integer:                               Nomenclature and Types.
                                                               (line   6)
 * Integer arithmetic functions:          Integer Arithmetic.  (line   6)
+* Integer assignment functions:          Assigning Integers.  (line   6)
 * Integer assignment functions <1>:      Simultaneous Integer Init & Assign.
                                                               (line   6)
-* Integer assignment functions:          Assigning Integers.  (line   6)
 * Integer bit manipulation functions:    Integer Logic and Bit Fiddling.
                                                               (line   6)
 * Integer comparison functions:          Integer Comparisons. (line   6)
@@ -9548,10 +9498,10 @@ Concept Index
 * Integer functions:                     Integer Functions.   (line   6)
 * Integer import:                        Integer Import and Export.
                                                               (line  11)
-* Integer initialization functions <1>:  Simultaneous Integer Init & Assign.
-                                                              (line   6)
 * Integer initialization functions:      Initializing Integers.
                                                               (line   6)
+* Integer initialization functions <1>:  Simultaneous Integer Init & Assign.
+                                                              (line   6)
 * Integer input and output functions:    I/O of Integers.     (line   6)
 * Integer internals:                     Integer Internals.   (line   6)
 * Integer logical functions:             Integer Logic and Bit Fiddling.
@@ -9570,9 +9520,9 @@ Concept Index
 * Introduction:                          Introduction to GMP. (line   6)
 * Inverse modulo functions:              Number Theoretic Functions.
                                                               (line  60)
+* IRIX:                                  ABI and ISA.         (line 131)
 * IRIX <1>:                              Known Build Problems.
                                                               (line  38)
-* IRIX:                                  ABI and ISA.         (line 132)
 * ISA:                                   ABI and ISA.         (line   6)
 * istream input:                         C++ Formatted Input. (line   6)
 * Jacobi symbol algorithm:               Jacobi Symbol.       (line   6)
@@ -9585,7 +9535,7 @@ Concept Index
 * Kronecker symbol functions:            Number Theoretic Functions.
                                                               (line  78)
 * Language bindings:                     Language Bindings.   (line   6)
-* Latest version of GMP:                 Introduction to GMP. (line  38)
+* Latest version of GMP:                 Introduction to GMP. (line  37)
 * LCM functions:                         Number Theoretic Functions.
                                                               (line  55)
 * Least common multiple functions:       Number Theoretic Functions.
@@ -9610,7 +9560,9 @@ Concept Index
 * Linear congruential algorithm:         Random Number Algorithms.
                                                               (line  25)
 * Linear congruential random numbers:    Random State Initialization.
-                                                              (line  18)
+                                                              (line  19)
+* Linear congruential random numbers <1>: Random State Initialization.
+                                                              (line  33)
 * Linking:                               Headers and Libraries.
                                                               (line  22)
 * Logical functions:                     Integer Logic and Bit Fiddling.
@@ -9622,9 +9574,9 @@ Concept Index
                                                               (line 119)
 * MacOS X:                               Known Build Problems.
                                                               (line  51)
-* Mailing lists:                         Introduction to GMP. (line  45)
-* Malloc debugger:                       Debugging.           (line  30)
-* Malloc problems:                       Debugging.           (line  24)
+* Mailing lists:                         Introduction to GMP. (line  44)
+* Malloc debugger:                       Debugging.           (line  29)
+* Malloc problems:                       Debugging.           (line  23)
 * Memory allocation:                     Custom Allocation.   (line   6)
 * Memory management:                     Memory Management.   (line   6)
 * Mersenne twister algorithm:            Random Number Algorithms.
@@ -9633,7 +9585,7 @@ Concept Index
                                                               (line  13)
 * MINGW:                                 Notes for Particular Systems.
                                                               (line  43)
-* MIPS:                                  ABI and ISA.         (line 132)
+* MIPS:                                  ABI and ISA.         (line 131)
 * Miscellaneous float functions:         Miscellaneous Float Functions.
                                                               (line   6)
 * Miscellaneous integer functions:       Miscellaneous Integer Functions.
@@ -9646,16 +9598,18 @@ Concept Index
                                                               (line  34)
 * mp.h:                                  BSD Compatible Functions.
                                                               (line  21)
-* MPN_PATH:                              Build Options.       (line 335)
+* MPN_PATH:                              Build Options.       (line 329)
 * MS Windows:                            Notes for Particular Systems.
                                                               (line  43)
+* MS Windows <1>:                        Notes for Particular Systems.
+                                                              (line  56)
 * MS-DOS:                                Notes for Particular Systems.
                                                               (line  43)
 * Multi-threading:                       Reentrancy.          (line   6)
 * Multiplication algorithms:             Multiplication Algorithms.
                                                               (line   6)
 * Nails:                                 Low-level Functions. (line 479)
-* Native compilation:                    Build Options.       (line  52)
+* Native compilation:                    Build Options.       (line  51)
 * NeXT:                                  Known Build Problems.
                                                               (line  57)
 * Next prime function:                   Number Theoretic Functions.
@@ -9664,13 +9618,13 @@ Concept Index
                                                               (line   6)
 * Non-Unix systems:                      Build Options.       (line  11)
 * Nth root algorithm:                    Nth Root Algorithm.  (line   6)
-* Number sequences:                      Efficiency.          (line 147)
+* Number sequences:                      Efficiency.          (line 145)
 * Number theoretic functions:            Number Theoretic Functions.
                                                               (line   6)
 * Numerator and denominator:             Applying Integer Functions.
                                                               (line   6)
 * obstack output:                        Formatted Output Functions.
-                                                              (line  81)
+                                                              (line  79)
 * OpenBSD:                               Notes for Particular Systems.
                                                               (line  86)
 * Optimizing performance:                Performance optimization.
@@ -9678,22 +9632,26 @@ Concept Index
 * ostream output:                        C++ Formatted Output.
                                                               (line   6)
 * Other languages:                       Language Bindings.   (line   6)
-* Output functions <1>:                  Formatted Output Functions.
-                                                              (line   6)
-* Output functions <2>:                  I/O of Floats.       (line   6)
-* Output functions <3>:                  I/O of Rationals.    (line   6)
 * Output functions:                      I/O of Integers.     (line   6)
+* Output functions <1>:                  I/O of Rationals.    (line   6)
+* Output functions <2>:                  I/O of Floats.       (line   6)
+* Output functions <3>:                  Formatted Output Functions.
+                                                              (line   6)
 * Packaged builds:                       Notes for Package Builds.
                                                               (line   6)
 * Parameter conventions:                 Parameter Conventions.
                                                               (line   6)
 * Parsing expressions demo:              Demonstration Programs.
                                                               (line  15)
+* Parsing expressions demo <1>:          Demonstration Programs.
+                                                              (line  17)
+* Parsing expressions demo <2>:          Demonstration Programs.
+                                                              (line  19)
 * Particular systems:                    Notes for Particular Systems.
                                                               (line   6)
 * Past GMP versions:                     Compatibility with older versions.
                                                               (line   6)
-* PDF:                                   Build Options.       (line 350)
+* PDF:                                   Build Options.       (line 344)
 * Perfect power algorithm:               Perfect Power Algorithm.
                                                               (line   6)
 * Perfect power functions:               Integer Roots.       (line  27)
@@ -9701,19 +9659,19 @@ Concept Index
                                                               (line   6)
 * Perfect square functions:              Integer Roots.       (line  36)
 * perl:                                  Demonstration Programs.
-                                                              (line  35)
+                                                              (line  28)
 * Perl module:                           Demonstration Programs.
-                                                              (line  35)
-* Postscript:                            Build Options.       (line 350)
-* Power/PowerPC <1>:                     Known Build Problems.
-                                                              (line  63)
+                                                              (line  28)
+* Postscript:                            Build Options.       (line 344)
 * Power/PowerPC:                         Notes for Particular Systems.
                                                               (line  92)
+* Power/PowerPC <1>:                     Known Build Problems.
+                                                              (line  63)
 * Powering algorithms:                   Powering Algorithms. (line   6)
-* Powering functions <1>:                Float Arithmetic.    (line  41)
 * Powering functions:                    Integer Exponentiation.
                                                               (line   6)
-* PowerPC:                               ABI and ISA.         (line 167)
+* Powering functions <1>:                Float Arithmetic.    (line  41)
+* PowerPC:                               ABI and ISA.         (line 165)
 * Precision of floats:                   Floating-point Functions.
                                                               (line   6)
 * Precision of hardware floating point:  Notes for Particular Systems.
@@ -9732,11 +9690,11 @@ Concept Index
                                                               (line   6)
 * Random number algorithms:              Random Number Algorithms.
                                                               (line   6)
-* Random number functions <1>:           Random Number Functions.
+* Random number functions:               Integer Random Numbers.
                                                               (line   6)
-* Random number functions <2>:           Miscellaneous Float Functions.
+* Random number functions <1>:           Miscellaneous Float Functions.
                                                               (line  27)
-* Random number functions:               Integer Random Numbers.
+* Random number functions <2>:           Random Number Functions.
                                                               (line   6)
 * Random number seeding:                 Random State Seeding.
                                                               (line   6)
@@ -9744,7 +9702,7 @@ Concept Index
                                                               (line   6)
 * Random state:                          Nomenclature and Types.
                                                               (line  46)
-* Rational arithmetic:                   Efficiency.          (line 113)
+* Rational arithmetic:                   Efficiency.          (line 111)
 * Rational arithmetic functions:         Rational Arithmetic. (line   6)
 * Rational assignment functions:         Initializing Rationals.
                                                               (line   6)
@@ -9766,22 +9724,23 @@ Concept Index
                                                               (line   6)
 * Reallocations:                         Efficiency.          (line  30)
 * Reentrancy:                            Reentrancy.          (line   6)
-* References:                            References.          (line   6)
+* References:                            References.          (line   5)
 * Remove factor functions:               Number Theoretic Functions.
                                                               (line  90)
 * Reporting bugs:                        Reporting Bugs.      (line   6)
 * Root extraction algorithm:             Nth Root Algorithm.  (line   6)
 * Root extraction algorithms:            Root Extraction Algorithms.
                                                               (line   6)
-* Root extraction functions <1>:         Float Arithmetic.    (line  37)
 * Root extraction functions:             Integer Roots.       (line   6)
+* Root extraction functions <1>:         Float Arithmetic.    (line  37)
 * Root testing functions:                Integer Roots.       (line  27)
+* Root testing functions <1>:            Integer Roots.       (line  36)
 * Rounding functions:                    Miscellaneous Float Functions.
                                                               (line   9)
 * Sample programs:                       Demonstration Programs.
                                                               (line   6)
 * Scan bit functions:                    Integer Logic and Bit Fiddling.
-                                                              (line  38)
+                                                              (line  37)
 * scanf formatted input:                 Formatted Input.     (line   6)
 * SCO:                                   Known Build Problems.
                                                               (line  38)
@@ -9794,27 +9753,31 @@ Concept Index
                                                               (line  51)
 * Shared library versioning:             Notes for Package Builds.
                                                               (line   9)
-* Sign tests <1>:                        Float Comparison.    (line  33)
-* Sign tests <2>:                        Comparing Rationals. (line  27)
 * Sign tests:                            Integer Comparisons. (line  28)
+* Sign tests <1>:                        Comparing Rationals. (line  27)
+* Sign tests <2>:                        Float Comparison.    (line  33)
 * Size in digits:                        Miscellaneous Integer Functions.
                                                               (line  23)
 * Small operands:                        Efficiency.          (line   7)
+* Solaris:                               ABI and ISA.         (line 198)
 * Solaris <1>:                           Known Build Problems.
                                                               (line  72)
-* Solaris:                               ABI and ISA.         (line 201)
+* Solaris <2>:                           Known Build Problems.
+                                                              (line  77)
 * Sparc:                                 Notes for Particular Systems.
                                                               (line 103)
-* Sparc V9:                              ABI and ISA.         (line 201)
+* Sparc <1>:                             Notes for Particular Systems.
+                                                              (line 108)
+* Sparc V9:                              ABI and ISA.         (line 198)
 * Special integer functions:             Integer Special Functions.
                                                               (line   6)
 * Square root algorithm:                 Square Root Algorithm.
                                                               (line   6)
 * SSE2:                                  Notes for Particular Systems.
                                                               (line 132)
-* Stack backtrace:                       Debugging.           (line  50)
+* Stack backtrace:                       Debugging.           (line  49)
+* Stack overflow:                        Build Options.       (line 277)
 * Stack overflow <1>:                    Debugging.           (line   7)
-* Stack overflow:                        Build Options.       (line 278)
 * Static linking:                        Efficiency.          (line  14)
 * stdarg.h:                              Headers and Libraries.
                                                               (line  17)
@@ -9822,20 +9785,20 @@ Concept Index
                                                               (line  11)
 * Stripped libraries:                    Known Build Problems.
                                                               (line  28)
-* Sun:                                   ABI and ISA.         (line 201)
+* Sun:                                   ABI and ISA.         (line 198)
 * SunOS:                                 Notes for Particular Systems.
                                                               (line 120)
 * Systems:                               Notes for Particular Systems.
                                                               (line   6)
-* Temporary memory:                      Build Options.       (line 278)
-* Texinfo:                               Build Options.       (line 347)
-* Text input/output:                     Efficiency.          (line 153)
+* Temporary memory:                      Build Options.       (line 277)
+* Texinfo:                               Build Options.       (line 341)
+* Text input/output:                     Efficiency.          (line 151)
 * Thread safety:                         Reentrancy.          (line   6)
-* Toom multiplication <1>:               Other Multiplication.
+* Toom multiplication:                   Toom 3-Way Multiplication.
                                                               (line   6)
-* Toom multiplication <2>:               Toom 4-Way Multiplication.
+* Toom multiplication <1>:               Toom 4-Way Multiplication.
                                                               (line   6)
-* Toom multiplication:                   Toom 3-Way Multiplication.
+* Toom multiplication <2>:               Other Multiplication.
                                                               (line   6)
 * Types:                                 Nomenclature and Types.
                                                               (line   6)
@@ -9848,19 +9811,21 @@ Concept Index
                                                               (line   6)
 * User-defined precision:                Floating-point Functions.
                                                               (line   6)
-* Valgrind:                              Debugging.           (line 130)
+* Valgrind:                              Debugging.           (line 129)
 * Variable conventions:                  Variable Conventions.
                                                               (line   6)
 * Version number:                        Useful Macros and Constants.
                                                               (line  12)
-* Web page:                              Introduction to GMP. (line  34)
+* Web page:                              Introduction to GMP. (line  33)
 * Windows:                               Notes for Particular Systems.
                                                               (line  43)
+* Windows <1>:                           Notes for Particular Systems.
+                                                              (line  56)
 * x86:                                   Notes for Particular Systems.
                                                               (line 126)
 * x87:                                   Notes for Particular Systems.
                                                               (line  34)
-* XML:                                   Build Options.       (line 354)
+* XML:                                   Build Options.       (line 348)
 
 
 File: gmp.info,  Node: Function Index,  Prev: Concept Index,  Up: Top
@@ -9871,165 +9836,167 @@ Function and Type Index
  [index ]
 * Menu:
 
+* _mpz_realloc:                          Integer Special Functions.
+                                                              (line  50)
 * __GMP_CC:                              Useful Macros and Constants.
-                                                              (line  23)
+                                                              (line  22)
 * __GMP_CFLAGS:                          Useful Macros and Constants.
-                                                              (line  24)
+                                                              (line  23)
 * __GNU_MP_VERSION:                      Useful Macros and Constants.
-                                                              (line  10)
+                                                              (line   9)
 * __GNU_MP_VERSION_MINOR:                Useful Macros and Constants.
-                                                              (line  11)
+                                                              (line  10)
 * __GNU_MP_VERSION_PATCHLEVEL:           Useful Macros and Constants.
-                                                              (line  12)
-* _mpz_realloc:                          Integer Special Functions.
-                                                              (line  51)
-* abs <1>:                               C++ Interface Floats.
+                                                              (line  11)
+* abs:                                   C++ Interface Integers.
+                                                              (line  41)
+* abs <1>:                               C++ Interface Rationals.
+                                                              (line  41)
+* abs <2>:                               C++ Interface Floats.
+                                                              (line  78)
+* ceil:                                  C++ Interface Floats.
                                                               (line  79)
-* abs <2>:                               C++ Interface Rationals.
+* cmp:                                   C++ Interface Integers.
+                                                              (line  42)
+* cmp <1>:                               C++ Interface Integers.
                                                               (line  43)
-* abs:                                   C++ Interface Integers.
+* cmp <2>:                               C++ Interface Rationals.
                                                               (line  42)
-* ceil:                                  C++ Interface Floats.
+* cmp <3>:                               C++ Interface Rationals.
+                                                              (line  43)
+* cmp <4>:                               C++ Interface Floats.
                                                               (line  80)
-* cmp <1>:                               C++ Interface Floats.
+* cmp <5>:                               C++ Interface Floats.
                                                               (line  81)
-* cmp <2>:                               C++ Interface Rationals.
-                                                              (line  44)
-* cmp:                                   C++ Interface Integers.
-                                                              (line  43)
 * floor:                                 C++ Interface Floats.
-                                                              (line  89)
+                                                              (line  91)
 * gcd:                                   BSD Compatible Functions.
-                                                              (line  82)
+                                                              (line  81)
 * gmp_asprintf:                          Formatted Output Functions.
-                                                              (line  65)
+                                                              (line  63)
 * gmp_errno:                             Random State Initialization.
-                                                              (line  55)
+                                                              (line  57)
 * GMP_ERROR_INVALID_ARGUMENT:            Random State Initialization.
-                                                              (line  55)
+                                                              (line  57)
 * GMP_ERROR_UNSUPPORTED_ARGUMENT:        Random State Initialization.
-                                                              (line  55)
+                                                              (line  57)
 * gmp_fprintf:                           Formatted Output Functions.
-                                                              (line  29)
+                                                              (line  28)
 * gmp_fscanf:                            Formatted Input Functions.
-                                                              (line  25)
-* GMP_LIMB_BITS:                         Low-level Functions. (line 509)
-* GMP_NAIL_BITS:                         Low-level Functions. (line 507)
-* GMP_NAIL_MASK:                         Low-level Functions. (line 517)
-* GMP_NUMB_BITS:                         Low-level Functions. (line 508)
-* GMP_NUMB_MASK:                         Low-level Functions. (line 518)
-* GMP_NUMB_MAX:                          Low-level Functions. (line 526)
+                                                              (line  24)
+* GMP_LIMB_BITS:                         Low-level Functions. (line 507)
+* GMP_NAIL_BITS:                         Low-level Functions. (line 505)
+* GMP_NAIL_MASK:                         Low-level Functions. (line 515)
+* GMP_NUMB_BITS:                         Low-level Functions. (line 506)
+* GMP_NUMB_MASK:                         Low-level Functions. (line 516)
+* GMP_NUMB_MAX:                          Low-level Functions. (line 524)
 * gmp_obstack_printf:                    Formatted Output Functions.
-                                                              (line  79)
+                                                              (line  75)
 * gmp_obstack_vprintf:                   Formatted Output Functions.
-                                                              (line  81)
+                                                              (line  77)
 * gmp_printf:                            Formatted Output Functions.
-                                                              (line  24)
-* GMP_RAND_ALG_DEFAULT:                  Random State Initialization.
-                                                              (line  49)
-* GMP_RAND_ALG_LC:                       Random State Initialization.
-                                                              (line  49)
+                                                              (line  23)
 * gmp_randclass:                         C++ Interface Random Numbers.
-                                                              (line   7)
+                                                              (line   6)
 * gmp_randclass::get_f:                  C++ Interface Random Numbers.
+                                                              (line  44)
+* gmp_randclass::get_f <1>:              C++ Interface Random Numbers.
                                                               (line  45)
 * gmp_randclass::get_z_bits:             C++ Interface Random Numbers.
+                                                              (line  37)
+* gmp_randclass::get_z_bits <1>:         C++ Interface Random Numbers.
                                                               (line  38)
 * gmp_randclass::get_z_range:            C++ Interface Random Numbers.
-                                                              (line  42)
+                                                              (line  41)
 * gmp_randclass::gmp_randclass:          C++ Interface Random Numbers.
-                                                              (line  13)
+                                                              (line  11)
+* gmp_randclass::gmp_randclass <1>:      C++ Interface Random Numbers.
+                                                              (line  26)
 * gmp_randclass::seed:                   C++ Interface Random Numbers.
+                                                              (line  32)
+* gmp_randclass::seed <1>:               C++ Interface Random Numbers.
                                                               (line  33)
 * gmp_randclear:                         Random State Initialization.
-                                                              (line  62)
+                                                              (line  63)
 * gmp_randinit:                          Random State Initialization.
-                                                              (line  47)
+                                                              (line  46)
 * gmp_randinit_default:                  Random State Initialization.
-                                                              (line   7)
+                                                              (line   6)
 * gmp_randinit_lc_2exp:                  Random State Initialization.
-                                                              (line  18)
+                                                              (line  16)
 * gmp_randinit_lc_2exp_size:             Random State Initialization.
-                                                              (line  32)
+                                                              (line  31)
 * gmp_randinit_mt:                       Random State Initialization.
-                                                              (line  13)
+                                                              (line  12)
 * gmp_randinit_set:                      Random State Initialization.
-                                                              (line  43)
+                                                              (line  42)
 * gmp_randseed:                          Random State Seeding.
-                                                              (line   7)
+                                                              (line   6)
 * gmp_randseed_ui:                       Random State Seeding.
-                                                              (line   9)
+                                                              (line   7)
 * gmp_randstate_t:                       Nomenclature and Types.
                                                               (line  46)
+* GMP_RAND_ALG_DEFAULT:                  Random State Initialization.
+                                                              (line  51)
+* GMP_RAND_ALG_LC:                       Random State Initialization.
+                                                              (line  51)
 * gmp_scanf:                             Formatted Input Functions.
-                                                              (line  21)
+                                                              (line  20)
 * gmp_snprintf:                          Formatted Output Functions.
-                                                              (line  46)
+                                                              (line  44)
 * gmp_sprintf:                           Formatted Output Functions.
-                                                              (line  34)
+                                                              (line  33)
 * gmp_sscanf:                            Formatted Input Functions.
-                                                              (line  29)
+                                                              (line  28)
 * gmp_urandomb_ui:                       Random State Miscellaneous.
-                                                              (line   8)
+                                                              (line   6)
 * gmp_urandomm_ui:                       Random State Miscellaneous.
-                                                              (line  14)
+                                                              (line  12)
 * gmp_vasprintf:                         Formatted Output Functions.
-                                                              (line  66)
+                                                              (line  64)
 * gmp_version:                           Useful Macros and Constants.
                                                               (line  18)
 * gmp_vfprintf:                          Formatted Output Functions.
-                                                              (line  30)
+                                                              (line  29)
 * gmp_vfscanf:                           Formatted Input Functions.
-                                                              (line  26)
-* gmp_vprintf:                           Formatted Output Functions.
                                                               (line  25)
+* gmp_vprintf:                           Formatted Output Functions.
+                                                              (line  24)
 * gmp_vscanf:                            Formatted Input Functions.
-                                                              (line  22)
+                                                              (line  21)
 * gmp_vsnprintf:                         Formatted Output Functions.
-                                                              (line  48)
+                                                              (line  46)
 * gmp_vsprintf:                          Formatted Output Functions.
-                                                              (line  35)
+                                                              (line  34)
 * gmp_vsscanf:                           Formatted Input Functions.
-                                                              (line  31)
+                                                              (line  29)
 * hypot:                                 C++ Interface Floats.
-                                                              (line  90)
+                                                              (line  92)
 * itom:                                  BSD Compatible Functions.
-                                                              (line  29)
+                                                              (line  28)
 * madd:                                  BSD Compatible Functions.
-                                                              (line  43)
+                                                              (line  42)
 * mcmp:                                  BSD Compatible Functions.
-                                                              (line  85)
+                                                              (line  84)
 * mdiv:                                  BSD Compatible Functions.
-                                                              (line  53)
+                                                              (line  51)
 * mfree:                                 BSD Compatible Functions.
-                                                              (line 105)
+                                                              (line 104)
 * min:                                   BSD Compatible Functions.
-                                                              (line  89)
+                                                              (line  88)
 * MINT:                                  BSD Compatible Functions.
                                                               (line  21)
 * mout:                                  BSD Compatible Functions.
-                                                              (line  94)
+                                                              (line  93)
 * move:                                  BSD Compatible Functions.
-                                                              (line  39)
-* mp_bitcnt_t:                           Nomenclature and Types.
-                                                              (line  42)
-* mp_bits_per_limb:                      Useful Macros and Constants.
-                                                              (line   7)
-* mp_exp_t:                              Nomenclature and Types.
-                                                              (line  27)
-* mp_get_memory_functions:               Custom Allocation.   (line  93)
-* mp_limb_t:                             Nomenclature and Types.
-                                                              (line  31)
-* mp_set_memory_functions:               Custom Allocation.   (line  21)
-* mp_size_t:                             Nomenclature and Types.
-                                                              (line  37)
-* mpf_abs:                               Float Arithmetic.    (line  47)
-* mpf_add:                               Float Arithmetic.    (line   7)
-* mpf_add_ui:                            Float Arithmetic.    (line   9)
+                                                              (line  38)
+* mpf_abs:                               Float Arithmetic.    (line  46)
+* mpf_add:                               Float Arithmetic.    (line   6)
+* mpf_add_ui:                            Float Arithmetic.    (line   7)
 * mpf_ceil:                              Miscellaneous Float Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpf_class:                             C++ Interface General.
-                                                              (line  20)
+                                                              (line  19)
 * mpf_class::fits_sint_p:                C++ Interface Floats.
                                                               (line  83)
 * mpf_class::fits_slong_p:               C++ Interface Floats.
@@ -10037,268 +10004,294 @@ Function and Type Index
 * mpf_class::fits_sshort_p:              C++ Interface Floats.
                                                               (line  85)
 * mpf_class::fits_uint_p:                C++ Interface Floats.
-                                                              (line  86)
-* mpf_class::fits_ulong_p:               C++ Interface Floats.
                                                               (line  87)
-* mpf_class::fits_ushort_p:              C++ Interface Floats.
+* mpf_class::fits_ulong_p:               C++ Interface Floats.
                                                               (line  88)
+* mpf_class::fits_ushort_p:              C++ Interface Floats.
+                                                              (line  89)
 * mpf_class::get_d:                      C++ Interface Floats.
-                                                              (line  91)
+                                                              (line  94)
 * mpf_class::get_mpf_t:                  C++ Interface General.
-                                                              (line  66)
+                                                              (line  65)
 * mpf_class::get_prec:                   C++ Interface Floats.
-                                                              (line 109)
+                                                              (line 113)
 * mpf_class::get_si:                     C++ Interface Floats.
-                                                              (line  92)
+                                                              (line  95)
 * mpf_class::get_str:                    C++ Interface Floats.
-                                                              (line  94)
+                                                              (line  96)
 * mpf_class::get_ui:                     C++ Interface Floats.
-                                                              (line  95)
+                                                              (line  98)
 * mpf_class::mpf_class:                  C++ Interface Floats.
+                                                              (line  11)
+* mpf_class::mpf_class <1>:              C++ Interface Floats.
                                                               (line  12)
+* mpf_class::mpf_class <2>:              C++ Interface Floats.
+                                                              (line  32)
+* mpf_class::mpf_class <3>:              C++ Interface Floats.
+                                                              (line  33)
+* mpf_class::mpf_class <4>:              C++ Interface Floats.
+                                                              (line  41)
+* mpf_class::mpf_class <5>:              C++ Interface Floats.
+                                                              (line  42)
+* mpf_class::mpf_class <6>:              C++ Interface Floats.
+                                                              (line  44)
+* mpf_class::mpf_class <7>:              C++ Interface Floats.
+                                                              (line  45)
 * mpf_class::operator=:                  C++ Interface Floats.
-                                                              (line  56)
+                                                              (line  55)
 * mpf_class::set_prec:                   C++ Interface Floats.
-                                                              (line 110)
+                                                              (line 114)
 * mpf_class::set_prec_raw:               C++ Interface Floats.
-                                                              (line 111)
+                                                              (line 115)
 * mpf_class::set_str:                    C++ Interface Floats.
-                                                              (line  96)
-* mpf_clear:                             Initializing Floats. (line  37)
-* mpf_clears:                            Initializing Floats. (line  41)
-* mpf_cmp:                               Float Comparison.    (line   7)
-* mpf_cmp_d:                             Float Comparison.    (line   8)
-* mpf_cmp_si:                            Float Comparison.    (line  10)
-* mpf_cmp_ui:                            Float Comparison.    (line   9)
-* mpf_div:                               Float Arithmetic.    (line  29)
-* mpf_div_2exp:                          Float Arithmetic.    (line  53)
-* mpf_div_ui:                            Float Arithmetic.    (line  33)
-* mpf_eq:                                Float Comparison.    (line  17)
+                                                              (line 100)
+* mpf_class::set_str <1>:                C++ Interface Floats.
+                                                              (line 101)
+* mpf_clear:                             Initializing Floats. (line  36)
+* mpf_clears:                            Initializing Floats. (line  40)
+* mpf_cmp:                               Float Comparison.    (line   6)
+* mpf_cmp_d:                             Float Comparison.    (line   7)
+* mpf_cmp_si:                            Float Comparison.    (line   9)
+* mpf_cmp_ui:                            Float Comparison.    (line   8)
+* mpf_div:                               Float Arithmetic.    (line  28)
+* mpf_div_2exp:                          Float Arithmetic.    (line  52)
+* mpf_div_ui:                            Float Arithmetic.    (line  31)
+* mpf_eq:                                Float Comparison.    (line  16)
 * mpf_fits_sint_p:                       Miscellaneous Float Functions.
-                                                              (line  20)
+                                                              (line  19)
 * mpf_fits_slong_p:                      Miscellaneous Float Functions.
-                                                              (line  18)
+                                                              (line  17)
 * mpf_fits_sshort_p:                     Miscellaneous Float Functions.
-                                                              (line  22)
+                                                              (line  21)
 * mpf_fits_uint_p:                       Miscellaneous Float Functions.
-                                                              (line  19)
+                                                              (line  18)
 * mpf_fits_ulong_p:                      Miscellaneous Float Functions.
-                                                              (line  17)
+                                                              (line  16)
 * mpf_fits_ushort_p:                     Miscellaneous Float Functions.
-                                                              (line  21)
+                                                              (line  20)
 * mpf_floor:                             Miscellaneous Float Functions.
-                                                              (line   8)
-* mpf_get_d:                             Converting Floats.   (line   7)
-* mpf_get_d_2exp:                        Converting Floats.   (line  16)
-* mpf_get_default_prec:                  Initializing Floats. (line  12)
-* mpf_get_prec:                          Initializing Floats. (line  62)
-* mpf_get_si:                            Converting Floats.   (line  27)
-* mpf_get_str:                           Converting Floats.   (line  37)
-* mpf_get_ui:                            Converting Floats.   (line  28)
-* mpf_init:                              Initializing Floats. (line  19)
-* mpf_init2:                             Initializing Floats. (line  26)
+                                                              (line   7)
+* mpf_get_d:                             Converting Floats.   (line   6)
+* mpf_get_default_prec:                  Initializing Floats. (line  11)
+* mpf_get_d_2exp:                        Converting Floats.   (line  15)
+* mpf_get_prec:                          Initializing Floats. (line  61)
+* mpf_get_si:                            Converting Floats.   (line  26)
+* mpf_get_str:                           Converting Floats.   (line  35)
+* mpf_get_ui:                            Converting Floats.   (line  27)
+* mpf_init:                              Initializing Floats. (line  18)
+* mpf_init2:                             Initializing Floats. (line  25)
+* mpf_inits:                             Initializing Floats. (line  30)
 * mpf_init_set:                          Simultaneous Float Init & Assign.
-                                                              (line  16)
+                                                              (line  15)
 * mpf_init_set_d:                        Simultaneous Float Init & Assign.
-                                                              (line  19)
-* mpf_init_set_si:                       Simultaneous Float Init & Assign.
                                                               (line  18)
+* mpf_init_set_si:                       Simultaneous Float Init & Assign.
+                                                              (line  17)
 * mpf_init_set_str:                      Simultaneous Float Init & Assign.
-                                                              (line  25)
+                                                              (line  24)
 * mpf_init_set_ui:                       Simultaneous Float Init & Assign.
-                                                              (line  17)
-* mpf_inits:                             Initializing Floats. (line  31)
-* mpf_inp_str:                           I/O of Floats.       (line  39)
+                                                              (line  16)
+* mpf_inp_str:                           I/O of Floats.       (line  38)
 * mpf_integer_p:                         Miscellaneous Float Functions.
-                                                              (line  14)
-* mpf_mul:                               Float Arithmetic.    (line  19)
-* mpf_mul_2exp:                          Float Arithmetic.    (line  50)
-* mpf_mul_ui:                            Float Arithmetic.    (line  21)
-* mpf_neg:                               Float Arithmetic.    (line  44)
-* mpf_out_str:                           I/O of Floats.       (line  19)
-* mpf_pow_ui:                            Float Arithmetic.    (line  41)
+                                                              (line  13)
+* mpf_mul:                               Float Arithmetic.    (line  18)
+* mpf_mul_2exp:                          Float Arithmetic.    (line  49)
+* mpf_mul_ui:                            Float Arithmetic.    (line  19)
+* mpf_neg:                               Float Arithmetic.    (line  43)
+* mpf_out_str:                           I/O of Floats.       (line  17)
+* mpf_pow_ui:                            Float Arithmetic.    (line  39)
 * mpf_random2:                           Miscellaneous Float Functions.
-                                                              (line  37)
-* mpf_reldiff:                           Float Comparison.    (line  29)
-* mpf_set:                               Assigning Floats.    (line  10)
-* mpf_set_d:                             Assigning Floats.    (line  13)
-* mpf_set_default_prec:                  Initializing Floats. (line   7)
-* mpf_set_prec:                          Initializing Floats. (line  65)
-* mpf_set_prec_raw:                      Initializing Floats. (line  72)
-* mpf_set_q:                             Assigning Floats.    (line  15)
-* mpf_set_si:                            Assigning Floats.    (line  12)
-* mpf_set_str:                           Assigning Floats.    (line  18)
-* mpf_set_ui:                            Assigning Floats.    (line  11)
-* mpf_set_z:                             Assigning Floats.    (line  14)
-* mpf_sgn:                               Float Comparison.    (line  33)
-* mpf_sqrt:                              Float Arithmetic.    (line  36)
-* mpf_sqrt_ui:                           Float Arithmetic.    (line  37)
-* mpf_sub:                               Float Arithmetic.    (line  12)
-* mpf_sub_ui:                            Float Arithmetic.    (line  16)
-* mpf_swap:                              Assigning Floats.    (line  52)
+                                                              (line  35)
+* mpf_reldiff:                           Float Comparison.    (line  28)
+* mpf_set:                               Assigning Floats.    (line   9)
+* mpf_set_d:                             Assigning Floats.    (line  12)
+* mpf_set_default_prec:                  Initializing Floats. (line   6)
+* mpf_set_prec:                          Initializing Floats. (line  64)
+* mpf_set_prec_raw:                      Initializing Floats. (line  71)
+* mpf_set_q:                             Assigning Floats.    (line  14)
+* mpf_set_si:                            Assigning Floats.    (line  11)
+* mpf_set_str:                           Assigning Floats.    (line  17)
+* mpf_set_ui:                            Assigning Floats.    (line  10)
+* mpf_set_z:                             Assigning Floats.    (line  13)
+* mpf_sgn:                               Float Comparison.    (line  32)
+* mpf_sqrt:                              Float Arithmetic.    (line  35)
+* mpf_sqrt_ui:                           Float Arithmetic.    (line  36)
+* mpf_sub:                               Float Arithmetic.    (line  11)
+* mpf_sub_ui:                            Float Arithmetic.    (line  14)
+* mpf_swap:                              Assigning Floats.    (line  50)
 * mpf_t:                                 Nomenclature and Types.
                                                               (line  21)
 * mpf_trunc:                             Miscellaneous Float Functions.
-                                                              (line   9)
-* mpf_ui_div:                            Float Arithmetic.    (line  31)
-* mpf_ui_sub:                            Float Arithmetic.    (line  14)
+                                                              (line   8)
+* mpf_ui_div:                            Float Arithmetic.    (line  29)
+* mpf_ui_sub:                            Float Arithmetic.    (line  12)
 * mpf_urandomb:                          Miscellaneous Float Functions.
-                                                              (line  27)
-* mpn_add:                               Low-level Functions. (line  69)
-* mpn_add_1:                             Low-level Functions. (line  64)
-* mpn_add_n:                             Low-level Functions. (line  54)
-* mpn_addmul_1:                          Low-level Functions. (line 148)
-* mpn_and_n:                             Low-level Functions. (line 421)
-* mpn_andn_n:                            Low-level Functions. (line 436)
-* mpn_cmp:                               Low-level Functions. (line 284)
-* mpn_com:                               Low-level Functions. (line 461)
-* mpn_copyd:                             Low-level Functions. (line 470)
-* mpn_copyi:                             Low-level Functions. (line 466)
-* mpn_divexact_by3:                      Low-level Functions. (line 229)
-* mpn_divexact_by3c:                     Low-level Functions. (line 231)
-* mpn_divmod:                            Low-level Functions. (line 224)
-* mpn_divmod_1:                          Low-level Functions. (line 208)
-* mpn_divrem:                            Low-level Functions. (line 182)
-* mpn_divrem_1:                          Low-level Functions. (line 206)
-* mpn_gcd:                               Low-level Functions. (line 289)
-* mpn_gcd_1:                             Low-level Functions. (line 299)
-* mpn_gcdext:                            Low-level Functions. (line 305)
-* mpn_get_str:                           Low-level Functions. (line 346)
-* mpn_hamdist:                           Low-level Functions. (line 410)
-* mpn_ior_n:                             Low-level Functions. (line 426)
-* mpn_iorn_n:                            Low-level Functions. (line 441)
-* mpn_lshift:                            Low-level Functions. (line 260)
-* mpn_mod_1:                             Low-level Functions. (line 255)
-* mpn_mul:                               Low-level Functions. (line 114)
-* mpn_mul_1:                             Low-level Functions. (line 133)
-* mpn_mul_n:                             Low-level Functions. (line 103)
-* mpn_nand_n:                            Low-level Functions. (line 446)
-* mpn_neg:                               Low-level Functions. (line  98)
-* mpn_nior_n:                            Low-level Functions. (line 451)
-* mpn_perfect_square_p:                  Low-level Functions. (line 416)
-* mpn_popcount:                          Low-level Functions. (line 406)
-* mpn_random:                            Low-level Functions. (line 395)
-* mpn_random2:                           Low-level Functions. (line 396)
-* mpn_rshift:                            Low-level Functions. (line 272)
-* mpn_scan0:                             Low-level Functions. (line 380)
-* mpn_scan1:                             Low-level Functions. (line 388)
-* mpn_set_str:                           Low-level Functions. (line 361)
-* mpn_sqr:                               Low-level Functions. (line 125)
-* mpn_sqrtrem:                           Low-level Functions. (line 328)
-* mpn_sub:                               Low-level Functions. (line  90)
-* mpn_sub_1:                             Low-level Functions. (line  85)
-* mpn_sub_n:                             Low-level Functions. (line  76)
-* mpn_submul_1:                          Low-level Functions. (line 159)
-* mpn_tdiv_qr:                           Low-level Functions. (line 171)
-* mpn_xnor_n:                            Low-level Functions. (line 456)
-* mpn_xor_n:                             Low-level Functions. (line 431)
-* mpn_zero:                              Low-level Functions. (line 473)
-* mpq_abs:                               Rational Arithmetic. (line  31)
-* mpq_add:                               Rational Arithmetic. (line   7)
+                                                              (line  25)
+* mpn_add:                               Low-level Functions. (line  67)
+* mpn_addmul_1:                          Low-level Functions. (line 146)
+* mpn_add_1:                             Low-level Functions. (line  62)
+* mpn_add_n:                             Low-level Functions. (line  52)
+* mpn_andn_n:                            Low-level Functions. (line 434)
+* mpn_and_n:                             Low-level Functions. (line 419)
+* mpn_cmp:                               Low-level Functions. (line 282)
+* mpn_com:                               Low-level Functions. (line 459)
+* mpn_copyd:                             Low-level Functions. (line 468)
+* mpn_copyi:                             Low-level Functions. (line 464)
+* mpn_divexact_by3:                      Low-level Functions. (line 227)
+* mpn_divexact_by3c:                     Low-level Functions. (line 229)
+* mpn_divmod:                            Low-level Functions. (line 222)
+* mpn_divmod_1:                          Low-level Functions. (line 206)
+* mpn_divrem:                            Low-level Functions. (line 179)
+* mpn_divrem_1:                          Low-level Functions. (line 204)
+* mpn_gcd:                               Low-level Functions. (line 287)
+* mpn_gcdext:                            Low-level Functions. (line 302)
+* mpn_gcd_1:                             Low-level Functions. (line 297)
+* mpn_get_str:                           Low-level Functions. (line 344)
+* mpn_hamdist:                           Low-level Functions. (line 408)
+* mpn_iorn_n:                            Low-level Functions. (line 439)
+* mpn_ior_n:                             Low-level Functions. (line 424)
+* mpn_lshift:                            Low-level Functions. (line 258)
+* mpn_mod_1:                             Low-level Functions. (line 253)
+* mpn_mul:                               Low-level Functions. (line 112)
+* mpn_mul_1:                             Low-level Functions. (line 131)
+* mpn_mul_n:                             Low-level Functions. (line 101)
+* mpn_nand_n:                            Low-level Functions. (line 444)
+* mpn_neg:                               Low-level Functions. (line  96)
+* mpn_nior_n:                            Low-level Functions. (line 449)
+* mpn_perfect_square_p:                  Low-level Functions. (line 414)
+* mpn_popcount:                          Low-level Functions. (line 404)
+* mpn_random:                            Low-level Functions. (line 394)
+* mpn_random2:                           Low-level Functions. (line 395)
+* mpn_rshift:                            Low-level Functions. (line 270)
+* mpn_scan0:                             Low-level Functions. (line 378)
+* mpn_scan1:                             Low-level Functions. (line 386)
+* mpn_set_str:                           Low-level Functions. (line 359)
+* mpn_sqr:                               Low-level Functions. (line 123)
+* mpn_sqrtrem:                           Low-level Functions. (line 326)
+* mpn_sub:                               Low-level Functions. (line  88)
+* mpn_submul_1:                          Low-level Functions. (line 157)
+* mpn_sub_1:                             Low-level Functions. (line  83)
+* mpn_sub_n:                             Low-level Functions. (line  74)
+* mpn_tdiv_qr:                           Low-level Functions. (line 168)
+* mpn_xnor_n:                            Low-level Functions. (line 454)
+* mpn_xor_n:                             Low-level Functions. (line 429)
+* mpn_zero:                              Low-level Functions. (line 472)
+* mpq_abs:                               Rational Arithmetic. (line  30)
+* mpq_add:                               Rational Arithmetic. (line   6)
 * mpq_canonicalize:                      Rational Number Functions.
-                                                              (line  22)
+                                                              (line  21)
 * mpq_class:                             C++ Interface General.
-                                                              (line  19)
+                                                              (line  18)
 * mpq_class::canonicalize:               C++ Interface Rationals.
-                                                              (line  37)
+                                                              (line  35)
 * mpq_class::get_d:                      C++ Interface Rationals.
-                                                              (line  46)
+                                                              (line  45)
 * mpq_class::get_den:                    C++ Interface Rationals.
                                                               (line  58)
 * mpq_class::get_den_mpz_t:              C++ Interface Rationals.
                                                               (line  68)
 * mpq_class::get_mpq_t:                  C++ Interface General.
-                                                              (line  65)
+                                                              (line  64)
 * mpq_class::get_num:                    C++ Interface Rationals.
                                                               (line  57)
 * mpq_class::get_num_mpz_t:              C++ Interface Rationals.
                                                               (line  67)
 * mpq_class::get_str:                    C++ Interface Rationals.
-                                                              (line  47)
+                                                              (line  46)
 * mpq_class::mpq_class:                  C++ Interface Rationals.
-                                                              (line  11)
+                                                              (line   9)
+* mpq_class::mpq_class <1>:              C++ Interface Rationals.
+                                                              (line  10)
+* mpq_class::mpq_class <2>:              C++ Interface Rationals.
+                                                              (line  20)
+* mpq_class::mpq_class <3>:              C++ Interface Rationals.
+                                                              (line  25)
+* mpq_class::mpq_class <4>:              C++ Interface Rationals.
+                                                              (line  27)
 * mpq_class::set_str:                    C++ Interface Rationals.
                                                               (line  48)
+* mpq_class::set_str <1>:                C++ Interface Rationals.
+                                                              (line  49)
 * mpq_clear:                             Initializing Rationals.
-                                                              (line  16)
+                                                              (line  15)
 * mpq_clears:                            Initializing Rationals.
-                                                              (line  20)
-* mpq_cmp:                               Comparing Rationals. (line   7)
-* mpq_cmp_si:                            Comparing Rationals. (line  17)
-* mpq_cmp_ui:                            Comparing Rationals. (line  15)
+                                                              (line  19)
+* mpq_cmp:                               Comparing Rationals. (line   6)
+* mpq_cmp_si:                            Comparing Rationals. (line  15)
+* mpq_cmp_ui:                            Comparing Rationals. (line  13)
 * mpq_denref:                            Applying Integer Functions.
-                                                              (line  18)
-* mpq_div:                               Rational Arithmetic. (line  22)
-* mpq_div_2exp:                          Rational Arithmetic. (line  25)
-* mpq_equal:                             Comparing Rationals. (line  33)
+                                                              (line  16)
+* mpq_div:                               Rational Arithmetic. (line  20)
+* mpq_div_2exp:                          Rational Arithmetic. (line  24)
+* mpq_equal:                             Comparing Rationals. (line  32)
 * mpq_get_d:                             Rational Conversions.
-                                                              (line   7)
+                                                              (line   6)
 * mpq_get_den:                           Applying Integer Functions.
-                                                              (line  24)
+                                                              (line  22)
 * mpq_get_num:                           Applying Integer Functions.
-                                                              (line  23)
+                                                              (line  21)
 * mpq_get_str:                           Rational Conversions.
-                                                              (line  22)
+                                                              (line  21)
 * mpq_init:                              Initializing Rationals.
-                                                              (line   7)
+                                                              (line   6)
 * mpq_inits:                             Initializing Rationals.
-                                                              (line  12)
-* mpq_inp_str:                           I/O of Rationals.    (line  26)
-* mpq_inv:                               Rational Arithmetic. (line  34)
-* mpq_mul:                               Rational Arithmetic. (line  15)
-* mpq_mul_2exp:                          Rational Arithmetic. (line  18)
-* mpq_neg:                               Rational Arithmetic. (line  28)
+                                                              (line  11)
+* mpq_inp_str:                           I/O of Rationals.    (line  25)
+* mpq_inv:                               Rational Arithmetic. (line  33)
+* mpq_mul:                               Rational Arithmetic. (line  13)
+* mpq_mul_2exp:                          Rational Arithmetic. (line  17)
+* mpq_neg:                               Rational Arithmetic. (line  27)
 * mpq_numref:                            Applying Integer Functions.
-                                                              (line  17)
-* mpq_out_str:                           I/O of Rationals.    (line  18)
+                                                              (line  15)
+* mpq_out_str:                           I/O of Rationals.    (line  17)
 * mpq_set:                               Initializing Rationals.
-                                                              (line  24)
+                                                              (line  23)
 * mpq_set_d:                             Rational Conversions.
-                                                              (line  17)
+                                                              (line  16)
 * mpq_set_den:                           Applying Integer Functions.
-                                                              (line  26)
+                                                              (line  24)
 * mpq_set_f:                             Rational Conversions.
-                                                              (line  18)
+                                                              (line  17)
 * mpq_set_num:                           Applying Integer Functions.
-                                                              (line  25)
+                                                              (line  23)
 * mpq_set_si:                            Initializing Rationals.
-                                                              (line  31)
+                                                              (line  29)
 * mpq_set_str:                           Initializing Rationals.
-                                                              (line  36)
+                                                              (line  35)
 * mpq_set_ui:                            Initializing Rationals.
-                                                              (line  29)
+                                                              (line  27)
 * mpq_set_z:                             Initializing Rationals.
-                                                              (line  25)
-* mpq_sgn:                               Comparing Rationals. (line  27)
-* mpq_sub:                               Rational Arithmetic. (line  11)
+                                                              (line  24)
+* mpq_sgn:                               Comparing Rationals. (line  26)
+* mpq_sub:                               Rational Arithmetic. (line   9)
 * mpq_swap:                              Initializing Rationals.
-                                                              (line  56)
+                                                              (line  54)
 * mpq_t:                                 Nomenclature and Types.
                                                               (line  16)
-* mpz_abs:                               Integer Arithmetic.  (line  42)
-* mpz_add:                               Integer Arithmetic.  (line   7)
-* mpz_add_ui:                            Integer Arithmetic.  (line   9)
-* mpz_addmul:                            Integer Arithmetic.  (line  25)
-* mpz_addmul_ui:                         Integer Arithmetic.  (line  27)
+* mpz_abs:                               Integer Arithmetic.  (line  41)
+* mpz_add:                               Integer Arithmetic.  (line   6)
+* mpz_addmul:                            Integer Arithmetic.  (line  24)
+* mpz_addmul_ui:                         Integer Arithmetic.  (line  25)
+* mpz_add_ui:                            Integer Arithmetic.  (line   7)
 * mpz_and:                               Integer Logic and Bit Fiddling.
-                                                              (line  11)
+                                                              (line  10)
 * mpz_array_init:                        Integer Special Functions.
-                                                              (line  11)
+                                                              (line   9)
 * mpz_bin_ui:                            Number Theoretic Functions.
-                                                              (line  98)
+                                                              (line  97)
 * mpz_bin_uiui:                          Number Theoretic Functions.
-                                                              (line 100)
-* mpz_cdiv_q:                            Integer Division.    (line  13)
-* mpz_cdiv_q_2exp:                       Integer Division.    (line  24)
-* mpz_cdiv_q_ui:                         Integer Division.    (line  17)
-* mpz_cdiv_qr:                           Integer Division.    (line  15)
-* mpz_cdiv_qr_ui:                        Integer Division.    (line  21)
-* mpz_cdiv_r:                            Integer Division.    (line  14)
-* mpz_cdiv_r_2exp:                       Integer Division.    (line  25)
-* mpz_cdiv_r_ui:                         Integer Division.    (line  19)
+                                                              (line  98)
+* mpz_cdiv_q:                            Integer Division.    (line  12)
+* mpz_cdiv_qr:                           Integer Division.    (line  14)
+* mpz_cdiv_qr_ui:                        Integer Division.    (line  20)
+* mpz_cdiv_q_2exp:                       Integer Division.    (line  27)
+* mpz_cdiv_q_ui:                         Integer Division.    (line  16)
+* mpz_cdiv_r:                            Integer Division.    (line  13)
+* mpz_cdiv_r_2exp:                       Integer Division.    (line  28)
+* mpz_cdiv_r_ui:                         Integer Division.    (line  18)
 * mpz_cdiv_ui:                           Integer Division.    (line  23)
 * mpz_class:                             C++ Interface General.
-                                                              (line  18)
+                                                              (line  17)
 * mpz_class::fits_sint_p:                C++ Interface Integers.
                                                               (line  45)
 * mpz_class::fits_slong_p:               C++ Interface Integers.
@@ -10306,415 +10299,441 @@ Function and Type Index
 * mpz_class::fits_sshort_p:              C++ Interface Integers.
                                                               (line  47)
 * mpz_class::fits_uint_p:                C++ Interface Integers.
-                                                              (line  48)
-* mpz_class::fits_ulong_p:               C++ Interface Integers.
                                                               (line  49)
-* mpz_class::fits_ushort_p:              C++ Interface Integers.
+* mpz_class::fits_ulong_p:               C++ Interface Integers.
                                                               (line  50)
-* mpz_class::get_d:                      C++ Interface Integers.
+* mpz_class::fits_ushort_p:              C++ Interface Integers.
                                                               (line  51)
+* mpz_class::get_d:                      C++ Interface Integers.
+                                                              (line  53)
 * mpz_class::get_mpz_t:                  C++ Interface General.
-                                                              (line  64)
+                                                              (line  63)
 * mpz_class::get_si:                     C++ Interface Integers.
-                                                              (line  52)
+                                                              (line  54)
 * mpz_class::get_str:                    C++ Interface Integers.
-                                                              (line  53)
+                                                              (line  55)
 * mpz_class::get_ui:                     C++ Interface Integers.
-                                                              (line  54)
+                                                              (line  56)
 * mpz_class::mpz_class:                  C++ Interface Integers.
-                                                              (line   7)
+                                                              (line   6)
+* mpz_class::mpz_class <1>:              C++ Interface Integers.
+                                                              (line  13)
+* mpz_class::mpz_class <2>:              C++ Interface Integers.
+                                                              (line  18)
+* mpz_class::mpz_class <3>:              C++ Interface Integers.
+                                                              (line  20)
 * mpz_class::set_str:                    C++ Interface Integers.
-                                                              (line  55)
+                                                              (line  58)
+* mpz_class::set_str <1>:                C++ Interface Integers.
+                                                              (line  59)
 * mpz_clear:                             Initializing Integers.
-                                                              (line  44)
+                                                              (line  43)
 * mpz_clears:                            Initializing Integers.
-                                                              (line  48)
+                                                              (line  47)
 * mpz_clrbit:                            Integer Logic and Bit Fiddling.
-                                                              (line  54)
-* mpz_cmp:                               Integer Comparisons. (line   7)
-* mpz_cmp_d:                             Integer Comparisons. (line   8)
-* mpz_cmp_si:                            Integer Comparisons. (line   9)
-* mpz_cmp_ui:                            Integer Comparisons. (line  10)
-* mpz_cmpabs:                            Integer Comparisons. (line  18)
-* mpz_cmpabs_d:                          Integer Comparisons. (line  19)
-* mpz_cmpabs_ui:                         Integer Comparisons. (line  20)
+                                                              (line  52)
+* mpz_cmp:                               Integer Comparisons. (line   6)
+* mpz_cmpabs:                            Integer Comparisons. (line  17)
+* mpz_cmpabs_d:                          Integer Comparisons. (line  18)
+* mpz_cmpabs_ui:                         Integer Comparisons. (line  19)
+* mpz_cmp_d:                             Integer Comparisons. (line   7)
+* mpz_cmp_si:                            Integer Comparisons. (line   8)
+* mpz_cmp_ui:                            Integer Comparisons. (line   9)
 * mpz_com:                               Integer Logic and Bit Fiddling.
-                                                              (line  20)
+                                                              (line  19)
 * mpz_combit:                            Integer Logic and Bit Fiddling.
-                                                              (line  57)
-* mpz_congruent_2exp_p:                  Integer Division.    (line 124)
-* mpz_congruent_p:                       Integer Division.    (line 121)
-* mpz_congruent_ui_p:                    Integer Division.    (line 123)
-* mpz_divexact:                          Integer Division.    (line 101)
-* mpz_divexact_ui:                       Integer Division.    (line 102)
-* mpz_divisible_2exp_p:                  Integer Division.    (line 112)
-* mpz_divisible_p:                       Integer Division.    (line 110)
-* mpz_divisible_ui_p:                    Integer Division.    (line 111)
+                                                              (line  55)
+* mpz_congruent_2exp_p:                  Integer Division.    (line 136)
+* mpz_congruent_p:                       Integer Division.    (line 133)
+* mpz_congruent_ui_p:                    Integer Division.    (line 134)
+* mpz_divexact:                          Integer Division.    (line 113)
+* mpz_divexact_ui:                       Integer Division.    (line 114)
+* mpz_divisible_2exp_p:                  Integer Division.    (line 124)
+* mpz_divisible_p:                       Integer Division.    (line 122)
+* mpz_divisible_ui_p:                    Integer Division.    (line 123)
 * mpz_even_p:                            Miscellaneous Integer Functions.
-                                                              (line  18)
+                                                              (line  17)
 * mpz_export:                            Integer Import and Export.
-                                                              (line  45)
+                                                              (line  43)
 * mpz_fac_ui:                            Number Theoretic Functions.
-                                                              (line  95)
-* mpz_fdiv_q:                            Integer Division.    (line  27)
-* mpz_fdiv_q_2exp:                       Integer Division.    (line  38)
-* mpz_fdiv_q_ui:                         Integer Division.    (line  31)
-* mpz_fdiv_qr:                           Integer Division.    (line  29)
-* mpz_fdiv_qr_ui:                        Integer Division.    (line  35)
-* mpz_fdiv_r:                            Integer Division.    (line  28)
-* mpz_fdiv_r_2exp:                       Integer Division.    (line  39)
-* mpz_fdiv_r_ui:                         Integer Division.    (line  33)
-* mpz_fdiv_ui:                           Integer Division.    (line  37)
+                                                              (line  94)
+* mpz_fdiv_q:                            Integer Division.    (line  30)
+* mpz_fdiv_qr:                           Integer Division.    (line  32)
+* mpz_fdiv_qr_ui:                        Integer Division.    (line  38)
+* mpz_fdiv_q_2exp:                       Integer Division.    (line  45)
+* mpz_fdiv_q_ui:                         Integer Division.    (line  34)
+* mpz_fdiv_r:                            Integer Division.    (line  31)
+* mpz_fdiv_r_2exp:                       Integer Division.    (line  46)
+* mpz_fdiv_r_ui:                         Integer Division.    (line  36)
+* mpz_fdiv_ui:                           Integer Division.    (line  41)
 * mpz_fib2_ui:                           Number Theoretic Functions.
-                                                              (line 108)
-* mpz_fib_ui:                            Number Theoretic Functions.
                                                               (line 106)
+* mpz_fib_ui:                            Number Theoretic Functions.
+                                                              (line 105)
 * mpz_fits_sint_p:                       Miscellaneous Integer Functions.
-                                                              (line  10)
+                                                              (line   9)
 * mpz_fits_slong_p:                      Miscellaneous Integer Functions.
-                                                              (line   8)
+                                                              (line   7)
 * mpz_fits_sshort_p:                     Miscellaneous Integer Functions.
-                                                              (line  12)
+                                                              (line  11)
 * mpz_fits_uint_p:                       Miscellaneous Integer Functions.
-                                                              (line   9)
+                                                              (line   8)
 * mpz_fits_ulong_p:                      Miscellaneous Integer Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpz_fits_ushort_p:                     Miscellaneous Integer Functions.
-                                                              (line  11)
+                                                              (line  10)
 * mpz_gcd:                               Number Theoretic Functions.
-                                                              (line  30)
-* mpz_gcd_ui:                            Number Theoretic Functions.
-                                                              (line  35)
+                                                              (line  29)
 * mpz_gcdext:                            Number Theoretic Functions.
-                                                              (line  45)
-* mpz_get_d:                             Converting Integers. (line  27)
-* mpz_get_d_2exp:                        Converting Integers. (line  35)
-* mpz_get_si:                            Converting Integers. (line  18)
-* mpz_get_str:                           Converting Integers. (line  46)
-* mpz_get_ui:                            Converting Integers. (line  11)
+                                                              (line  43)
+* mpz_gcd_ui:                            Number Theoretic Functions.
+                                                              (line  33)
 * mpz_getlimbn:                          Integer Special Functions.
-                                                              (line  60)
+                                                              (line  59)
+* mpz_get_d:                             Converting Integers. (line  26)
+* mpz_get_d_2exp:                        Converting Integers. (line  34)
+* mpz_get_si:                            Converting Integers. (line  17)
+* mpz_get_str:                           Converting Integers. (line  45)
+* mpz_get_ui:                            Converting Integers. (line  10)
 * mpz_hamdist:                           Integer Logic and Bit Fiddling.
-                                                              (line  29)
+                                                              (line  28)
 * mpz_import:                            Integer Import and Export.
-                                                              (line  11)
+                                                              (line   9)
 * mpz_init:                              Initializing Integers.
-                                                              (line  26)
+                                                              (line  25)
 * mpz_init2:                             Initializing Integers.
-                                                              (line  33)
+                                                              (line  32)
+* mpz_inits:                             Initializing Integers.
+                                                              (line  28)
 * mpz_init_set:                          Simultaneous Integer Init & Assign.
-                                                              (line  27)
+                                                              (line  26)
 * mpz_init_set_d:                        Simultaneous Integer Init & Assign.
-                                                              (line  30)
-* mpz_init_set_si:                       Simultaneous Integer Init & Assign.
                                                               (line  29)
+* mpz_init_set_si:                       Simultaneous Integer Init & Assign.
+                                                              (line  28)
 * mpz_init_set_str:                      Simultaneous Integer Init & Assign.
-                                                              (line  34)
+                                                              (line  33)
 * mpz_init_set_ui:                       Simultaneous Integer Init & Assign.
-                                                              (line  28)
-* mpz_inits:                             Initializing Integers.
-                                                              (line  29)
-* mpz_inp_raw:                           I/O of Integers.     (line  61)
-* mpz_inp_str:                           I/O of Integers.     (line  30)
+                                                              (line  27)
+* mpz_inp_raw:                           I/O of Integers.     (line  60)
+* mpz_inp_str:                           I/O of Integers.     (line  29)
 * mpz_invert:                            Number Theoretic Functions.
-                                                              (line  60)
+                                                              (line  59)
 * mpz_ior:                               Integer Logic and Bit Fiddling.
-                                                              (line  14)
+                                                              (line  13)
 * mpz_jacobi:                            Number Theoretic Functions.
-                                                              (line  66)
+                                                              (line  65)
 * mpz_kronecker:                         Number Theoretic Functions.
-                                                              (line  74)
+                                                              (line  73)
 * mpz_kronecker_si:                      Number Theoretic Functions.
-                                                              (line  75)
+                                                              (line  74)
 * mpz_kronecker_ui:                      Number Theoretic Functions.
-                                                              (line  76)
+                                                              (line  75)
 * mpz_lcm:                               Number Theoretic Functions.
-                                                              (line  54)
+                                                              (line  53)
 * mpz_lcm_ui:                            Number Theoretic Functions.
-                                                              (line  55)
+                                                              (line  54)
 * mpz_legendre:                          Number Theoretic Functions.
-                                                              (line  69)
+                                                              (line  68)
 * mpz_lucnum2_ui:                        Number Theoretic Functions.
-                                                              (line 119)
-* mpz_lucnum_ui:                         Number Theoretic Functions.
                                                               (line 117)
-* mpz_mod:                               Integer Division.    (line  91)
-* mpz_mod_ui:                            Integer Division.    (line  93)
-* mpz_mul:                               Integer Arithmetic.  (line  19)
-* mpz_mul_2exp:                          Integer Arithmetic.  (line  35)
-* mpz_mul_si:                            Integer Arithmetic.  (line  20)
-* mpz_mul_ui:                            Integer Arithmetic.  (line  22)
-* mpz_neg:                               Integer Arithmetic.  (line  39)
+* mpz_lucnum_ui:                         Number Theoretic Functions.
+                                                              (line 116)
+* mpz_mod:                               Integer Division.    (line 103)
+* mpz_mod_ui:                            Integer Division.    (line 104)
+* mpz_mul:                               Integer Arithmetic.  (line  18)
+* mpz_mul_2exp:                          Integer Arithmetic.  (line  34)
+* mpz_mul_si:                            Integer Arithmetic.  (line  19)
+* mpz_mul_ui:                            Integer Arithmetic.  (line  20)
+* mpz_neg:                               Integer Arithmetic.  (line  38)
 * mpz_nextprime:                         Number Theoretic Functions.
-                                                              (line  23)
+                                                              (line  22)
 * mpz_odd_p:                             Miscellaneous Integer Functions.
-                                                              (line  17)
-* mpz_out_raw:                           I/O of Integers.     (line  45)
-* mpz_out_str:                           I/O of Integers.     (line  18)
-* mpz_perfect_power_p:                   Integer Roots.       (line  27)
-* mpz_perfect_square_p:                  Integer Roots.       (line  36)
+                                                              (line  16)
+* mpz_out_raw:                           I/O of Integers.     (line  44)
+* mpz_out_str:                           I/O of Integers.     (line  17)
+* mpz_perfect_power_p:                   Integer Roots.       (line  26)
+* mpz_perfect_square_p:                  Integer Roots.       (line  35)
 * mpz_popcount:                          Integer Logic and Bit Fiddling.
-                                                              (line  23)
-* mpz_pow_ui:                            Integer Exponentiation.
-                                                              (line  31)
+                                                              (line  22)
 * mpz_powm:                              Integer Exponentiation.
-                                                              (line   8)
+                                                              (line   6)
 * mpz_powm_sec:                          Integer Exponentiation.
-                                                              (line  18)
+                                                              (line  16)
 * mpz_powm_ui:                           Integer Exponentiation.
-                                                              (line  10)
+                                                              (line   8)
+* mpz_pow_ui:                            Integer Exponentiation.
+                                                              (line  29)
 * mpz_probab_prime_p:                    Number Theoretic Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpz_random:                            Integer Random Numbers.
-                                                              (line  42)
+                                                              (line  41)
 * mpz_random2:                           Integer Random Numbers.
-                                                              (line  51)
+                                                              (line  50)
 * mpz_realloc2:                          Initializing Integers.
-                                                              (line  52)
+                                                              (line  51)
 * mpz_remove:                            Number Theoretic Functions.
-                                                              (line  90)
-* mpz_root:                              Integer Roots.       (line   7)
-* mpz_rootrem:                           Integer Roots.       (line  13)
+                                                              (line  89)
+* mpz_root:                              Integer Roots.       (line   6)
+* mpz_rootrem:                           Integer Roots.       (line  11)
 * mpz_rrandomb:                          Integer Random Numbers.
-                                                              (line  31)
+                                                              (line  29)
 * mpz_scan0:                             Integer Logic and Bit Fiddling.
-                                                              (line  37)
+                                                              (line  35)
 * mpz_scan1:                             Integer Logic and Bit Fiddling.
-                                                              (line  38)
-* mpz_set:                               Assigning Integers.  (line  10)
-* mpz_set_d:                             Assigning Integers.  (line  13)
-* mpz_set_f:                             Assigning Integers.  (line  15)
-* mpz_set_q:                             Assigning Integers.  (line  14)
-* mpz_set_si:                            Assigning Integers.  (line  12)
-* mpz_set_str:                           Assigning Integers.  (line  21)
-* mpz_set_ui:                            Assigning Integers.  (line  11)
+                                                              (line  36)
+* mpz_set:                               Assigning Integers.  (line   9)
 * mpz_setbit:                            Integer Logic and Bit Fiddling.
-                                                              (line  51)
-* mpz_sgn:                               Integer Comparisons. (line  28)
-* mpz_si_kronecker:                      Number Theoretic Functions.
-                                                              (line  77)
+                                                              (line  49)
+* mpz_set_d:                             Assigning Integers.  (line  12)
+* mpz_set_f:                             Assigning Integers.  (line  14)
+* mpz_set_q:                             Assigning Integers.  (line  13)
+* mpz_set_si:                            Assigning Integers.  (line  11)
+* mpz_set_str:                           Assigning Integers.  (line  20)
+* mpz_set_ui:                            Assigning Integers.  (line  10)
+* mpz_sgn:                               Integer Comparisons. (line  27)
 * mpz_size:                              Integer Special Functions.
-                                                              (line  68)
+                                                              (line  67)
 * mpz_sizeinbase:                        Miscellaneous Integer Functions.
-                                                              (line  23)
-* mpz_sqrt:                              Integer Roots.       (line  17)
-* mpz_sqrtrem:                           Integer Roots.       (line  20)
-* mpz_sub:                               Integer Arithmetic.  (line  12)
-* mpz_sub_ui:                            Integer Arithmetic.  (line  14)
-* mpz_submul:                            Integer Arithmetic.  (line  30)
-* mpz_submul_ui:                         Integer Arithmetic.  (line  32)
-* mpz_swap:                              Assigning Integers.  (line  37)
+                                                              (line  22)
+* mpz_si_kronecker:                      Number Theoretic Functions.
+                                                              (line  76)
+* mpz_sqrt:                              Integer Roots.       (line  16)
+* mpz_sqrtrem:                           Integer Roots.       (line  19)
+* mpz_sub:                               Integer Arithmetic.  (line  11)
+* mpz_submul:                            Integer Arithmetic.  (line  29)
+* mpz_submul_ui:                         Integer Arithmetic.  (line  30)
+* mpz_sub_ui:                            Integer Arithmetic.  (line  12)
+* mpz_swap:                              Assigning Integers.  (line  36)
 * mpz_t:                                 Nomenclature and Types.
                                                               (line   6)
-* mpz_tdiv_q:                            Integer Division.    (line  41)
-* mpz_tdiv_q_2exp:                       Integer Division.    (line  52)
-* mpz_tdiv_q_ui:                         Integer Division.    (line  45)
-* mpz_tdiv_qr:                           Integer Division.    (line  43)
-* mpz_tdiv_qr_ui:                        Integer Division.    (line  49)
-* mpz_tdiv_r:                            Integer Division.    (line  42)
-* mpz_tdiv_r_2exp:                       Integer Division.    (line  53)
-* mpz_tdiv_r_ui:                         Integer Division.    (line  47)
-* mpz_tdiv_ui:                           Integer Division.    (line  51)
+* mpz_tdiv_q:                            Integer Division.    (line  48)
+* mpz_tdiv_qr:                           Integer Division.    (line  50)
+* mpz_tdiv_qr_ui:                        Integer Division.    (line  56)
+* mpz_tdiv_q_2exp:                       Integer Division.    (line  63)
+* mpz_tdiv_q_ui:                         Integer Division.    (line  52)
+* mpz_tdiv_r:                            Integer Division.    (line  49)
+* mpz_tdiv_r_2exp:                       Integer Division.    (line  64)
+* mpz_tdiv_r_ui:                         Integer Division.    (line  54)
+* mpz_tdiv_ui:                           Integer Division.    (line  59)
 * mpz_tstbit:                            Integer Logic and Bit Fiddling.
-                                                              (line  60)
+                                                              (line  58)
 * mpz_ui_kronecker:                      Number Theoretic Functions.
-                                                              (line  78)
+                                                              (line  77)
 * mpz_ui_pow_ui:                         Integer Exponentiation.
-                                                              (line  33)
-* mpz_ui_sub:                            Integer Arithmetic.  (line  16)
+                                                              (line  31)
+* mpz_ui_sub:                            Integer Arithmetic.  (line  14)
 * mpz_urandomb:                          Integer Random Numbers.
-                                                              (line  14)
+                                                              (line  12)
 * mpz_urandomm:                          Integer Random Numbers.
-                                                              (line  23)
+                                                              (line  21)
 * mpz_xor:                               Integer Logic and Bit Fiddling.
-                                                              (line  17)
+                                                              (line  16)
+* mp_bitcnt_t:                           Nomenclature and Types.
+                                                              (line  42)
+* mp_bits_per_limb:                      Useful Macros and Constants.
+                                                              (line   7)
+* mp_exp_t:                              Nomenclature and Types.
+                                                              (line  27)
+* mp_get_memory_functions:               Custom Allocation.   (line  89)
+* mp_limb_t:                             Nomenclature and Types.
+                                                              (line  31)
+* mp_set_memory_functions:               Custom Allocation.   (line  17)
+* mp_size_t:                             Nomenclature and Types.
+                                                              (line  37)
 * msqrt:                                 BSD Compatible Functions.
-                                                              (line  63)
+                                                              (line  62)
 * msub:                                  BSD Compatible Functions.
-                                                              (line  46)
+                                                              (line  45)
 * mtox:                                  BSD Compatible Functions.
-                                                              (line  98)
+                                                              (line  97)
 * mult:                                  BSD Compatible Functions.
-                                                              (line  49)
+                                                              (line  48)
 * operator%:                             C++ Interface Integers.
-                                                              (line  30)
-* operator/:                             C++ Interface Integers.
                                                               (line  29)
+* operator/:                             C++ Interface Integers.
+                                                              (line  28)
 * operator<<:                            C++ Formatted Output.
-                                                              (line  11)
-* operator>> <1>:                        C++ Interface Rationals.
+                                                              (line  10)
+* operator<< <1>:                        C++ Formatted Output.
+                                                              (line  19)
+* operator<< <2>:                        C++ Formatted Output.
+                                                              (line  32)
+* operator>>:                            C++ Formatted Input. (line  10)
+* operator>> <1>:                        C++ Formatted Input. (line  13)
+* operator>> <2>:                        C++ Formatted Input. (line  24)
+* operator>> <3>:                        C++ Interface Rationals.
                                                               (line  77)
-* operator>>:                            C++ Formatted Input. (line  11)
 * pow:                                   BSD Compatible Functions.
-                                                              (line  71)
+                                                              (line  70)
 * rpow:                                  BSD Compatible Functions.
-                                                              (line  79)
+                                                              (line  78)
 * sdiv:                                  BSD Compatible Functions.
-                                                              (line  55)
-* sgn <1>:                               C++ Interface Floats.
-                                                              (line  98)
-* sgn <2>:                               C++ Interface Rationals.
-                                                              (line  50)
+                                                              (line  53)
 * sgn:                                   C++ Interface Integers.
-                                                              (line  57)
-* sqrt <1>:                              C++ Interface Floats.
-                                                              (line  99)
+                                                              (line  60)
+* sgn <1>:                               C++ Interface Rationals.
+                                                              (line  50)
+* sgn <2>:                               C++ Interface Floats.
+                                                              (line 102)
 * sqrt:                                  C++ Interface Integers.
-                                                              (line  58)
+                                                              (line  61)
+* sqrt <1>:                              C++ Interface Floats.
+                                                              (line 103)
 * trunc:                                 C++ Interface Floats.
-                                                              (line 100)
+                                                              (line 104)
 * xtom:                                  BSD Compatible Functions.
-                                                              (line  34)
+                                                              (line  33)
 
 
 
 Tag Table:
-Node: Top999
-Node: Copying3235
-Node: Introduction to GMP5086
-Node: Installing GMP7797
-Node: Build Options8529
-Node: ABI and ISA24597
-Node: Notes for Package Builds34283
-Node: Notes for Particular Systems37370
-Node: Known Build Problems43927
-Node: Performance optimization47461
-Node: GMP Basics48590
-Node: Headers and Libraries49238
-Node: Nomenclature and Types50662
-Node: Function Classes52659
-Node: Variable Conventions54352
-Node: Parameter Conventions55961
-Node: Memory Management58017
-Node: Reentrancy59145
-Node: Useful Macros and Constants61018
-Node: Compatibility with older versions62016
-Node: Demonstration Programs62977
-Node: Efficiency64842
-Node: Debugging72466
-Node: Profiling79024
-Node: Autoconf83015
-Node: Emacs84794
-Node: Reporting Bugs85400
-Node: Integer Functions87943
-Node: Initializing Integers88719
-Node: Assigning Integers90866
-Node: Simultaneous Integer Init & Assign92453
-Node: Converting Integers94078
-Node: Integer Arithmetic97000
-Node: Integer Division98586
-Node: Integer Exponentiation104896
-Node: Integer Roots106336
-Node: Number Theoretic Functions108010
-Node: Integer Comparisons114153
-Node: Integer Logic and Bit Fiddling115531
-Node: I/O of Integers118078
-Node: Integer Random Numbers121047
-Node: Integer Import and Export123658
-Node: Miscellaneous Integer Functions127668
-Node: Integer Special Functions129528
-Node: Rational Number Functions132615
-Node: Initializing Rationals133808
-Node: Rational Conversions136269
-Node: Rational Arithmetic138000
-Node: Comparing Rationals139304
-Node: Applying Integer Functions140671
-Node: I/O of Rationals142154
-Node: Floating-point Functions144196
-Node: Initializing Floats147081
-Node: Assigning Floats151168
-Node: Simultaneous Float Init & Assign153735
-Node: Converting Floats155263
-Node: Float Arithmetic158511
-Node: Float Comparison160524
-Node: I/O of Floats162105
-Node: Miscellaneous Float Functions164788
-Node: Low-level Functions166730
-Node: Random Number Functions190942
-Node: Random State Initialization192010
-Node: Random State Seeding194868
-Node: Random State Miscellaneous196257
-Node: Formatted Output196898
-Node: Formatted Output Strings197143
-Node: Formatted Output Functions202357
-Node: C++ Formatted Output206432
-Node: Formatted Input209114
-Node: Formatted Input Strings209350
-Node: Formatted Input Functions214002
-Node: C++ Formatted Input216971
-Node: C++ Class Interface218874
-Node: C++ Interface General219875
-Node: C++ Interface Integers222945
-Node: C++ Interface Rationals226290
-Node: C++ Interface Floats229877
-Node: C++ Interface Random Numbers235587
-Node: C++ Interface Limitations237993
-Node: BSD Compatible Functions240813
-Node: Custom Allocation245524
-Node: Language Bindings249842
-Node: Algorithms253821
-Node: Multiplication Algorithms254521
-Node: Basecase Multiplication255493
-Node: Karatsuba Multiplication257401
-Node: Toom 3-Way Multiplication261026
-Node: Toom 4-Way Multiplication267440
-Node: FFT Multiplication268812
-Node: Other Multiplication274147
-Node: Unbalanced Multiplication276621
-Node: Division Algorithms277409
-Node: Single Limb Division277788
-Node: Basecase Division280678
-Node: Divide and Conquer Division281881
-Node: Block-Wise Barrett Division283950
-Node: Exact Division284602
-Node: Exact Remainder287767
-Node: Small Quotient Division289994
-Node: Greatest Common Divisor Algorithms291592
-Node: Binary GCD291889
-Node: Lehmer's Algorithm294738
-Node: Subquadratic GCD296957
-Node: Extended GCD299414
-Node: Jacobi Symbol300726
-Node: Powering Algorithms301642
-Node: Normal Powering Algorithm301905
-Node: Modular Powering Algorithm302433
-Node: Root Extraction Algorithms303213
-Node: Square Root Algorithm303528
-Node: Nth Root Algorithm305669
-Node: Perfect Square Algorithm306454
-Node: Perfect Power Algorithm308540
-Node: Radix Conversion Algorithms309161
-Node: Binary to Radix309537
-Node: Radix to Binary313466
-Node: Other Algorithms315554
-Node: Prime Testing Algorithm315906
-Node: Factorial Algorithm317090
-Node: Binomial Coefficients Algorithm318493
-Node: Fibonacci Numbers Algorithm319387
-Node: Lucas Numbers Algorithm321861
-Node: Random Number Algorithms322582
-Node: Assembly Coding324703
-Node: Assembly Code Organisation325663
-Node: Assembly Basics326630
-Node: Assembly Carry Propagation327780
-Node: Assembly Cache Handling329611
-Node: Assembly Functional Units331772
-Node: Assembly Floating Point333385
-Node: Assembly SIMD Instructions337163
-Node: Assembly Software Pipelining338145
-Node: Assembly Loop Unrolling339207
-Node: Assembly Writing Guide341422
-Node: Internals344187
-Node: Integer Internals344699
-Node: Rational Internals346955
-Node: Float Internals348193
-Node: Raw Output Internals355607
-Node: C++ Interface Internals356801
-Node: Contributors360087
-Node: References365038
-Node: GNU Free Documentation License370773
-Node: Concept Index395942
-Node: Function Index442051
+Node: Top955
+Node: Copying3187
+Node: Introduction to GMP5038
+Node: Installing GMP7749
+Node: Build Options8481
+Node: ABI and ISA24538
+Node: Notes for Package Builds34228
+Node: Notes for Particular Systems37315
+Node: Known Build Problems43873
+Node: Performance optimization47404
+Node: GMP Basics48533
+Node: Headers and Libraries49181
+Node: Nomenclature and Types50605
+Node: Function Classes52602
+Node: Variable Conventions54296
+Node: Parameter Conventions55905
+Node: Memory Management57961
+Node: Reentrancy59089
+Node: Useful Macros and Constants60961
+Node: Compatibility with older versions61959
+Node: Demonstration Programs62919
+Node: Efficiency64778
+Node: Debugging72392
+Node: Profiling78945
+Node: Autoconf82935
+Node: Emacs84714
+Node: Reporting Bugs85320
+Node: Integer Functions87862
+Node: Initializing Integers88638
+Node: Assigning Integers90785
+Node: Simultaneous Integer Init & Assign92372
+Node: Converting Integers93997
+Node: Integer Arithmetic96895
+Node: Integer Division98481
+Node: Integer Exponentiation104798
+Node: Integer Roots106238
+Node: Number Theoretic Functions107909
+Node: Integer Comparisons114051
+Node: Integer Logic and Bit Fiddling115429
+Node: I/O of Integers117971
+Node: Integer Random Numbers120940
+Node: Integer Import and Export123551
+Node: Miscellaneous Integer Functions127561
+Node: Integer Special Functions129421
+Node: Rational Number Functions132509
+Node: Initializing Rationals133702
+Node: Rational Conversions136157
+Node: Rational Arithmetic137888
+Node: Comparing Rationals139192
+Node: Applying Integer Functions140559
+Node: I/O of Rationals142042
+Node: Floating-point Functions144083
+Node: Initializing Floats146968
+Node: Assigning Floats151054
+Node: Simultaneous Float Init & Assign153618
+Node: Converting Floats155146
+Node: Float Arithmetic158369
+Node: Float Comparison160382
+Node: I/O of Floats161964
+Node: Miscellaneous Float Functions164647
+Node: Low-level Functions166589
+Node: Random Number Functions190796
+Node: Random State Initialization191864
+Node: Random State Seeding194722
+Node: Random State Miscellaneous196111
+Node: Formatted Output196752
+Node: Formatted Output Strings196997
+Node: Formatted Output Functions202227
+Node: C++ Formatted Output206291
+Node: Formatted Input208973
+Node: Formatted Input Strings209209
+Node: Formatted Input Functions213869
+Node: C++ Formatted Input216838
+Node: C++ Class Interface218741
+Node: C++ Interface General219742
+Node: C++ Interface Integers222811
+Node: C++ Interface Rationals226160
+Node: C++ Interface Floats229747
+Node: C++ Interface Random Numbers235457
+Node: C++ Interface Limitations237861
+Node: BSD Compatible Functions240676
+Node: Custom Allocation245387
+Node: Language Bindings249706
+Node: Algorithms253662
+Node: Multiplication Algorithms254362
+Node: Basecase Multiplication255334
+Node: Karatsuba Multiplication257242
+Node: Toom 3-Way Multiplication260865
+Node: Toom 4-Way Multiplication267280
+Node: FFT Multiplication268652
+Node: Other Multiplication273988
+Node: Unbalanced Multiplication276462
+Node: Division Algorithms277250
+Node: Single Limb Division277629
+Node: Basecase Division280517
+Node: Divide and Conquer Division281720
+Node: Block-Wise Barrett Division283788
+Node: Exact Division284440
+Node: Exact Remainder287604
+Node: Small Quotient Division289831
+Node: Greatest Common Divisor Algorithms291429
+Node: Binary GCD291726
+Node: Lehmer's Algorithm294576
+Node: Subquadratic GCD296806
+Node: Extended GCD299274
+Node: Jacobi Symbol300592
+Node: Powering Algorithms301509
+Node: Normal Powering Algorithm301772
+Node: Modular Powering Algorithm302300
+Node: Root Extraction Algorithms303080
+Node: Square Root Algorithm303395
+Node: Nth Root Algorithm305536
+Node: Perfect Square Algorithm306321
+Node: Perfect Power Algorithm308407
+Node: Radix Conversion Algorithms309028
+Node: Binary to Radix309404
+Node: Radix to Binary313333
+Node: Other Algorithms315421
+Node: Prime Testing Algorithm315773
+Node: Factorial Algorithm316957
+Node: Binomial Coefficients Algorithm318364
+Node: Fibonacci Numbers Algorithm319258
+Node: Lucas Numbers Algorithm321732
+Node: Random Number Algorithms322453
+Node: Assembly Coding324572
+Node: Assembly Code Organisation325532
+Node: Assembly Basics326499
+Node: Assembly Carry Propagation327649
+Node: Assembly Cache Handling329479
+Node: Assembly Functional Units331640
+Node: Assembly Floating Point333253
+Node: Assembly SIMD Instructions337032
+Node: Assembly Software Pipelining338014
+Node: Assembly Loop Unrolling339077
+Node: Assembly Writing Guide341292
+Node: Internals344057
+Node: Integer Internals344569
+Node: Rational Internals346825
+Node: Float Internals348063
+Node: Raw Output Internals355463
+Node: C++ Interface Internals356657
+Node: Contributors359943
+Node: References364892
+Node: GNU Free Documentation License370617
+Node: Concept Index395765
+Node: Function Index443430
 
 End Tag Table
 
diff --git a/libcpp/expr.c b/libcpp/expr.c
index 3c36127b..4076fd01 100644
--- a/libcpp/expr.c
+++ b/libcpp/expr.c
@@ -1578,6 +1578,7 @@ num_binary_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs, enum cpp_ttype op)
       /* Arithmetic.  */
     case CPP_MINUS:
       rhs = num_negate (rhs, precision);
+      break;
     case CPP_PLUS:
       result.low = lhs.low + rhs.low;
       result.high = lhs.high + rhs.high;
diff --git a/libiberty/sha1.c b/libiberty/sha1.c
index 6a25ab23..aa952806 100644
--- a/libiberty/sha1.c
+++ b/libiberty/sha1.c
@@ -42,10 +42,11 @@
 #endif
 
 #define BLOCKSIZE 4096
+/*
 #if BLOCKSIZE % 64 != 0
 # error "invalid BLOCKSIZE"
 #endif
-
+*/
 /* This array contains the bytes used to pad the buffer to the next
    64-byte boundary.  (RFC 1321, 3.1: Step 1)  */
 static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };
diff --git a/mpc/doc/mpc.info b/mpc/doc/mpc.info
index 1542a0d2..c970392f 100644
--- a/mpc/doc/mpc.info
+++ b/mpc/doc/mpc.info
@@ -1,10 +1,6 @@
-This is mpc.info, produced by makeinfo version 4.13 from mpc.texi.
+This is mpc.info, produced by makeinfo version 6.5 from mpc.texi.
 
-START-INFO-DIR-ENTRY
-* mpc: (mpc.info).               Multiple Precision Complex Library.
-END-INFO-DIR-ENTRY
-
-   This is the manual for MPC, a library for multiple precision complex
+This is the manual for MPC, a library for multiple precision complex
 arithmetic, version 0.9, of February 2011.
 
 
@@ -18,14 +14,18 @@ manual provided the copyright notice and this permission notice are
 preserved on all copies.
 
    Permission is granted to copy and distribute modified versions of
-this manual under the conditions for verbatim copying, provided that
-the entire resulting derived work is distributed under the terms of a
+this manual under the conditions for verbatim copying, provided that the
+entire resulting derived work is distributed under the terms of a
 permission notice identical to this one.
 
    Permission is granted to copy and distribute translations of this
 manual into another language, under the above conditions for modified
 versions.
 
+START-INFO-DIR-ENTRY
+* mpc: (mpc.info).               Multiple Precision Complex Library.
+END-INFO-DIR-ENTRY
+
 
 File: mpc.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)
 
@@ -55,15 +55,14 @@ MPC Copying Conditions
 **********************
 
 The MPC Library is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as
-published by the Free Software Foundation; either version 2.1 of the
-License, or (at your option) any later version, see the file
-COPYING.LIB.
+it under the terms of the GNU Lesser General Public License as published
+by the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version, see the file COPYING.LIB.
 
    The MPC Library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
+General Public License for more details.
 
 
 File: mpc.info,  Node: Introduction to MPC,  Next: Installing MPC,  Prev: Copying,  Up: Top
@@ -72,8 +71,8 @@ File: mpc.info,  Node: Introduction to MPC,  Next: Installing MPC,  Prev: Copyin
 *********************
 
 MPC is a portable library written in C for arbitrary precision
-arithmetic on complex numbers providing correct rounding. Ultimately, it
-should implement a multiprecision equivalent of the C99 standard.  It
+arithmetic on complex numbers providing correct rounding.  Ultimately,
+it should implement a multiprecision equivalent of the C99 standard.  It
 builds upon the GNU MP and the GNU MPFR libraries.
 
 1.1 How to use this Manual
@@ -82,8 +81,8 @@ builds upon the GNU MP and the GNU MPFR libraries.
 Everyone should read *note MPC Basics::.  If you need to install the
 library yourself, you need to read *note Installing MPC::, too.
 
-   The remainder of the manual can be used for later reference,
-although it is probably a good idea to skim through it.
+   The remainder of the manual can be used for later reference, although
+it is probably a good idea to skim through it.
 
 
 File: mpc.info,  Node: Installing MPC,  Next: Reporting Bugs,  Prev: Introduction to MPC,  Up: Top
@@ -91,137 +90,136 @@ File: mpc.info,  Node: Installing MPC,  Next: Reporting Bugs,  Prev: Introductio
 2 Installing MPC
 ****************
 
-To build MPC, you first have to install GNU MP (version 4.3.2 or
-higher) and GNU MPFR (version 2.4.2 or higher) on your computer.  You
-need a C compiler, preferably GCC, but any reasonable compiler should
-work. And you need a standard Unix `make' program, plus some other
-standard Unix utility programs.
+To build MPC, you first have to install GNU MP (version 4.3.2 or higher)
+and GNU MPFR (version 2.4.2 or higher) on your computer.  You need a C
+compiler, preferably GCC, but any reasonable compiler should work.  And
+you need a standard Unix 'make' program, plus some other standard Unix
+utility programs.
 
    Here are the steps needed to install the library on Unix systems:
 
-  1. `tar xzf mpc-0.9.tar.gz'
+  1. 'tar xzf mpc-0.9.tar.gz'
 
-  2. `cd mpc-0.9'
+  2. 'cd mpc-0.9'
 
-  3. `./configure'
+  3. './configure'
 
      if GMP and MPFR are installed into standard directories, that is,
      directories that are searched by default by the compiler and the
      linking tools.
 
-     `./configure --with-gmp=<gmp_install_dir>'
+     './configure --with-gmp=<gmp_install_dir>'
 
      is used to indicate a different location where GMP is installed.
      Alternatively, you can specify directly GMP include and GMP lib
-     directories with `./configure --with-gmp-lib=<gmp_lib_dir>
+     directories with './configure --with-gmp-lib=<gmp_lib_dir>
      --with-gmp-include=<gmp_include_dir>'.
 
-     `./configure --with-mpfr=<mpfr_install_dir>'
+     './configure --with-mpfr=<mpfr_install_dir>'
 
      is used to indicate a different location where MPFR is installed.
      Alternatively, you can specify directly MPFR include and MPFR lib
-     directories with `./configure --with-mpf-lib=<mpfr_lib_dir>
+     directories with './configure --with-mpf-lib=<mpfr_lib_dir>
      --with-mpfr-include=<mpfr_include_dir>'.
 
-     Another useful parameter is `--prefix', which can be used to
+     Another useful parameter is '--prefix', which can be used to
      specify an alternative installation location instead of
-     `/usr/local'; see `make install' below.
+     '/usr/local'; see 'make install' below.
 
      If for debugging purposes you wish to log calls to MPC functions
-     from within your code, add the parameter `--enable-logging'.  In
-     your code, replace the inclusion of `mpc.h' by `mpc-log.h' and
-     link the executable dynamically.  Then all calls to functions with
-     only complex arguments are printed to `stderr' in the following
-     form: First, the function name is given, followed by its type such
-     as `c_cc', meaning that the function has one complex result (one
-     `c' in front of the `_'), computed from two complex arguments (two
-     `c' after the `_'). Then, the precisions of the real and the
-     imaginary part of the first result is given, followed by the
-     second one and so on. Finally, for each argument, the precisions
-     of its real and imaginary part are specified and the argument
-     itself is printed in hexadecimal via the function `mpc_out_str'
-     (*note String and Stream Input and Output: string-io.).
-
-     Use `./configure --help' for an exhaustive list of parameters.
-
-  4. `make'
+     from within your code, add the parameter '--enable-logging'.  In
+     your code, replace the inclusion of 'mpc.h' by 'mpc-log.h' and link
+     the executable dynamically.  Then all calls to functions with only
+     complex arguments are printed to 'stderr' in the following form:
+     First, the function name is given, followed by its type such as
+     'c_cc', meaning that the function has one complex result (one 'c'
+     in front of the '_'), computed from two complex arguments (two 'c'
+     after the '_').  Then, the precisions of the real and the imaginary
+     part of the first result is given, followed by the second one and
+     so on.  Finally, for each argument, the precisions of its real and
+     imaginary part are specified and the argument itself is printed in
+     hexadecimal via the function 'mpc_out_str' (*note String and Stream
+     Input and Output: string-io.).
+
+     Use './configure --help' for an exhaustive list of parameters.
+
+  4. 'make'
 
      This compiles MPC in the working directory.
 
-  5. `make check'
+  5. 'make check'
 
      This will make sure MPC was built correctly.
 
      If you get error messages, please report them to
-     `mpc-discuss@lists.gforge.inria.fr' (*Note Reporting Bugs::, for
+     'mpc-discuss@lists.gforge.inria.fr' (*Note Reporting Bugs::, for
      information on what to include in useful bug reports).
 
-  6. `make install'
+  6. 'make install'
 
-     This will copy the file `mpc.h' to the directory
-     `/usr/local/include', the file `libmpc.a' to the directory
-     `/usr/local/lib', and the file `mpc.info' to the directory
-     `/usr/local/share/info' (or if you passed the `--prefix' option to
-     `configure', using the prefix directory given as argument to
-     `--prefix' instead of `/usr/local'). Note: you need write
+     This will copy the file 'mpc.h' to the directory
+     '/usr/local/include', the file 'libmpc.a' to the directory
+     '/usr/local/lib', and the file 'mpc.info' to the directory
+     '/usr/local/share/info' (or if you passed the '--prefix' option to
+     'configure', using the prefix directory given as argument to
+     '--prefix' instead of '/usr/local').  Note: you need write
      permissions on these directories.
 
-
-2.1 Other `make' Targets
+2.1 Other 'make' Targets
 ========================
 
 There are some other useful make targets:
 
-   * `info'
+   * 'info'
 
-     Create an info version of the manual, in `mpc.info'.
+     Create an info version of the manual, in 'mpc.info'.
 
-   * `pdf'
+   * 'pdf'
 
-     Create a PDF version of the manual, in `doc/mpc.pdf'.
+     Create a PDF version of the manual, in 'doc/mpc.pdf'.
 
-   * `dvi'
+   * 'dvi'
 
-     Create a DVI version of the manual, in `doc/mpc.dvi'.
+     Create a DVI version of the manual, in 'doc/mpc.dvi'.
 
-   * `ps'
+   * 'ps'
 
-     Create a Postscript version of the manual, in `doc/mpc.ps'.
+     Create a Postscript version of the manual, in 'doc/mpc.ps'.
 
-   * `html'
+   * 'html'
 
      Create an HTML version of the manual, in several pages in the
-     directory `doc/mpc.html'; if you want only one output HTML file,
-     then type `makeinfo --html --no-split mpc.texi' instead.
+     directory 'doc/mpc.html'; if you want only one output HTML file,
+     then type 'makeinfo --html --no-split mpc.texi' instead.
 
-   * `clean'
+   * 'clean'
 
      Delete all object files and archive files, but not the
      configuration files.
 
-   * `distclean'
+   * 'distclean'
 
      Delete all files not included in the distribution.
 
-   * `uninstall'
+   * 'uninstall'
 
-     Delete all files copied by `make install'.
+     Delete all files copied by 'make install'.
 
 2.2 Known Build Problems
 ========================
 
 On AIX, if GMP was built with the 64-bit ABI, before building and
-testing MPC, it might be necessary to set the `OBJECT_MODE' environment
+testing MPC, it might be necessary to set the 'OBJECT_MODE' environment
 variable to 64 by, e.g.,
 
-   `export OBJECT_MODE=64'
+   'export OBJECT_MODE=64'
 
    This has been tested with the C compiler IBM XL C/C++ Enterprise
 Edition V8.0 for AIX, version: 08.00.0000.0021, GMP 4.2.4 and MPFR
 2.4.1.
 
    Please report any other problems you encounter to
-`mpc-discuss@lists.gforge.inria.fr'.  *Note Reporting Bugs::.
+'mpc-discuss@lists.gforge.inria.fr'.  *Note Reporting Bugs::.
 
 
 File: mpc.info,  Node: Reporting Bugs,  Next: MPC Basics,  Prev: Installing MPC,  Up: Top
@@ -230,7 +228,7 @@ File: mpc.info,  Node: Reporting Bugs,  Next: MPC Basics,  Prev: Installing MPC,
 ****************
 
 If you think you have found a bug in the MPC library, please investigate
-and report it. We have made this library available to you, and it is
+and report it.  We have made this library available to you, and it is
 not to ask too much from you, to ask you to report the bugs that you
 find.
 
@@ -240,19 +238,18 @@ report together.
    You have to send us a test case that makes it possible for us to
 reproduce the bug.  Include instructions on how to run the test case.
 
-   You also have to explain what is wrong; if you get a crash, or if
-the results printed are incorrect and in that case, in what way.
+   You also have to explain what is wrong; if you get a crash, or if the
+results printed are incorrect and in that case, in what way.
 
-   Please include compiler version information in your bug report.
-This can be extracted using `gcc -v', or `cc -V' on some machines.
-Also, include the output from `uname -a'.
+   Please include compiler version information in your bug report.  This
+can be extracted using 'gcc -v', or 'cc -V' on some machines.  Also,
+include the output from 'uname -a'.
 
    If your bug report is good, we will do our best to help you to get a
-corrected version of the library; if the bug report is poor, we will
-not do anything about it (aside of chiding you to send better bug
-reports).
+corrected version of the library; if the bug report is poor, we will not
+do anything about it (aside of chiding you to send better bug reports).
 
-   Send your bug report to: `mpc-discuss@lists.gforge.inria.fr'.
+   Send your bug report to: 'mpc-discuss@lists.gforge.inria.fr'.
 
    If you think something in this manual is unclear, or downright
 incorrect, or if the language needs to be improved, please send a note
@@ -265,7 +262,7 @@ File: mpc.info,  Node: MPC Basics,  Next: Complex Functions,  Prev: Reporting Bu
 ************
 
 All declarations needed to use MPC are collected in the include file
-`mpc.h'.  It is designed to work with both C and C++ compilers.  You
+'mpc.h'.  It is designed to work with both C and C++ compilers.  You
 should include that file in any program using the MPC library by adding
 the line
         #include "mpc.h"
@@ -275,16 +272,16 @@ the line
 
 "Complex number" or "Complex" for short, is a pair of two arbitrary
 precision floating-point numbers (for the real and imaginary parts).
-The C data type for such objects is `mpc_t'.
+The C data type for such objects is 'mpc_t'.
 
 The "Precision" is the number of bits used to represent the mantissa of
 the real and imaginary parts; the corresponding C data type is
-`mpfr_prec_t'.  For more details on the allowed precision range, *note
-Nomenclature and Types: (mpfr.info)Nomenclature and Types.
+'mpfr_prec_t'.  For more details on the allowed precision range, *note
+(mpfr.info)Nomenclature and Types::.
 
 The "rounding mode" specifies the way to round the result of a complex
 operation, in case the exact result can not be represented exactly in
-the destination mantissa; the corresponding C data type is `mpc_rnd_t'.
+the destination mantissa; the corresponding C data type is 'mpc_rnd_t'.
 A complex rounding mode is a pair of two rounding modes: one for the
 real part, one for the imaginary part.
 
@@ -292,8 +289,8 @@ real part, one for the imaginary part.
 ====================
 
 There is only one class of functions in the MPC library, namely
-functions for complex arithmetic. The function names begin with `mpc_'.
-The associated type is `mpc_t'.
+functions for complex arithmetic.  The function names begin with 'mpc_'.
+The associated type is 'mpc_t'.
 
 4.3 MPC Variable Conventions
 ============================
@@ -304,8 +301,8 @@ assignment operator.
 
    MPC allows you to use the same variable for both input and output in
 the same expression.  For example, the main function for floating-point
-multiplication, `mpc_mul', can be used like this: `mpc_mul (x, x, x,
-rnd_mode)'.  This computes the square of X with rounding mode `rnd_mode'
+multiplication, 'mpc_mul', can be used like this: 'mpc_mul (x, x, x,
+rnd_mode)'.  This computes the square of X with rounding mode 'rnd_mode'
 and puts the result back in X.
 
    Before you can assign to an MPC variable, you need to initialize it
@@ -318,26 +315,26 @@ between each initialization.  After a variable has been initialized, it
 may be assigned to any number of times.
 
    For efficiency reasons, avoid to initialize and clear out a variable
-in loops.  Instead, initialize it before entering the loop, and clear
-it out after the loop has exited.
+in loops.  Instead, initialize it before entering the loop, and clear it
+out after the loop has exited.
 
-   You do not need to be concerned about allocating additional space
-for MPC variables, since each of its real and imaginary part has a
-mantissa of fixed size.  Hence unless you change its precision, or
-clear and reinitialize it, a complex variable will have the same
-allocated space during all its life.
+   You do not need to be concerned about allocating additional space for
+MPC variables, since each of its real and imaginary part has a mantissa
+of fixed size.  Hence unless you change its precision, or clear and
+reinitialize it, a complex variable will have the same allocated space
+during all its life.
 
 4.4 Rounding Modes
 ==================
 
-A complex rounding mode is of the form `MPC_RNDxy' where `x' and `y'
-are one of `N' (to nearest), `Z' (towards zero), `U' (towards plus
-infinity), `D' (towards minus infinity).  The first letter refers to
-the rounding mode for the real part, and the second one for the
-imaginary part.  For example `MPC_RNDZU' indicates to round the real
-part towards zero, and the imaginary part towards plus infinity.
+A complex rounding mode is of the form 'MPC_RNDxy' where 'x' and 'y' are
+one of 'N' (to nearest), 'Z' (towards zero), 'U' (towards plus
+infinity), 'D' (towards minus infinity).  The first letter refers to the
+rounding mode for the real part, and the second one for the imaginary
+part.  For example 'MPC_RNDZU' indicates to round the real part towards
+zero, and the imaginary part towards plus infinity.
 
-   The `round to nearest' mode works as in the IEEE P754 standard: in
+   The 'round to nearest' mode works as in the IEEE P754 standard: in
 case the number to be rounded lies exactly in the middle of two
 representable numbers, it is rounded to the one with the least
 significant bit set to zero.  For example, the number 5, which is
@@ -347,27 +344,27 @@ of two bits, and not to (110)=6.
 4.5 Return Value
 ================
 
-Most MPC functions have a return value of type `int', which is used to
+Most MPC functions have a return value of type 'int', which is used to
 indicate the position of the rounded real and imaginary parts with
 respect to the exact (infinite precision) values.  If this integer is
-`i', the macros `MPC_INEX_RE(i)' and `MPC_INEX_IM(i)' give 0 if the
+'i', the macros 'MPC_INEX_RE(i)' and 'MPC_INEX_IM(i)' give 0 if the
 corresponding rounded value is exact, a negative value if the rounded
 value is less than the exact one, and a positive value if it is greater
 than the exact one.  Similarly, functions computing a result of type
-`mpfr_t' return an integer that is 0, positive or negative depending on
+'mpfr_t' return an integer that is 0, positive or negative depending on
 whether the rounded value is the same, larger or smaller then the exact
 result.
 
-   Some functions, such as `mpc_sin_cos', compute two complex results;
-the macros `MPC_INEX1(i)' and `MPC_INEX2(i)', applied to the return
-value `i' of such a function, yield the exactness value corresponding
-to the first or the second computed value, respectively.
+   Some functions, such as 'mpc_sin_cos', compute two complex results;
+the macros 'MPC_INEX1(i)' and 'MPC_INEX2(i)', applied to the return
+value 'i' of such a function, yield the exactness value corresponding to
+the first or the second computed value, respectively.
 
 4.6 Branch Cuts And Special Values
 ==================================
 
 Some complex functions have branch cuts, across which the function is
-discontinous. In MPC, the branch cuts chosen are the same as those
+discontinous.  In MPC, the branch cuts chosen are the same as those
 specified for the corresponding functions in the ISO C99 standard.
 
    Likewise, when evaluated at a point whose real or imaginary part is
@@ -381,11 +378,11 @@ File: mpc.info,  Node: Complex Functions,  Next: Contributors,  Prev: MPC Basics
 5 Complex Functions
 *******************
 
-The complex functions expect arguments of type `mpc_t'.
+The complex functions expect arguments of type 'mpc_t'.
 
-   The MPC floating-point functions have an interface that is similar
-to the GNU MP integer functions.  The function prefix for operations on
-complex numbers is `mpc_'.
+   The MPC floating-point functions have an interface that is similar to
+the GNU MP integer functions.  The function prefix for operations on
+complex numbers is 'mpc_'.
 
    The precision of a computation is defined as follows: Compute the
 requested operation exactly (with "infinite precision"), and round the
@@ -393,9 +390,9 @@ result to the destination variable precision with the given rounding
 mode.
 
    The MPC complex functions are intended to be a smooth extension of
-the IEEE P754 arithmetic. The results obtained on one computer should
-not differ from the results obtained on a computer with a different
-word size.
+the IEEE P754 arithmetic.  The results obtained on one computer should
+not differ from the results obtained on a computer with a different word
+size.
 
 * Menu:
 
@@ -418,14 +415,14 @@ File: mpc.info,  Node: Initializing Complex Numbers,  Next: Assigning Complex Nu
 5.1 Initialization Functions
 ============================
 
-An `mpc_t' object must be initialized before storing the first value in
-it.  The functions `mpc_init2' and `mpc_init3' are used for that
+An 'mpc_t' object must be initialized before storing the first value in
+it.  The functions 'mpc_init2' and 'mpc_init3' are used for that
 purpose.
 
  -- Function: void mpc_init2 (mpc_t Z, mpfr_prec_t PREC)
      Initialize Z to precision PREC bits and set its real and imaginary
-     parts to NaN.  Normally, a variable should be initialized once only
-     or at least be cleared, using `mpc_clear', between initializations.
+     parts to NaN. Normally, a variable should be initialized once only
+     or at least be cleared, using 'mpc_clear', between initializations.
 
  -- Function: void mpc_init3 (mpc_t Z, mpfr_prec_t PREC_R, mpfr_prec_t
           PREC_I)
@@ -435,7 +432,7 @@ purpose.
 
  -- Function: void mpc_clear (mpc_t Z)
      Free the space occupied by Z.  Make sure to call this function for
-     all `mpc_t' variables when you are done with them.
+     all 'mpc_t' variables when you are done with them.
 
    Here is an example on how to initialize complex variables:
      {
@@ -455,9 +452,9 @@ numbers.
 
  -- Function: void mpc_set_prec (mpc_t X, mpfr_prec_t PREC)
      Reset the precision of X to be *exactly* PREC bits, and set its
-     real/imaginary parts to NaN.  The previous value stored in X is
-     lost. It is equivalent to a call to `mpc_clear(x)' followed by a
-     call to `mpc_init2(x, prec)', but more efficient as no allocation
+     real/imaginary parts to NaN. The previous value stored in X is
+     lost.  It is equivalent to a call to 'mpc_clear(x)' followed by a
+     call to 'mpc_init2(x, prec)', but more efficient as no allocation
      is done in case the current allocated space for the mantissa of X
      is sufficient.
 
@@ -478,20 +475,20 @@ File: mpc.info,  Node: Assigning Complex Numbers,  Next: Converting Complex Numb
 
 These functions assign new values to already initialized complex numbers
 (*note Initializing Complex Numbers::).  When using any functions with
-`intmax_t' or `uintmax_t' parameters, you must include `<stdint.h>' or
-`<inttypes.h>' _before_ `mpc.h', to allow `mpc.h' to define prototypes
+'intmax_t' or 'uintmax_t' parameters, you must include '<stdint.h>' or
+'<inttypes.h>' _before_ 'mpc.h', to allow 'mpc.h' to define prototypes
 for these functions.  Similarly, functions with parameters of type
-`complex' or `long complex' are defined only if `<complex.h>' is
-included _before_ `mpc.h'.  If you need assignment functions that are
-not in the current API, you can define them using the `MPC_SET_X_Y'
+'complex' or 'long complex' are defined only if '<complex.h>' is
+included _before_ 'mpc.h'.  If you need assignment functions that are
+not in the current API, you can define them using the 'MPC_SET_X_Y'
 macro (*note Advanced Functions::).
 
  -- Function: int mpc_set (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
      Set the value of ROP from OP, rounded to the precision of ROP with
      the given rounding mode RND.
 
- -- Function: int mpc_set_ui (mpc_t ROP, unsigned long int OP,
-          mpc_rnd_t RND)
+ -- Function: int mpc_set_ui (mpc_t ROP, unsigned long int OP, mpc_rnd_t
+          RND)
  -- Function: int mpc_set_si (mpc_t ROP, long int OP, mpc_rnd_t RND)
  -- Function: int mpc_set_uj (mpc_t ROP, uintmax_t OP, mpc_rnd_t RND)
  -- Function: int mpc_set_sj (mpc_t ROP, intmax_t OP, mpc_rnd_t RND)
@@ -508,9 +505,9 @@ macro (*note Advanced Functions::).
      Set the value of ROP from OP, rounded to the precision of ROP with
      the given rounding mode RND.  The argument OP is interpreted as
      real, so the imaginary part of ROP is set to zero with a positive
-     sign.  Please note that even a `long int' may have to be rounded,
+     sign.  Please note that even a 'long int' may have to be rounded,
      if the destination precision is less than the machine word width.
-     For `mpc_set_d', be careful that the input number OP may not be
+     For 'mpc_set_d', be careful that the input number OP may not be
      exactly representable as a double-precision number (this happens
      for 0.1 for instance), in which case it is first rounded by the C
      compiler to a double-precision number, and then only to a complex
@@ -526,8 +523,8 @@ macro (*note Advanced Functions::).
           mpc_rnd_t RND)
  -- Function: int mpc_set_d_d (mpc_t ROP, double OP1, double OP2,
           mpc_rnd_t RND)
- -- Function: int mpc_set_ld_ld (mpc_t ROP, long double OP1, long
-          double OP2, mpc_rnd_t RND)
+ -- Function: int mpc_set_ld_ld (mpc_t ROP, long double OP1, long double
+          OP2, mpc_rnd_t RND)
  -- Function: int mpc_set_z_z (mpc_t ROP, mpz_t OP1, mpz_t OP2,
           mpc_rnd_t RND)
  -- Function: int mpc_set_q_q (mpc_t ROP, mpq_t OP1, mpq_t OP2,
@@ -536,15 +533,15 @@ macro (*note Advanced Functions::).
           mpc_rnd_t RND)
  -- Function: int mpc_set_fr_fr (mpc_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpc_rnd_t RND)
-     Set the real part of ROP from OP1, and its imaginary part from
-     OP2, according to the rounding mode RND.
-
-     Beware that the behaviour of `mpc_set_fr_fr' is undefined if OP1
-     or OP2 is a pointer to the real or imaginary part of ROP.  To
-     exchange the real and the imaginary part of a complex number,
-     either use `mpfr_swap (mpc_realref (rop), mpc_imagref (rop))',
-     which also exchanges the precisions of the two parts; or use a
-     temporary variable.
+     Set the real part of ROP from OP1, and its imaginary part from OP2,
+     according to the rounding mode RND.
+
+     Beware that the behaviour of 'mpc_set_fr_fr' is undefined if OP1 or
+     OP2 is a pointer to the real or imaginary part of ROP.  To exchange
+     the real and the imaginary part of a complex number, either use
+     'mpfr_swap (mpc_realref (rop), mpc_imagref (rop))', which also
+     exchanges the precisions of the two parts; or use a temporary
+     variable.
 
    For functions assigning complex variables from strings or input
 streams, *note String and Stream Input and Output: string-io.
@@ -553,9 +550,9 @@ streams, *note String and Stream Input and Output: string-io.
      Set ROP to Nan+i*NaN.
 
  -- Function: void mpc_swap (mpc_t OP1, mpc_t OP2)
-     Swap the values of OP1 and OP2 efficiently. Warning: The
+     Swap the values of OP1 and OP2 efficiently.  Warning: The
      precisions are exchanged, too; in case these are different,
-     `mpc_swap' is thus not equivalent to three `mpc_set' calls using a
+     'mpc_swap' is thus not equivalent to three 'mpc_set' calls using a
      third auxiliary variable.
 
 
@@ -564,8 +561,8 @@ File: mpc.info,  Node: Converting Complex Numbers,  Next: String and Stream Inpu
 5.3 Conversion Functions
 ========================
 
-The following functions are available only if `<complex.h>' is included
-_before_ `mpc.h'.
+The following functions are available only if '<complex.h>' is included
+_before_ 'mpc.h'.
 
  -- Function: double _Complex mpc_get_dc (mpc_t OP, mpc_rnd_t RND)
  -- Function: long double _Complex mpc_get_ldc (mpc_t OP, mpc_rnd_t RND)
@@ -589,106 +586,105 @@ File: mpc.info,  Node: String and Stream Input and Output,  Next: Complex Compar
      stored in ROP, the usual inexact value is returned (*note Return
      Value: return-value.) and, if ENDPTR is not the null pointer,
      *ENDPTR points to the character just after the valid data.
-     Otherwise, ROP is set to `NaN + i * NaN', -1 is returned and, if
+     Otherwise, ROP is set to 'NaN + i * NaN', -1 is returned and, if
      ENDPTR is not the null pointer, the value of NPTR is stored in the
      location referenced by ENDPTR.
 
      The expected form of a complex number string is either a real
      number (an optional leading whitespace, an optional sign followed
      by a floating-point number), or a pair of real numbers in
-     parentheses separated by whitespace. If a real number is read, the
+     parentheses separated by whitespace.  If a real number is read, the
      missing imaginary part is set to +0.  The form of a floating-point
-     number depends on the base and is described in the documentation
-     of `mpfr_strtofr' (*note Assignment Functions:
-     (mpfr.info)Assignment Functions.).  For instance, `"3.1415926"',
-     `"(1.25e+7 +.17)"', `"(@nan@ 2)"' and `"(-0 -7)"' are valid
-     strings for BASE = 10.  If BASE = 0, then a prefix may be used to
-     indicate the base in which the floating-point number is written.
-     Use prefix '0b' for binary numbers, prefix '0x' for hexadecimal
-     numbers, and no prefix for decimal numbers.  The real and
-     imaginary part may then be written in different bases.  For
-     instance, `"(1.024e+3 +2.05e+3)"' and `"(0b1p+10 +0x802)"' are
-     valid strings for `base'=0 and represent the same value.
+     number depends on the base and is described in the documentation of
+     'mpfr_strtofr' (*note (mpfr.info)Assignment Functions::).  For
+     instance, '"3.1415926"', '"(1.25e+7 +.17)"', '"(@nan@ 2)"' and
+     '"(-0 -7)"' are valid strings for BASE = 10.  If BASE = 0, then a
+     prefix may be used to indicate the base in which the floating-point
+     number is written.  Use prefix '0b' for binary numbers, prefix '0x'
+     for hexadecimal numbers, and no prefix for decimal numbers.  The
+     real and imaginary part may then be written in different bases.
+     For instance, '"(1.024e+3 +2.05e+3)"' and '"(0b1p+10 +0x802)"' are
+     valid strings for 'base'=0 and represent the same value.
 
  -- Function: int mpc_set_str (mpc_t ROP, const char *S, int BASE,
           mpc_rnd_t rnd)
      Set ROP to the value of the string S in base BASE, rounded to the
      precision of ROP with the given rounding mode RND.  See the
-     documentation of `mpc_strtoc' for a detailed description of the
-     valid string formats.  Contrarily to `mpc_strtoc', `mpc_set_str'
+     documentation of 'mpc_strtoc' for a detailed description of the
+     valid string formats.  Contrarily to 'mpc_strtoc', 'mpc_set_str'
      requires the _whole_ string to represent a valid complex number
      (potentially followed by additional white space).  This function
-     returns the usual inexact value (*note Return Value:
-     return-value.) if the entire string up to the final null character
-     is a valid number in base BASE; otherwise it returns -1, and ROP
-     is set to NaN+i*NaN.
+     returns the usual inexact value (*note Return Value: return-value.)
+     if the entire string up to the final null character is a valid
+     number in base BASE; otherwise it returns -1, and ROP is set to
+     NaN+i*NaN.
 
  -- Function: char * mpc_get_str (int B, size_t N, mpc_t OP, mpc_rnd_t
           RND)
      Convert OP to a string containing its real and imaginary parts,
      separated by a space and enclosed in a pair of parentheses.  The
      numbers are written in base B (which may vary from 2 to 36) and
-     rounded according to RND. The number of significant digits, at
-     least 2, is given by N. It is also possible to let N be zero, in
+     rounded according to RND.  The number of significant digits, at
+     least 2, is given by N.  It is also possible to let N be zero, in
      which case the number of digits is chosen large enough so that
-     re-reading the printed value with the same precision, assuming
-     both output and input use rounding to nearest, will recover the
-     original value of OP.  Note that `mpc_get_str' uses the decimal
-     point of the current locale if available, and `.' otherwise.
+     re-reading the printed value with the same precision, assuming both
+     output and input use rounding to nearest, will recover the original
+     value of OP.  Note that 'mpc_get_str' uses the decimal point of the
+     current locale if available, and '.' otherwise.
 
      The string is generated using the current memory allocation
-     function (`malloc' by default, unless it has been modified using
-     the custom memory allocation interface of `gmp'); once it is not
-     needed any more, it should be freed by calling `mpc_free_str'.
+     function ('malloc' by default, unless it has been modified using
+     the custom memory allocation interface of 'gmp'); once it is not
+     needed any more, it should be freed by calling 'mpc_free_str'.
 
  -- Function: void mpc_free_str (char *STR)
      Free the string STR, which needs to have been allocated by a call
-     to `mpc_get_str'.
+     to 'mpc_get_str'.
 
    The following two functions read numbers from input streams and write
 them to output streams.  When using any of these functions, you need to
-include `stdio.h' _before_ `mpc.h'.
+include 'stdio.h' _before_ 'mpc.h'.
 
  -- Function: int mpc_inp_str (mpc_t ROP, FILE *STREAM, size_t *READ,
           int BASE, mpc_rnd_t RND)
-     Input a string in base BASE in the same format as for `mpc_strtoc'
+     Input a string in base BASE in the same format as for 'mpc_strtoc'
      from stdio stream STREAM, rounded according to RND, and put the
      read complex number into ROP.  If STREAM is the null pointer, ROP
-     is read from `stdin'.  Return the usual inexact value; if an error
-     occurs, set ROP to `NaN + i * NaN' and return -1.  If READ is not
+     is read from 'stdin'.  Return the usual inexact value; if an error
+     occurs, set ROP to 'NaN + i * NaN' and return -1.  If READ is not
      the null pointer, it is set to the number of read characters.
 
-     Unlike `mpc_strtoc', the function `mpc_inp_str' does not possess
+     Unlike 'mpc_strtoc', the function 'mpc_inp_str' does not possess
      perfect knowledge of the string to transform and has to read it
      character by character, so it behaves slightly differently: It
      tries to read a string describing a complex number and processes
-     this string through a call to `mpc_set_str'. Precisely, after
-     skipping optional whitespace, a minimal string is read according
-     to the regular expression `mpfr | '(' \s* mpfr \s+ mpfr \s* ')'',
-     where `\s' denotes a whitespace, and `mpfr' is either a string
+     this string through a call to 'mpc_set_str'.  Precisely, after
+     skipping optional whitespace, a minimal string is read according to
+     the regular expression 'mpfr | '(' \s* mpfr \s+ mpfr \s* ')'',
+     where '\s' denotes a whitespace, and 'mpfr' is either a string
      containing neither whitespaces nor parentheses, or
-     `nan(n-char-sequence)' or `@nan@(n-char-sequence)' (regardless of
-     capitalisation) with `n-char-sequence' a string of ascii letters,
-     digits or `'_''.
+     'nan(n-char-sequence)' or '@nan@(n-char-sequence)' (regardless of
+     capitalisation) with 'n-char-sequence' a string of ascii letters,
+     digits or ''_''.
 
-     For instance, upon input of `"nan(13 1)"', the function
-     `mpc_inp_str' starts to recognise a value of NaN followed by an
+     For instance, upon input of '"nan(13 1)"', the function
+     'mpc_inp_str' starts to recognise a value of NaN followed by an
      n-char-sequence indicated by the opening parenthesis; as soon as
      the space is reached, it becocmes clear that the expression in
      parentheses is not an n-char-sequence, and the error flag -1 is
-     returned after 6 characters have been consumed from the stream
-     (the whitespace itself remaining in the stream).  The function
-     `mpc_strtoc', on the other hand, may track back when reaching the
+     returned after 6 characters have been consumed from the stream (the
+     whitespace itself remaining in the stream).  The function
+     'mpc_strtoc', on the other hand, may track back when reaching the
      whitespace; it treats the string as the two successive complex
-     numbers `NaN + i * 0' and `13 + i'.  It is thus recommended to
-     have a whitespace follow each floating point number to avoid this
+     numbers 'NaN + i * 0' and '13 + i'.  It is thus recommended to have
+     a whitespace follow each floating point number to avoid this
      problem.
 
  -- Function: size_t mpc_out_str (FILE *STREAM, int BASE, size_t
           N_DIGITS, mpc_t OP, mpc_rnd_t RND)
-     Output OP on stdio stream STREAM in base BASE, rounded according
-     to RND, in the same format as for `mpc_strtoc' If STREAM is the
-     null pointer, ROP is written to `stdout'.
+     Output OP on stdio stream STREAM in base BASE, rounded according to
+     RND, in the same format as for 'mpc_strtoc' If STREAM is the null
+     pointer, ROP is written to 'stdout'.
 
      Return the number of characters written.
 
@@ -702,18 +698,18 @@ File: mpc.info,  Node: Complex Comparison,  Next: Projection & Decomposing,  Pre
  -- Function: int mpc_cmp_si_si (mpc_t OP1, long int OP2R, long int
           OP2I)
  -- Macro: int mpc_cmp_si (mpc_t OP1, long int OP2)
-     Compare OP1 and OP2, where in the case of `mpc_cmp_si_si', OP2 is
+
+     Compare OP1 and OP2, where in the case of 'mpc_cmp_si_si', OP2 is
      taken to be OP2R + i OP2I.  The return value C can be decomposed
-     into `x = MPC_INEX_RE(c)' and `y = MPC_INEX_IM(c)', such that X is
+     into 'x = MPC_INEX_RE(c)' and 'y = MPC_INEX_IM(c)', such that X is
      positive if the real part of OP1 is greater than that of OP2, zero
      if both real parts are equal, and negative if the real part of OP1
-     is less than that of OP2, and likewise for Y.  Both OP1 and OP2
-     are considered to their full own precision, which may differ.  It
-     is not allowed that one of the operands has a NaN (Not-a-Number)
-     part.
+     is less than that of OP2, and likewise for Y.  Both OP1 and OP2 are
+     considered to their full own precision, which may differ.  It is
+     not allowed that one of the operands has a NaN (Not-a-Number) part.
 
-     The storage of the return value is such that equality can be
-     simply checked with `mpc_cmp (op1, op2) == 0'.
+     The storage of the return value is such that equality can be simply
+     checked with 'mpc_cmp (op1, op2) == 0'.
 
 
 File: mpc.info,  Node: Projection & Decomposing,  Next: Basic Arithmetic,  Prev: Complex Comparison,  Up: Complex Functions
@@ -732,15 +728,15 @@ File: mpc.info,  Node: Projection & Decomposing,  Next: Basic Arithmetic,  Prev:
  -- Macro: mpfr_t mpc_realref (mpc_t OP)
  -- Macro: mpfr_t mpc_imagref (mpc_t OP)
      Return a reference to the real part and imaginary part of OP,
-     respectively. The `mpfr' functions can be used on the result of
-     these macros (note that the `mpfr_t' type is itself a pointer).
+     respectively.  The 'mpfr' functions can be used on the result of
+     these macros (note that the 'mpfr_t' type is itself a pointer).
 
  -- Function: int mpc_arg (mpfr_t ROP, mpc_t OP, mpfr_rnd_t RND)
-     Set ROP to the argument of OP, with a branch cut along the
-     negative real axis.
+     Set ROP to the argument of OP, with a branch cut along the negative
+     real axis.
 
  -- Function: int mpc_proj (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Compute a projection of OP onto the Riemann sphere. Set ROP to OP
+     Compute a projection of OP onto the Riemann sphere.  Set ROP to OP
      rounded in the direction RND, except when at least one part of OP
      is infinite (even if the other part is a NaN) in which case the
      real part of ROP is set to plus infinity and its imaginary part to
@@ -778,7 +774,7 @@ marginal overhead due to the MPC layer.
  -- Function: int mpc_ui_ui_sub (mpc_t ROP, unsigned long int RE1,
           unsigned long int IM1, mpc_t OP2, mpc_rnd_t RND)
      Set ROP to OP1 - OP2 rounded according to RND.  For
-     `mpc_ui_ui_sub', OP1 is RE1 + IM1.
+     'mpc_ui_ui_sub', OP1 is RE1 + IM1.
 
  -- Function: int mpc_mul (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_rnd_t
           RND)
@@ -809,10 +805,10 @@ marginal overhead due to the MPC layer.
           mpc_rnd_t RND)
  -- Function: int mpc_fr_div (mpc_t ROP, mpfr_t OP1, mpc_t OP2,
           mpc_rnd_t RND)
-     Set ROP to OP1/OP2 rounded according to RND.  For `mpc_div' and
-     `mpc_ui_div', the return value may fail to recognize some exact
-     results. The sign of returned value is significant only for
-     `mpc_div_ui'.
+     Set ROP to OP1/OP2 rounded according to RND.  For 'mpc_div' and
+     'mpc_ui_div', the return value may fail to recognize some exact
+     results.  The sign of returned value is significant only for
+     'mpc_div_ui'.
 
  -- Function: int mpc_neg (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
      Set ROP to -OP rounded according to RND.  Just changes the sign if
@@ -832,7 +828,7 @@ marginal overhead due to the MPC layer.
      Set the floating-point number ROP to the norm of OP (i.e., the
      square of its absolute value), rounded in the direction RND.  The
      returned value is zero iff the result is exact.  Note that the
-     destination is of type `mpfr_t', not `mpc_t'.
+     destination is of type 'mpfr_t', not 'mpc_t'.
 
  -- Function: int mpc_mul_2exp (mpc_t ROP, mpc_t OP1, unsigned long int
           OP2, mpc_rnd_t RND)
@@ -842,9 +838,9 @@ marginal overhead due to the MPC layer.
 
  -- Function: int mpc_div_2exp (mpc_t ROP, mpc_t OP1, unsigned long int
           OP2, mpc_rnd_t RND)
-     Set ROP to OP1 divided by 2 raised to OP2 rounded according to
-     RND. Just decreases the exponents of the real and imaginary parts
-     by OP2 when ROP and OP1 are identical.
+     Set ROP to OP1 divided by 2 raised to OP2 rounded according to RND.
+     Just decreases the exponents of the real and imaginary parts by OP2
+     when ROP and OP1 are identical.
 
  -- Function: int mpc_fma (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_t OP3,
           mpc_rnd_t RND)
@@ -862,8 +858,8 @@ File: mpc.info,  Node: Power Functions and Logarithm,  Next: Trigonometric Funct
 
  -- Function: int mpc_pow (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_rnd_t
           RND)
- -- Function: int mpc_pow_d (mpc_t ROP, mpc_t OP1, double OP2,
-          mpc_rnd_t RND)
+ -- Function: int mpc_pow_d (mpc_t ROP, mpc_t OP1, double OP2, mpc_rnd_t
+          RND)
  -- Function: int mpc_pow_ld (mpc_t ROP, mpc_t OP1, long double OP2,
           mpc_rnd_t RND)
  -- Function: int mpc_pow_si (mpc_t ROP, mpc_t OP1, long OP2, mpc_rnd_t
@@ -875,13 +871,13 @@ File: mpc.info,  Node: Power Functions and Logarithm,  Next: Trigonometric Funct
  -- Function: int mpc_pow_fr (mpc_t ROP, mpc_t OP1, mpfr_t OP2,
           mpc_rnd_t RND)
      Set ROP to OP1 raised to the power OP2, rounded according to RND.
-     For `mpc_pow_d', `mpc_pow_ld', `mpc_pow_si', `mpc_pow_ui',
-     `mpc_pow_z' and `mpc_pow_fr', the imaginary part of OP2 is
+     For 'mpc_pow_d', 'mpc_pow_ld', 'mpc_pow_si', 'mpc_pow_ui',
+     'mpc_pow_z' and 'mpc_pow_fr', the imaginary part of OP2 is
      considered as +0.
 
  -- Function: int mpc_exp (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the exponential of OP, rounded according to RND with
-     the precision of ROP.
+     Set ROP to the exponential of OP, rounded according to RND with the
+     precision of ROP.
 
  -- Function: int mpc_log (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
      Set ROP to the logarithm of OP, rounded according to RND with the
@@ -914,8 +910,8 @@ File: mpc.info,  Node: Trigonometric Functions,  Next: Miscellaneous Complex Fun
      precision of ROP.
 
  -- Function: int mpc_sinh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the hyperbolic sine of OP, rounded according to RND
-     with the precision of ROP.
+     Set ROP to the hyperbolic sine of OP, rounded according to RND with
+     the precision of ROP.
 
  -- Function: int mpc_cosh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
      Set ROP to the hyperbolic cosine of OP, rounded according to RND
@@ -935,8 +931,8 @@ File: mpc.info,  Node: Trigonometric Functions,  Next: Miscellaneous Complex Fun
  -- Function: int mpc_acosh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
  -- Function: int mpc_atanh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
      Set ROP to the inverse hyperbolic sine, inverse hyperbolic cosine,
-     inverse hyperbolic tangent of OP, rounded according to RND with
-     the precision of ROP.  The branch cut of MPC_ACOSH is (-\infty, 1).
+     inverse hyperbolic tangent of OP, rounded according to RND with the
+     precision of ROP.  The branch cut of MPC_ACOSH is (-\infty, 1).
 
 
 File: mpc.info,  Node: Miscellaneous Complex Functions,  Next: Advanced Functions,  Prev: Trigonometric Functions,  Up: Complex Functions
@@ -946,11 +942,11 @@ File: mpc.info,  Node: Miscellaneous Complex Functions,  Next: Advanced Function
 
  -- Function: int mpc_urandom (mpc_t ROP, gmp_randstate_t STATE)
      Generate a uniformly distributed random complex in the unit square
-     [0, 1] * [0, 1]. Return 0, unless an exponent in the real or
+     [0, 1] * [0, 1].  Return 0, unless an exponent in the real or
      imaginary part is not in the current exponent range, in which case
-     that part is set to NaN and a zero value is returned. The second
-     argument is a `gmp_randstate_t' structure which should be created
-     using the GMP `rand_init' function, see the GMP manual.
+     that part is set to NaN and a zero value is returned.  The second
+     argument is a 'gmp_randstate_t' structure which should be created
+     using the GMP 'rand_init' function, see the GMP manual.
 
  -- Function: const char * mpc_get_version (void)
      Return the MPC version, as a null-terminated string.
@@ -960,13 +956,13 @@ File: mpc.info,  Node: Miscellaneous Complex Functions,  Next: Advanced Function
  -- Macro: MPC_VERSION_MINOR
  -- Macro: MPC_VERSION_PATCHLEVEL
  -- Macro: MPC_VERSION_STRING
-     `MPC_VERSION' is the version of MPC as a preprocessing constant.
-     `MPC_VERSION_MAJOR', `MPC_VERSION_MINOR' and
-     `MPC_VERSION_PATCHLEVEL' are respectively the major, minor and
+     'MPC_VERSION' is the version of MPC as a preprocessing constant.
+     'MPC_VERSION_MAJOR', 'MPC_VERSION_MINOR' and
+     'MPC_VERSION_PATCHLEVEL' are respectively the major, minor and
      patch level of MPC version, as preprocessing constants.
-     `MPC_VERSION_STRING' is the version as a string constant, which
-     can be compared to the result of `mpc_get_version' to check at run
-     time the header file and library used match:
+     'MPC_VERSION_STRING' is the version as a string constant, which can
+     be compared to the result of 'mpc_get_version' to check at run time
+     the header file and library used match:
           if (strcmp (mpc_get_version (), MPC_VERSION_STRING))
             fprintf (stderr, "Warning: header and library do not match\n");
      Note: Obtaining different strings is not necessarily an error, as
@@ -975,7 +971,7 @@ File: mpc.info,  Node: Miscellaneous Complex Functions,  Next: Advanced Function
      the library versioning system).
 
  -- Macro: long MPC_VERSION_NUM (MAJOR, MINOR, PATCHLEVEL)
-     Create an integer in the same format as used by `MPC_VERSION' from
+     Create an integer in the same format as used by 'MPC_VERSION' from
      the given MAJOR, MINOR and PATCHLEVEL.  Here is an example of how
      to check the MPC version at compile time:
           #if (!defined(MPC_VERSION) || (MPC_VERSION<MPC_VERSION_NUM(2,1,0)))
@@ -992,11 +988,11 @@ File: mpc.info,  Node: Advanced Functions,  Next: Internals,  Prev: Miscellaneou
      The macro MPC_SET_X_Y is designed to serve as the body of an
      assignment function and cannot be used by itself.  The REAL_SUFFIX
      and IMAG_SUFFIX parameters are the types of the real and imaginary
-     part, that is, the `x' in the `mpfr_set_x' function one would use
-     to set the part; for the mpfr type, use `fr'.  REAL (respectively
+     part, that is, the 'x' in the 'mpfr_set_x' function one would use
+     to set the part; for the mpfr type, use 'fr'.  REAL (respectively
      IMAG) is the value you want to assign to the real (resp.
      imaginary) part, its type must conform to REAL_SUFFIX (resp.
-     IMAG_SUFFIX).  RND is the `mpc_rnd_t' rounding mode.  The return
+     IMAG_SUFFIX).  RND is the 'mpc_rnd_t' rounding mode.  The return
      value is the usual inexact value (*note Return Value:
      return-value.).
 
@@ -1010,12 +1006,11 @@ File: mpc.info,  Node: Internals,  Prev: Advanced Functions,  Up: Complex Functi
 5.12 Internals
 ==============
 
-These macros and functions are mainly designed for the implementation
-of MPC, but may be useful for users too.  However, no upward
-compatibility is guaranteed.  You need to include `mpc-impl.h' to use
-them.
+These macros and functions are mainly designed for the implementation of
+MPC, but may be useful for users too.  However, no upward compatibility
+is guaranteed.  You need to include 'mpc-impl.h' to use them.
 
-   The macro `MPC_MAX_PREC(z)' gives the maximum of the precisions of
+   The macro 'MPC_MAX_PREC(z)' gives the maximum of the precisions of
 the real and imaginary parts of a complex number.
 
 
@@ -1025,9 +1020,9 @@ Contributors
 ************
 
 The main developers of the MPC library are Andreas Enge, Philippe
-The'veny and Paul Zimmermann.  Patrick Pe'lissier has helped cleaning
-up the code.  Marc Helbling contributed the `mpc_ui_sub' and
-`mpc_ui_ui_sub' functions.
+The'veny and Paul Zimmermann.  Patrick Pe'lissier has helped cleaning up
+the code.  Marc Helbling contributed the 'mpc_ui_sub' and
+'mpc_ui_ui_sub' functions.
 
 
 File: mpc.info,  Node: References,  Next: Concept Index,  Prev: Contributors,  Up: Top
@@ -1035,25 +1030,24 @@ File: mpc.info,  Node: References,  Next: Concept Index,  Prev: Contributors,  U
 References
 **********
 
-   * Torbjo"rn Granlund et al.  `gmp' - GNU multiprecision library.
-     Version 4.2.4, `http://gmplib.org/'.
+   * Torbjo"rn Granlund et al.  'gmp' - GNU multiprecision library.
+     Version 4.2.4, <http://gmplib.org/>.
 
    * Guillaume Hanrot, Vincent Lefe`vre, Patrick Pe'lissier, Paul
-     Zimmermann et al.  `mpfr' - A library for multiple-precision
-     floating-point               computations with exact rounding.
-     Version 2.4.1, `http://www.mpfr.org'.
+     Zimmermann et al.  'mpfr' - A library for multiple-precision
+     floating-point computations with exact rounding.  Version 2.4.1,
+     <http://www.mpfr.org>.
 
    * IEEE standard for binary floating-point arithmetic, Technical
-     Report ANSI-IEEE Standard 754-1985, New York, 1985.  Approved
-     March 21, 1985: IEEE Standards Board; approved July 26,   1985:
-     American National Standards Institute, 18 pages.
+     Report ANSI-IEEE Standard 754-1985, New York, 1985.  Approved March
+     21, 1985: IEEE Standards Board; approved July 26, 1985: American
+     National Standards Institute, 18 pages.
 
    * Donald E. Knuth, "The Art of Computer Programming", vol 2,
      "Seminumerical Algorithms", 2nd edition, Addison-Wesley, 1981.
 
    * ISO/IEC 9899:1999, Programming languages  C.
 
-
 
 File: mpc.info,  Node: Concept Index,  Next: Function Index,  Prev: References,  Up: Top
 
@@ -1104,219 +1098,219 @@ Function and Type Index
 * Menu:
 
 * _Complex:                              Converting Complex Numbers.
-                                                              (line  10)
-* mpc_abs:                               Basic Arithmetic.    (line  78)
+                                                              (line   9)
+* mpc_abs:                               Basic Arithmetic.    (line  77)
 * mpc_acos:                              Trigonometric Functions.
-                                                              (line  38)
+                                                              (line  37)
 * mpc_acosh:                             Trigonometric Functions.
-                                                              (line  44)
-* mpc_add:                               Basic Arithmetic.    (line  13)
-* mpc_add_fr:                            Basic Arithmetic.    (line  17)
-* mpc_add_ui:                            Basic Arithmetic.    (line  15)
+                                                              (line  43)
+* mpc_add:                               Basic Arithmetic.    (line  11)
+* mpc_add_fr:                            Basic Arithmetic.    (line  15)
+* mpc_add_ui:                            Basic Arithmetic.    (line  13)
 * mpc_arg:                               Projection & Decomposing.
-                                                              (line  21)
+                                                              (line  20)
 * mpc_asin:                              Trigonometric Functions.
-                                                              (line  37)
+                                                              (line  36)
 * mpc_asinh:                             Trigonometric Functions.
-                                                              (line  43)
+                                                              (line  42)
 * mpc_atan:                              Trigonometric Functions.
-                                                              (line  39)
+                                                              (line  38)
 * mpc_atanh:                             Trigonometric Functions.
-                                                              (line  45)
+                                                              (line  44)
 * mpc_clear:                             Initializing Complex Numbers.
-                                                              (line  22)
-* mpc_cmp:                               Complex Comparison.  (line   7)
-* mpc_cmp_si:                            Complex Comparison.  (line  10)
-* mpc_cmp_si_si:                         Complex Comparison.  (line   9)
-* mpc_conj:                              Basic Arithmetic.    (line  73)
+                                                              (line  21)
+* mpc_cmp:                               Complex Comparison.  (line   6)
+* mpc_cmp_si:                            Complex Comparison.  (line   9)
+* mpc_cmp_si_si:                         Complex Comparison.  (line   7)
+* mpc_conj:                              Basic Arithmetic.    (line  72)
 * mpc_cos:                               Trigonometric Functions.
-                                                              (line  11)
+                                                              (line  10)
 * mpc_cosh:                              Trigonometric Functions.
-                                                              (line  29)
-* mpc_div:                               Basic Arithmetic.    (line  55)
-* mpc_div_2exp:                          Basic Arithmetic.    (line  96)
-* mpc_div_fr:                            Basic Arithmetic.    (line  61)
-* mpc_div_ui:                            Basic Arithmetic.    (line  57)
+                                                              (line  28)
+* mpc_div:                               Basic Arithmetic.    (line  53)
+* mpc_div_2exp:                          Basic Arithmetic.    (line  94)
+* mpc_div_fr:                            Basic Arithmetic.    (line  59)
+* mpc_div_ui:                            Basic Arithmetic.    (line  55)
 * mpc_exp:                               Power Functions and Logarithm.
-                                                              (line  29)
-* mpc_fma:                               Basic Arithmetic.    (line 102)
-* mpc_fr_div:                            Basic Arithmetic.    (line  63)
-* mpc_fr_sub:                            Basic Arithmetic.    (line  25)
+                                                              (line  28)
+* mpc_fma:                               Basic Arithmetic.    (line 100)
 * mpc_free_str:                          String and Stream Input and Output.
-                                                              (line  68)
+                                                              (line  66)
+* mpc_fr_div:                            Basic Arithmetic.    (line  61)
+* mpc_fr_sub:                            Basic Arithmetic.    (line  23)
 * mpc_get_ldc:                           Converting Complex Numbers.
-                                                              (line  11)
+                                                              (line  10)
 * mpc_get_prec:                          Initializing Complex Numbers.
-                                                              (line  50)
+                                                              (line  49)
 * mpc_get_prec2:                         Initializing Complex Numbers.
-                                                              (line  55)
+                                                              (line  53)
 * mpc_get_str:                           String and Stream Input and Output.
-                                                              (line  51)
+                                                              (line  48)
 * mpc_get_version:                       Miscellaneous Complex Functions.
-                                                              (line  15)
+                                                              (line  14)
 * mpc_imag:                              Projection & Decomposing.
-                                                              (line  11)
+                                                              (line  10)
 * mpc_imagref:                           Projection & Decomposing.
-                                                              (line  16)
+                                                              (line  15)
 * mpc_init2:                             Initializing Complex Numbers.
-                                                              (line  11)
+                                                              (line  10)
 * mpc_init3:                             Initializing Complex Numbers.
-                                                              (line  17)
+                                                              (line  15)
 * mpc_inp_str:                           String and Stream Input and Output.
-                                                              (line  77)
+                                                              (line  74)
 * mpc_log:                               Power Functions and Logarithm.
-                                                              (line  33)
-* mpc_mul:                               Basic Arithmetic.    (line  36)
-* mpc_mul_2exp:                          Basic Arithmetic.    (line  90)
-* mpc_mul_fr:                            Basic Arithmetic.    (line  42)
-* mpc_mul_i:                             Basic Arithmetic.    (line  46)
-* mpc_mul_si:                            Basic Arithmetic.    (line  40)
-* mpc_mul_ui:                            Basic Arithmetic.    (line  38)
-* mpc_neg:                               Basic Arithmetic.    (line  69)
-* mpc_norm:                              Basic Arithmetic.    (line  83)
+                                                              (line  32)
+* mpc_mul:                               Basic Arithmetic.    (line  34)
+* mpc_mul_2exp:                          Basic Arithmetic.    (line  88)
+* mpc_mul_fr:                            Basic Arithmetic.    (line  40)
+* mpc_mul_i:                             Basic Arithmetic.    (line  44)
+* mpc_mul_si:                            Basic Arithmetic.    (line  38)
+* mpc_mul_ui:                            Basic Arithmetic.    (line  36)
+* mpc_neg:                               Basic Arithmetic.    (line  68)
+* mpc_norm:                              Basic Arithmetic.    (line  82)
 * mpc_out_str:                           String and Stream Input and Output.
-                                                              (line 112)
+                                                              (line 109)
 * mpc_pow:                               Power Functions and Logarithm.
-                                                              (line  11)
+                                                              (line   9)
 * mpc_pow_d:                             Power Functions and Logarithm.
-                                                              (line  13)
+                                                              (line  11)
 * mpc_pow_fr:                            Power Functions and Logarithm.
-                                                              (line  23)
+                                                              (line  21)
 * mpc_pow_ld:                            Power Functions and Logarithm.
-                                                              (line  15)
+                                                              (line  13)
 * mpc_pow_si:                            Power Functions and Logarithm.
-                                                              (line  17)
+                                                              (line  15)
 * mpc_pow_ui:                            Power Functions and Logarithm.
-                                                              (line  19)
+                                                              (line  17)
 * mpc_pow_z:                             Power Functions and Logarithm.
-                                                              (line  21)
+                                                              (line  19)
 * mpc_proj:                              Projection & Decomposing.
-                                                              (line  25)
+                                                              (line  24)
 * mpc_real:                              Projection & Decomposing.
-                                                              (line   7)
+                                                              (line   6)
 * mpc_realref:                           Projection & Decomposing.
-                                                              (line  15)
+                                                              (line  14)
 * mpc_rnd_t:                             MPC Basics.          (line  24)
 * mpc_set:                               Assigning Complex Numbers.
-                                                              (line  17)
+                                                              (line  16)
 * mpc_set_d:                             Assigning Complex Numbers.
-                                                              (line  26)
-* mpc_set_d_d:                           Assigning Complex Numbers.
-                                                              (line  56)
+                                                              (line  25)
 * mpc_set_dc:                            Assigning Complex Numbers.
-                                                              (line  29)
+                                                              (line  27)
+* mpc_set_d_d:                           Assigning Complex Numbers.
+                                                              (line  54)
 * mpc_set_f:                             Assigning Complex Numbers.
-                                                              (line  34)
-* mpc_set_f_f:                           Assigning Complex Numbers.
-                                                              (line  64)
+                                                              (line  33)
 * mpc_set_fr:                            Assigning Complex Numbers.
-                                                              (line  35)
+                                                              (line  34)
 * mpc_set_fr_fr:                         Assigning Complex Numbers.
-                                                              (line  66)
+                                                              (line  64)
+* mpc_set_f_f:                           Assigning Complex Numbers.
+                                                              (line  62)
 * mpc_set_ld:                            Assigning Complex Numbers.
-                                                              (line  27)
-* mpc_set_ld_ld:                         Assigning Complex Numbers.
-                                                              (line  58)
+                                                              (line  26)
 * mpc_set_ldc:                           Assigning Complex Numbers.
-                                                              (line  31)
+                                                              (line  29)
+* mpc_set_ld_ld:                         Assigning Complex Numbers.
+                                                              (line  56)
 * mpc_set_nan:                           Assigning Complex Numbers.
-                                                              (line  80)
+                                                              (line  79)
 * mpc_set_prec:                          Initializing Complex Numbers.
-                                                              (line  42)
+                                                              (line  41)
 * mpc_set_q:                             Assigning Complex Numbers.
-                                                              (line  33)
+                                                              (line  32)
 * mpc_set_q_q:                           Assigning Complex Numbers.
-                                                              (line  62)
+                                                              (line  60)
 * mpc_set_si:                            Assigning Complex Numbers.
-                                                              (line  23)
+                                                              (line  22)
 * mpc_set_si_si:                         Assigning Complex Numbers.
-                                                              (line  50)
+                                                              (line  48)
 * mpc_set_sj:                            Assigning Complex Numbers.
-                                                              (line  25)
+                                                              (line  24)
 * mpc_set_sj_sj:                         Assigning Complex Numbers.
-                                                              (line  54)
+                                                              (line  52)
 * mpc_set_str:                           String and Stream Input and Output.
-                                                              (line  38)
+                                                              (line  35)
 * mpc_set_ui:                            Assigning Complex Numbers.
-                                                              (line  22)
+                                                              (line  20)
 * mpc_set_ui_ui:                         Assigning Complex Numbers.
-                                                              (line  48)
+                                                              (line  46)
 * mpc_set_uj:                            Assigning Complex Numbers.
-                                                              (line  24)
+                                                              (line  23)
 * mpc_set_uj_uj:                         Assigning Complex Numbers.
-                                                              (line  52)
-* MPC_SET_X_Y:                           Advanced Functions.  (line   7)
+                                                              (line  50)
+* MPC_SET_X_Y:                           Advanced Functions.  (line   6)
 * mpc_set_z:                             Assigning Complex Numbers.
-                                                              (line  32)
+                                                              (line  31)
 * mpc_set_z_z:                           Assigning Complex Numbers.
-                                                              (line  60)
+                                                              (line  58)
 * mpc_sin:                               Trigonometric Functions.
-                                                              (line   7)
-* mpc_sin_cos:                           Trigonometric Functions.
-                                                              (line  16)
+                                                              (line   6)
 * mpc_sinh:                              Trigonometric Functions.
-                                                              (line  25)
-* mpc_sqr:                               Basic Arithmetic.    (line  51)
+                                                              (line  24)
+* mpc_sin_cos:                           Trigonometric Functions.
+                                                              (line  14)
+* mpc_sqr:                               Basic Arithmetic.    (line  50)
 * mpc_sqrt:                              Power Functions and Logarithm.
-                                                              (line   7)
+                                                              (line   6)
 * mpc_strtoc:                            String and Stream Input and Output.
-                                                              (line   8)
-* mpc_sub:                               Basic Arithmetic.    (line  21)
-* mpc_sub_fr:                            Basic Arithmetic.    (line  23)
-* mpc_sub_ui:                            Basic Arithmetic.    (line  27)
+                                                              (line   6)
+* mpc_sub:                               Basic Arithmetic.    (line  19)
+* mpc_sub_fr:                            Basic Arithmetic.    (line  21)
+* mpc_sub_ui:                            Basic Arithmetic.    (line  25)
 * mpc_swap:                              Assigning Complex Numbers.
-                                                              (line  83)
+                                                              (line  82)
 * mpc_t:                                 MPC Basics.          (line  15)
 * mpc_tan:                               Trigonometric Functions.
-                                                              (line  21)
+                                                              (line  20)
 * mpc_tanh:                              Trigonometric Functions.
-                                                              (line  33)
-* mpc_ui_div:                            Basic Arithmetic.    (line  59)
-* mpc_ui_sub:                            Basic Arithmetic.    (line  29)
-* mpc_ui_ui_sub:                         Basic Arithmetic.    (line  31)
+                                                              (line  32)
+* mpc_ui_div:                            Basic Arithmetic.    (line  57)
+* mpc_ui_sub:                            Basic Arithmetic.    (line  27)
+* mpc_ui_ui_sub:                         Basic Arithmetic.    (line  29)
 * mpc_urandom:                           Miscellaneous Complex Functions.
-                                                              (line   7)
+                                                              (line   6)
 * MPC_VERSION:                           Miscellaneous Complex Functions.
-                                                              (line  18)
+                                                              (line  17)
 * MPC_VERSION_MAJOR:                     Miscellaneous Complex Functions.
-                                                              (line  19)
+                                                              (line  18)
 * MPC_VERSION_MINOR:                     Miscellaneous Complex Functions.
-                                                              (line  20)
+                                                              (line  19)
 * MPC_VERSION_NUM:                       Miscellaneous Complex Functions.
-                                                              (line  37)
+                                                              (line  36)
 * MPC_VERSION_PATCHLEVEL:                Miscellaneous Complex Functions.
-                                                              (line  21)
+                                                              (line  20)
 * MPC_VERSION_STRING:                    Miscellaneous Complex Functions.
-                                                              (line  22)
+                                                              (line  21)
 * mpfr_prec_t:                           MPC Basics.          (line  19)
 
 
 
 Tag Table:
-Node: Top946
-Node: Copying1607
-Node: Introduction to MPC2265
-Node: Installing MPC2973
-Node: Reporting Bugs7632
-Node: MPC Basics8961
-Ref: return-value12611
-Node: Complex Functions14053
-Node: Initializing Complex Numbers15202
-Node: Assigning Complex Numbers17616
-Node: Converting Complex Numbers22024
-Node: String and Stream Input and Output22658
-Ref: string-io22805
-Node: Complex Comparison29237
-Node: Projection & Decomposing30316
-Node: Basic Arithmetic31691
-Node: Power Functions and Logarithm36331
-Node: Trigonometric Functions37986
-Node: Miscellaneous Complex Functions40211
-Node: Advanced Functions42356
-Node: Internals43429
-Node: Contributors43876
-Node: References44222
-Node: Concept Index45136
-Node: Function Index47450
+Node: Top942
+Node: Copying1603
+Node: Introduction to MPC2260
+Node: Installing MPC2969
+Node: Reporting Bugs7631
+Node: MPC Basics8963
+Ref: return-value12592
+Node: Complex Functions14035
+Node: Initializing Complex Numbers15185
+Node: Assigning Complex Numbers17598
+Node: Converting Complex Numbers22007
+Node: String and Stream Input and Output22641
+Ref: string-io22788
+Node: Complex Comparison29198
+Node: Projection & Decomposing30273
+Node: Basic Arithmetic31650
+Node: Power Functions and Logarithm36291
+Node: Trigonometric Functions37946
+Node: Miscellaneous Complex Functions40171
+Node: Advanced Functions42318
+Node: Internals43391
+Node: Contributors43838
+Node: References44184
+Node: Concept Index45082
+Node: Function Index47396
 
 End Tag Table
diff --git a/mpfr/mpfr.info b/mpfr/mpfr.info
index 379918c6..9154aa35 100644
--- a/mpfr/mpfr.info
+++ b/mpfr/mpfr.info
@@ -1,19 +1,18 @@
-This is mpfr.info, produced by makeinfo version 4.13 from mpfr.texi.
+This is mpfr.info, produced by makeinfo version 6.5 from mpfr.texi.
 
 This manual documents how to install and use the Multiple Precision
 Floating-Point Reliable Library, version 3.0.1.
 
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
+   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+Foundation, Inc.
 
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.2 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with no Front-Cover Texts, and with no
-Back-Cover Texts.  A copy of the license is included in *note GNU Free
+   Permission is granted to copy, distribute and/or modify this document
+under the terms of the GNU Free Documentation License, Version 1.2 or
+any later version published by the Free Software Foundation; with no
+Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
+Texts.  A copy of the license is included in *note GNU Free
 Documentation License::.
-
 INFO-DIR-SECTION Software libraries
 START-INFO-DIR-ENTRY
 * mpfr: (mpfr).                 Multiple Precision Floating-Point Reliable Library.
@@ -25,21 +24,20 @@ File: mpfr.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)
 GNU MPFR
 ********
 
-   This manual documents how to install and use the Multiple Precision
+This manual documents how to install and use the Multiple Precision
 Floating-Point Reliable Library, version 3.0.1.
 
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
+   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+Foundation, Inc.
 
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.2 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with no Front-Cover Texts, and with no
-Back-Cover Texts.  A copy of the license is included in *note GNU Free
+   Permission is granted to copy, distribute and/or modify this document
+under the terms of the GNU Free Documentation License, Version 1.2 or
+any later version published by the Free Software Foundation; with no
+Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
+Texts.  A copy of the license is included in *note GNU Free
 Documentation License::.
 
-
 * Menu:
 
 * Copying::                     MPFR Copying Conditions (LGPL).
@@ -61,31 +59,30 @@ File: mpfr.info,  Node: Copying,  Next: Introduction to MPFR,  Prev: Top,  Up: T
 MPFR Copying Conditions
 ***********************
 
-The GNU MPFR library (or MPFR for short) is "free"; this means that
+The GNU MPFR library (or MPFR for short) is free; this means that
 everyone is free to use it and free to redistribute it on a free basis.
-The library is not in the public domain; it is copyrighted and there
-are restrictions on its distribution, but these restrictions are
-designed to permit everything that a good cooperating citizen would
-want to do.  What is not allowed is to try to prevent others from
-further sharing any version of this library that they might get from
-you.
+The library is not in the public domain; it is copyrighted and there are
+restrictions on its distribution, but these restrictions are designed to
+permit everything that a good cooperating citizen would want to do.
+What is not allowed is to try to prevent others from further sharing any
+version of this library that they might get from you.
 
    Specifically, we want to make sure that you have the right to give
-away copies of the library, that you receive source code or else can
-get it if you want it, that you can change this library or use pieces
-of it in new free programs, and that you know you can do these things.
+away copies of the library, that you receive source code or else can get
+it if you want it, that you can change this library or use pieces of it
+in new free programs, and that you know you can do these things.
 
    To make sure that everyone has such rights, we have to forbid you to
 deprive anyone else of these rights.  For example, if you distribute
 copies of the GNU MPFR library, you must give the recipients all the
-rights that you have.  You must make sure that they, too, receive or
-can get the source code.  And you must tell them their rights.
+rights that you have.  You must make sure that they, too, receive or can
+get the source code.  And you must tell them their rights.
 
    Also, for our own protection, we must make certain that everyone
 finds out that there is no warranty for the GNU MPFR library.  If it is
-modified by someone else and passed on, we want their recipients to
-know that what they have is not what we distributed, so that any
-problems introduced by others will not reflect on our reputation.
+modified by someone else and passed on, we want their recipients to know
+that what they have is not what we distributed, so that any problems
+introduced by others will not reflect on our reputation.
 
    The precise conditions of the license for the GNU MPFR library are
 found in the Lesser General Public License that accompanies the source
@@ -98,27 +95,25 @@ File: mpfr.info,  Node: Introduction to MPFR,  Next: Installing MPFR,  Prev: Cop
 **********************
 
 MPFR is a portable library written in C for arbitrary precision
-arithmetic on floating-point numbers. It is based on the GNU MP library.
-It aims to provide a class of floating-point numbers with precise
-semantics. The main characteristics of MPFR, which make it differ from
-most arbitrary precision floating-point software tools, are:
+arithmetic on floating-point numbers.  It is based on the GNU MP
+library.  It aims to provide a class of floating-point numbers with
+precise semantics.  The main characteristics of MPFR, which make it
+differ from most arbitrary precision floating-point software tools, are:
 
-   * the MPFR code is portable, i.e., the result of any operation does
-     not depend on the machine word size `mp_bits_per_limb' (64 on most
+    the MPFR code is portable, i.e., the result of any operation does
+     not depend on the machine word size mp_bits_per_limb (64 on most
      current processors);
-
-   * the precision in bits can be set _exactly_ to any valid value for
+    the precision in bits can be set _exactly_ to any valid value for
      each variable (including very small precision);
-
-   * MPFR provides the four rounding modes from the IEEE 754-1985
+    MPFR provides the four rounding modes from the IEEE 754-1985
      standard, plus away-from-zero, as well as for basic operations as
      for other mathematical functions.
 
    In particular, with a precision of 53 bits, MPFR is able to exactly
 reproduce all computations with double-precision machine floating-point
-numbers (e.g., `double' type in C, with a C implementation that
-rigorously follows Annex F of the ISO C99 standard and `FP_CONTRACT'
-pragma set to `OFF') on the four arithmetic operations and the square
+numbers (e.g., double type in C, with a C implementation that
+rigorously follows Annex F of the ISO C99 standard and FP_CONTRACT
+pragma set to OFF) on the four arithmetic operations and the square
 root, except the default exponent range is much wider and subnormal
 numbers are not implemented (but can be emulated).
 
@@ -132,8 +127,8 @@ provided.
 ==========================
 
 Everyone should read *note MPFR Basics::.  If you need to install the
-library yourself, you need to read *note Installing MPFR::, too.  To
-use the library you will need to refer to *note MPFR Interface::.
+library yourself, you need to read *note Installing MPFR::, too.  To use
+the library you will need to refer to *note MPFR Interface::.
 
    The rest of the manual can be used for later reference, although it
 is probably a good idea to glance through it.
@@ -145,11 +140,11 @@ File: mpfr.info,  Node: Installing MPFR,  Next: Reporting Bugs,  Prev: Introduct
 *****************
 
 The MPFR library is already installed on some GNU/Linux distributions,
-but the development files necessary to the compilation such as `mpfr.h'
-are not always present. To check that MPFR is fully installed on your
-computer, you can check the presence of the file `mpfr.h' in
-`/usr/include', or try to compile a small program having `#include
-<mpfr.h>' (since `mpfr.h' may be installed somewhere else). For
+but the development files necessary to the compilation such as mpfr.h
+are not always present.  To check that MPFR is fully installed on your
+computer, you can check the presence of the file mpfr.h in
+/usr/include, or try to compile a small program having #include
+<mpfr.h> (since mpfr.h may be installed somewhere else).  For
 instance, you can try to compile:
 
      #include <stdio.h>
@@ -170,7 +165,7 @@ and if you get errors whose first line looks like
 
      version.c:2:19: error: mpfr.h: No such file or directory
 
-then MPFR is probably not installed. Running this program will give you
+then MPFR is probably not installed.  Running this program will give you
 the MPFR version.
 
    If MPFR is not installed on your computer, or if you want to install
@@ -180,107 +175,106 @@ a different version, please follow the steps below.
 ==================
 
 Here are the steps needed to install the library on Unix systems (more
-details are provided in the `INSTALL' file):
+details are provided in the INSTALL file):
 
   1. To build MPFR, you first have to install GNU MP (version 4.1 or
      higher) on your computer.  You need a C compiler, preferably GCC,
-     but any reasonable compiler should work.  And you need the
-     standard Unix `make' command, plus some other standard Unix
-     utility commands.
+     but any reasonable compiler should work.  And you need the standard
+     Unix make command, plus some other standard Unix utility
+     commands.
 
      Then, in the MPFR build directory, type the following commands.
 
-  2. `./configure'
+  2. ./configure
 
-     This will prepare the build and setup the options according to
-     your system.  You can give options to specify the install
-     directories (instead of the default `/usr/local'), threading
-     support, and so on. See the `INSTALL' file and/or the output of
-     `./configure --help' for more information, in particular if you
-     get error messages.
+     This will prepare the build and setup the options according to your
+     system.  You can give options to specify the install directories
+     (instead of the default /usr/local), threading support, and so
+     on.  See the INSTALL file and/or the output of ./configure
+     --help for more information, in particular if you get error
+     messages.
 
-  3. `make'
+  3. make
 
      This will compile MPFR, and create a library archive file
-     `libmpfr.a'.  On most platforms, a dynamic library will be
-     produced too.
-
-  4. `make check'
+     libmpfr.a.  On most platforms, a dynamic library will be produced
+     too.
+  4. make check
 
      This will make sure MPFR was built correctly.  If you get error
-     messages, please report this to `mpfr@loria.fr'.  (*Note Reporting
+     messages, please report this to mpfr@loria.fr.  (*Note Reporting
      Bugs::, for information on what to include in useful bug reports.)
 
-  5. `make install'
+  5. make install
 
-     This will copy the files `mpfr.h' and `mpf2mpfr.h' to the directory
-     `/usr/local/include', the library files (`libmpfr.a' and possibly
-     others) to the directory `/usr/local/lib', the file `mpfr.info' to
-     the directory `/usr/local/share/info', and some other documentation
-     files to the directory `/usr/local/share/doc/mpfr' (or if you
-     passed the `--prefix' option to `configure', using the prefix
-     directory given as argument to `--prefix' instead of `/usr/local').
+     This will copy the files mpfr.h and mpf2mpfr.h to the directory
+     /usr/local/include, the library files (libmpfr.a and possibly
+     others) to the directory /usr/local/lib, the file mpfr.info to
+     the directory /usr/local/share/info, and some other documentation
+     files to the directory /usr/local/share/doc/mpfr (or if you
+     passed the --prefix option to configure, using the prefix
+     directory given as argument to --prefix instead of /usr/local).
 
-2.2 Other `make' Targets
+2.2 Other make Targets
 ========================
 
 There are some other useful make targets:
 
-   * `mpfr.info' or `info'
+    mpfr.info or info
 
-     Create or update an info version of the manual, in `mpfr.info'.
+     Create or update an info version of the manual, in mpfr.info.
 
      This file is already provided in the MPFR archives.
 
-   * `mpfr.pdf' or `pdf'
+    mpfr.pdf or pdf
 
-     Create a PDF version of the manual, in `mpfr.pdf'.
+     Create a PDF version of the manual, in mpfr.pdf.
 
-   * `mpfr.dvi' or `dvi'
+    mpfr.dvi or dvi
 
-     Create a DVI version of the manual, in `mpfr.dvi'.
+     Create a DVI version of the manual, in mpfr.dvi.
 
-   * `mpfr.ps' or `ps'
+    mpfr.ps or ps
 
-     Create a Postscript version of the manual, in `mpfr.ps'.
+     Create a Postscript version of the manual, in mpfr.ps.
 
-   * `mpfr.html' or `html'
+    mpfr.html or html
 
      Create a HTML version of the manual, in several pages in the
-     directory `mpfr.html'; if you want only one output HTML file, then
-     type `makeinfo --html --no-split mpfr.texi' instead.
+     directory mpfr.html; if you want only one output HTML file, then
+     type makeinfo --html --no-split mpfr.texi instead.
 
-   * `clean'
+    clean
 
      Delete all object files and archive files, but not the
      configuration files.
 
-   * `distclean'
+    distclean
 
      Delete all generated files not included in the distribution.
 
-   * `uninstall'
+    uninstall
 
-     Delete all files copied by `make install'.
+     Delete all files copied by make install.
 
 2.3 Build Problems
 ==================
 
-In case of problem, please read the `INSTALL' file carefully before
-reporting a bug, in particular section "In case of problem".  Some
+In case of problem, please read the INSTALL file carefully before
+reporting a bug, in particular section In case of problem.  Some
 problems are due to bad configuration on the user side (not specific to
 MPFR). Problems are also mentioned in the FAQ
-`http://www.mpfr.org/faq.html'.
+<http://www.mpfr.org/faq.html>.
 
-   Please report problems to `mpfr@loria.fr'.  *Note Reporting Bugs::.
+   Please report problems to mpfr@loria.fr.  *Note Reporting Bugs::.
 Some bug fixes are available on the MPFR 3.0.1 web page
-`http://www.mpfr.org/mpfr-3.0.1/'.
+<http://www.mpfr.org/mpfr-3.0.1/>.
 
 2.4 Getting the Latest Version of MPFR
 ======================================
 
 The latest version of MPFR is available from
-`ftp://ftp.gnu.org/gnu/mpfr/' or `http://www.mpfr.org/'.
+<ftp://ftp.gnu.org/gnu/mpfr/> or <http://www.mpfr.org/>.
 
 
 File: mpfr.info,  Node: Reporting Bugs,  Next: MPFR Basics,  Prev: Installing MPFR,  Up: Top
@@ -289,11 +283,11 @@ File: mpfr.info,  Node: Reporting Bugs,  Next: MPFR Basics,  Prev: Installing MP
 ****************
 
 If you think you have found a bug in the MPFR library, first have a look
-on the MPFR 3.0.1 web page `http://www.mpfr.org/mpfr-3.0.1/' and the
-FAQ `http://www.mpfr.org/faq.html': perhaps this bug is already known,
-in which case you may find there a workaround for it.  You might also
-look in the archives of the MPFR mailing-list:
-`http://websympa.loria.fr/wwsympa/arc/mpfr'.  Otherwise, please
+on the MPFR 3.0.1 web page <http://www.mpfr.org/mpfr-3.0.1/> and the FAQ
+<http://www.mpfr.org/faq.html>: perhaps this bug is already known, in
+which case you may find there a workaround for it.  You might also look
+in the archives of the MPFR mailing-list:
+<http://websympa.loria.fr/wwsympa/arc/mpfr>.  Otherwise, please
 investigate and report it.  We have made this library available to you,
 and it is not to ask too much from you, to ask you to report the bugs
 that you find.
@@ -303,22 +297,21 @@ report together.
 
    You have to send us a test case that makes it possible for us to
 reproduce the bug, i.e., a small self-content program, using no other
-library than MPFR.  Include instructions on how to run the test case.
+library than MPFR. Include instructions on how to run the test case.
 
-   You also have to explain what is wrong; if you get a crash, or if
-the results you get are incorrect and in that case, in what way.
+   You also have to explain what is wrong; if you get a crash, or if the
+results you get are incorrect and in that case, in what way.
 
-   Please include compiler version information in your bug report. This
-can be extracted using `cc -V' on some machines, or, if you're using
-GCC, `gcc -v'. Also, include the output from `uname -a' and the MPFR
+   Please include compiler version information in your bug report.  This
+can be extracted using cc -V on some machines, or, if youre using
+GCC, gcc -v.  Also, include the output from uname -a and the MPFR
 version (the GMP version may be useful too).
 
    If your bug report is good, we will do our best to help you to get a
-corrected version of the library; if the bug report is poor, we will
-not do anything about it (aside of chiding you to send better bug
-reports).
+corrected version of the library; if the bug report is poor, we will not
+do anything about it (aside of chiding you to send better bug reports).
 
-   Send your bug report to: `mpfr@loria.fr'.
+   Send your bug report to: mpfr@loria.fr.
 
    If you think something in this manual is unclear, or downright
 incorrect, or if the language needs to be improved, please send a note
@@ -334,49 +327,49 @@ File: mpfr.info,  Node: MPFR Basics,  Next: MPFR Interface,  Prev: Reporting Bug
 =========================
 
 All declarations needed to use MPFR are collected in the include file
-`mpfr.h'.  It is designed to work with both C and C++ compilers.  You
+mpfr.h.  It is designed to work with both C and C++ compilers.  You
 should include that file in any program using the MPFR library:
 
      #include <mpfr.h>
 
-   Note however that prototypes for MPFR functions with `FILE *'
-parameters are provided only if `<stdio.h>' is included too (before
-`mpfr.h'):
+   Note however that prototypes for MPFR functions with FILE *
+parameters are provided only if <stdio.h> is included too (before
+mpfr.h):
 
      #include <stdio.h>
      #include <mpfr.h>
 
-   Likewise `<stdarg.h>' (or `<varargs.h>') is required for prototypes
-with `va_list' parameters, such as `mpfr_vprintf'.
+   Likewise <stdarg.h> (or <varargs.h>) is required for prototypes
+with va_list parameters, such as mpfr_vprintf.
 
-   And for any functions using `intmax_t', you must include
-`<stdint.h>' or `<inttypes.h>' before `mpfr.h', to allow `mpfr.h' to
-define prototypes for these functions. Moreover, users of C++ compilers
-under some platforms may need to define `MPFR_USE_INTMAX_T' (and should
-do it for portability) before `mpfr.h' has been included; of course, it
-is possible to do that on the command line, e.g., with
-`-DMPFR_USE_INTMAX_T'.
+   And for any functions using intmax_t, you must include <stdint.h>
+or <inttypes.h> before mpfr.h, to allow mpfr.h to define
+prototypes for these functions.  Moreover, users of C++ compilers under
+some platforms may need to define MPFR_USE_INTMAX_T (and should do it
+for portability) before mpfr.h has been included; of course, it is
+possible to do that on the command line, e.g., with
+-DMPFR_USE_INTMAX_T.
 
-   Note: If `mpfr.h' and/or `gmp.h' (used by `mpfr.h') are included
+   Note: If mpfr.h and/or gmp.h (used by mpfr.h) are included
 several times (possibly from another header file), the aforementioned
 standard headers should be included *before* the first inclusion of
-`mpfr.h' or `gmp.h'. For the time being, this problem is not avoidable
+mpfr.h or gmp.h.  For the time being, this problem is not avoidable
 in MPFR without a change in GMP.
 
    When calling a MPFR macro, it is not allowed to have previously
-defined a macro with the same name as some keywords (currently `do',
-`while' and `sizeof').
+defined a macro with the same name as some keywords (currently do,
+while and sizeof).
 
    You can avoid the use of MPFR macros encapsulating functions by
-defining the `MPFR_USE_NO_MACRO' macro before `mpfr.h' is included.  In
+defining the MPFR_USE_NO_MACRO macro before mpfr.h is included.  In
 general this should not be necessary, but this can be useful when
 debugging user code: with some macros, the compiler may emit spurious
 warnings with some warning options, and macros can prevent some
 prototype checking.
 
-   All programs using MPFR must link against both `libmpfr' and
-`libgmp' libraries.  On a typical Unix-like system this can be done
-with `-lmpfr -lgmp' (in that order), for example:
+   All programs using MPFR must link against both libmpfr and libgmp
+libraries.  On a typical Unix-like system this can be done with -lmpfr
+-lgmp (in that order), for example:
 
      gcc myprogram.c -lmpfr -lgmp
 
@@ -384,54 +377,54 @@ with `-lmpfr -lgmp' (in that order), for example:
 if desired, *note GNU Libtool: (libtool.info)Top.
 
    If MPFR has been installed to a non-standard location, then it may be
-necessary to set up environment variables such as `C_INCLUDE_PATH' and
-`LIBRARY_PATH', or use `-I' and `-L' compiler options, in order to
-point to the right directories. For a shared library, it may also be
+necessary to set up environment variables such as C_INCLUDE_PATH and
+LIBRARY_PATH, or use -I and -L compiler options, in order to point
+to the right directories.  For a shared library, it may also be
 necessary to set up some sort of run-time library path (e.g.,
-`LD_LIBRARY_PATH') on some systems. Please read the `INSTALL' file for
+LD_LIBRARY_PATH) on some systems.  Please read the INSTALL file for
 additional information.
 
 4.2 Nomenclature and Types
 ==========================
 
-A "floating-point number", or "float" for short, is an arbitrary
+A floating-point number, or float for short, is an arbitrary
 precision significand (also called mantissa) with a limited precision
-exponent. The C data type for such objects is `mpfr_t' (internally
-defined as a one-element array of a structure, and `mpfr_ptr' is the C
-data type representing a pointer to this structure). A floating-point
+exponent.  The C data type for such objects is mpfr_t (internally
+defined as a one-element array of a structure, and mpfr_ptr is the C
+data type representing a pointer to this structure).  A floating-point
 number can have three special values: Not-a-Number (NaN) or plus or
-minus Infinity. NaN represents an uninitialized object, the result of
+minus Infinity.  NaN represents an uninitialized object, the result of
 an invalid operation (like 0 divided by 0), or a value that cannot be
-determined (like +Infinity minus +Infinity). Moreover, like in the IEEE
-754 standard, zero is signed, i.e., there are both +0 and -0; the
+determined (like +Infinity minus +Infinity).  Moreover, like in the IEEE
+754 standard, zero is signed, i.e., there are both +0 and 0; the
 behavior is the same as in the IEEE 754 standard and it is generalized
 to the other functions supported by MPFR. Unless documented otherwise,
 the sign bit of a NaN is unspecified.
 
-The "precision" is the number of bits used to represent the significand
+The precision is the number of bits used to represent the significand
 of a floating-point number; the corresponding C data type is
-`mpfr_prec_t'.  The precision can be any integer between
-`MPFR_PREC_MIN' and `MPFR_PREC_MAX'. In the current implementation,
-`MPFR_PREC_MIN' is equal to 2.
-
-   Warning! MPFR needs to increase the precision internally, in order to
-provide accurate results (and in particular, correct rounding). Do not
-attempt to set the precision to any value near `MPFR_PREC_MAX',
-otherwise MPFR will abort due to an assertion failure. Moreover, you
+mpfr_prec_t.  The precision can be any integer between MPFR_PREC_MIN
+and MPFR_PREC_MAX.  In the current implementation, MPFR_PREC_MIN is
+equal to 2.
+
+   Warning!  MPFR needs to increase the precision internally, in order
+to provide accurate results (and in particular, correct rounding).  Do
+not attempt to set the precision to any value near MPFR_PREC_MAX,
+otherwise MPFR will abort due to an assertion failure.  Moreover, you
 may reach some memory limit on your platform, in which case the program
 may abort, crash or have undefined behavior (depending on your C
 implementation).
 
-The "rounding mode" specifies the way to round the result of a
+The rounding mode specifies the way to round the result of a
 floating-point operation, in case the exact result can not be
 represented exactly in the destination significand; the corresponding C
-data type is `mpfr_rnd_t'.
+data type is mpfr_rnd_t.
 
 4.3 MPFR Variable Conventions
 =============================
 
 Before you can assign to an MPFR variable, you need to initialize it by
-calling one of the special initialization functions.  When you're done
+calling one of the special initialization functions.  When youre done
 with a variable, you need to clear it out, using one of the functions
 for that purpose.  A variable should only be initialized once, or at
 least cleared out between each initialization.  After a variable has
@@ -439,130 +432,126 @@ been initialized, it may be assigned to any number of times.  For
 efficiency reasons, avoid to initialize and clear out a variable in
 loops.  Instead, initialize it before entering the loop, and clear it
 out after the loop has exited.  You do not need to be concerned about
-allocating additional space for MPFR variables, since any variable has
-a significand of fixed size.  Hence unless you change its precision, or
+allocating additional space for MPFR variables, since any variable has a
+significand of fixed size.  Hence unless you change its precision, or
 clear and reinitialize it, a floating-point variable will have the same
 allocated space during all its life.
 
    As a general rule, all MPFR functions expect output arguments before
 input arguments.  This notation is based on an analogy with the
 assignment operator.  MPFR allows you to use the same variable for both
-input and output in the same expression.  For example, the main
-function for floating-point multiplication, `mpfr_mul', can be used
-like this: `mpfr_mul (x, x, x, rnd)'.  This computes the square of X
-with rounding mode `rnd' and puts the result back in X.
+input and output in the same expression.  For example, the main function
+for floating-point multiplication, mpfr_mul, can be used like this:
+mpfr_mul (x, x, x, rnd).  This computes the square of X with rounding
+mode rnd and puts the result back in X.
 
 4.4 Rounding Modes
 ==================
 
 The following five rounding modes are supported:
 
-   * `MPFR_RNDN': round to nearest (roundTiesToEven in IEEE 754-2008),
-
-   * `MPFR_RNDZ': round toward zero (roundTowardZero in IEEE 754-2008),
-
-   * `MPFR_RNDU': round toward plus infinity (roundTowardPositive in
+    MPFR_RNDN: round to nearest (roundTiesToEven in IEEE 754-2008),
+    MPFR_RNDZ: round toward zero (roundTowardZero in IEEE 754-2008),
+    MPFR_RNDU: round toward plus infinity (roundTowardPositive in
      IEEE 754-2008),
-
-   * `MPFR_RNDD': round toward minus infinity (roundTowardNegative in
+    MPFR_RNDD: round toward minus infinity (roundTowardNegative in
      IEEE 754-2008),
+    MPFR_RNDA: round away from zero (experimental).
 
-   * `MPFR_RNDA': round away from zero (experimental).
-
-   The `round to nearest' mode works as in the IEEE 754 standard: in
+   The round to nearest mode works as in the IEEE 754 standard: in
 case the number to be rounded lies exactly in the middle of two
 representable numbers, it is rounded to the one with the least
 significant bit set to zero.  For example, the number 2.5, which is
-represented by (10.1) in binary, is rounded to (10.0)=2 with a
-precision of two bits, and not to (11.0)=3.  This rule avoids the
-"drift" phenomenon mentioned by Knuth in volume 2 of The Art of
-Computer Programming (Section 4.2.2).
+represented by (10.1) in binary, is rounded to (10.0)=2 with a precision
+of two bits, and not to (11.0)=3.  This rule avoids the drift
+phenomenon mentioned by Knuth in volume 2 of The Art of Computer
+Programming (Section 4.2.2).
 
    Most MPFR functions take as first argument the destination variable,
 as second and following arguments the input variables, as last argument
-a rounding mode, and have a return value of type `int', called the
-"ternary value". The value stored in the destination variable is
+a rounding mode, and have a return value of type int, called the
+ternary value.  The value stored in the destination variable is
 correctly rounded, i.e., MPFR behaves as if it computed the result with
 an infinite precision, then rounded it to the precision of this
 variable.  The input variables are regarded as exact (in particular,
 their precision does not affect the result).
 
    As a consequence, in case of a non-zero real rounded result, the
-error on the result is less or equal to 1/2 ulp (unit in the last
-place) of that result in the rounding to nearest mode, and less than 1
-ulp of that result in the directed rounding modes (a ulp is the weight
-of the least significant represented bit of the result after rounding).
+error on the result is less or equal to 1/2 ulp (unit in the last place)
+of that result in the rounding to nearest mode, and less than 1 ulp of
+that result in the directed rounding modes (a ulp is the weight of the
+least significant represented bit of the result after rounding).
 
-   Unless documented otherwise, functions returning an `int' return a
+   Unless documented otherwise, functions returning an int return a
 ternary value.  If the ternary value is zero, it means that the value
 stored in the destination variable is the exact result of the
-corresponding mathematical function. If the ternary value is positive
+corresponding mathematical function.  If the ternary value is positive
 (resp. negative), it means the value stored in the destination variable
-is greater (resp. lower) than the exact result. For example with the
-`MPFR_RNDU' rounding mode, the ternary value is usually positive,
-except when the result is exact, in which case it is zero. In the case
-of an infinite result, it is considered as inexact when it was obtained
-by overflow, and exact otherwise. A NaN result (Not-a-Number) always
+is greater (resp. lower) than the exact result.  For example with the
+MPFR_RNDU rounding mode, the ternary value is usually positive, except
+when the result is exact, in which case it is zero.  In the case of an
+infinite result, it is considered as inexact when it was obtained by
+overflow, and exact otherwise.  A NaN result (Not-a-Number) always
 corresponds to an exact return value.  The opposite of a returned
-ternary value is guaranteed to be representable in an `int'.
+ternary value is guaranteed to be representable in an int.
 
    Unless documented otherwise, functions returning as result the value
-`1' (or any other value specified in this manual) for special cases
-(like `acos(0)') yield an overflow or an underflow if that value is not
+1 (or any other value specified in this manual) for special cases
+(like acos(0)) yield an overflow or an underflow if that value is not
 representable in the current exponent range.
 
 4.5 Floating-Point Values on Special Numbers
 ============================================
 
-This section specifies the floating-point values (of type `mpfr_t')
-returned by MPFR functions (where by "returned" we mean here the
-modified value of the destination object, which should not be mixed
-with the ternary return value of type `int' of those functions).  For
-functions returning several values (like `mpfr_sin_cos'), the rules
+This section specifies the floating-point values (of type mpfr_t)
+returned by MPFR functions (where by returned we mean here the
+modified value of the destination object, which should not be mixed with
+the ternary return value of type int of those functions).  For
+functions returning several values (like mpfr_sin_cos), the rules
 apply to each result separately.
 
-   Functions can have one or several input arguments. An input point is
+   Functions can have one or several input arguments.  An input point is
 a mapping from these input arguments to the set of the MPFR numbers.
 When none of its components are NaN, an input point can also be seen as
 a tuple in the extended real numbers (the set of the real numbers with
 both infinities).
 
    When the input point is in the domain of the mathematical function,
-the result is rounded as described in Section "Rounding Modes" (but see
-below for the specification of the sign of an exact zero). Otherwise
-the general rules from this section apply unless stated otherwise in
-the description of the MPFR function (*note MPFR Interface::).
+the result is rounded as described in Section Rounding Modes (but see
+below for the specification of the sign of an exact zero).  Otherwise
+the general rules from this section apply unless stated otherwise in the
+description of the MPFR function (*note MPFR Interface::).
 
    When the input point is not in the domain of the mathematical
 function but is in its closure in the extended real numbers and the
 function can be extended by continuity, the result is the obtained
-limit.  Examples: `mpfr_hypot' on (+Inf,0) gives +Inf. But `mpfr_pow'
-cannot be defined on (1,+Inf) using this rule, as one can find
-sequences (X_N,Y_N) such that X_N goes to 1, Y_N goes to +Inf and X_N
-to the Y_N goes to any positive value when N goes to the infinity.
+limit.  Examples: mpfr_hypot on (+Inf,0) gives +Inf.  But mpfr_pow
+cannot be defined on (1,+Inf) using this rule, as one can find sequences
+(X_N,Y_N) such that X_N goes to 1, Y_N goes to +Inf and X_N to the Y_N
+goes to any positive value when N goes to the infinity.
 
    When the input point is in the closure of the domain of the
-mathematical function and an input argument is +0 (resp. -0), one
+mathematical function and an input argument is +0 (resp. 0), one
 considers the limit when the corresponding argument approaches 0 from
-above (resp. below). If the limit is not defined (e.g., `mpfr_log' on
--0), the behavior is specified in the description of the MPFR function.
+above (resp. below).  If the limit is not defined (e.g., mpfr_log on
+0), the behavior is specified in the description of the MPFR function.
 
    When the result is equal to 0, its sign is determined by considering
 the limit as if the input point were not in the domain: If one
-approaches 0 from above (resp. below), the result is +0 (resp. -0); for
-example, `mpfr_sin' on +0 gives +0.  In the other cases, the sign is
+approaches 0 from above (resp. below), the result is +0 (resp. 0); for
+example, mpfr_sin on +0 gives +0.  In the other cases, the sign is
 specified in the description of the MPFR function; for example
-`mpfr_max' on -0 and +0 gives +0.
+mpfr_max on 0 and +0 gives +0.
 
    When the input point is not in the closure of the domain of the
-function, the result is NaN. Example: `mpfr_sqrt' on -17 gives NaN.
+function, the result is NaN. Example: mpfr_sqrt on 17 gives NaN.
 
    When an input argument is NaN, the result is NaN, possibly except
 when a partial function is constant on the finite floating-point
 numbers; such a case is always explicitly specified in *note MPFR
-Interface::.  Example: `mpfr_hypot' on (NaN,0) gives NaN, but
-`mpfr_hypot' on (NaN,+Inf) gives +Inf (as specified in *note Special
-Functions::), since for any finite input X, `mpfr_hypot' on (X,+Inf)
+Interface::.  Example: mpfr_hypot on (NaN,0) gives NaN, but
+mpfr_hypot on (NaN,+Inf) gives +Inf (as specified in *note Special
+Functions::), since for any finite input X, mpfr_hypot on (X,+Inf)
 gives +Inf.
 
 4.6 Exceptions
@@ -570,74 +559,71 @@ gives +Inf.
 
 MPFR supports 5 exception types:
 
-   * Underflow: An underflow occurs when the exact result of a function
+    Underflow: An underflow occurs when the exact result of a function
      is a non-zero real number and the result obtained after the
      rounding, assuming an unbounded exponent range (for the rounding),
      has an exponent smaller than the minimum value of the current
-     exponent range. (In the round-to-nearest mode, the halfway case is
+     exponent range.  (In the round-to-nearest mode, the halfway case is
      rounded toward zero.)
 
      Note: This is not the single possible definition of the underflow.
-     MPFR chooses to consider the underflow _after_ rounding. The
-     underflow before rounding can also be defined. For instance,
+     MPFR chooses to consider the underflow _after_ rounding.  The
+     underflow before rounding can also be defined.  For instance,
      consider a function that has the exact result 7 multiplied by two
-     to the power E-4, where E is the smallest exponent (for a
+     to the power E4, where E is the smallest exponent (for a
      significand between 1/2 and 1), with a 2-bit target precision and
      rounding toward plus infinity.  The exact result has the exponent
-     E-1. With the underflow before rounding, such a function call
-     would yield an underflow, as E-1 is outside the current exponent
-     range. However, MPFR first considers the rounded result assuming
+     E1.  With the underflow before rounding, such a function call
+     would yield an underflow, as E1 is outside the current exponent
+     range.  However, MPFR first considers the rounded result assuming
      an unbounded exponent range.  The exact result cannot be
      represented exactly in precision 2, and here, it is rounded to 0.5
-     times 2 to E, which is representable in the current exponent
-     range. As a consequence, this will not yield an underflow in MPFR.
+     times 2 to E, which is representable in the current exponent range.
+     As a consequence, this will not yield an underflow in MPFR.
 
-   * Overflow: An overflow occurs when the exact result of a function
-     is a non-zero real number and the result obtained after the
-     rounding, assuming an unbounded exponent range (for the rounding),
-     has an exponent larger than the maximum value of the current
-     exponent range. In the round-to-nearest mode, the result is
-     infinite.  Note: unlike the underflow case, there is only one
-     possible definition of overflow here.
+    Overflow: An overflow occurs when the exact result of a function is
+     a non-zero real number and the result obtained after the rounding,
+     assuming an unbounded exponent range (for the rounding), has an
+     exponent larger than the maximum value of the current exponent
+     range.  In the round-to-nearest mode, the result is infinite.
+     Note: unlike the underflow case, there is only one possible
+     definition of overflow here.
 
-   * NaN: A NaN exception occurs when the result of a function is NaN.
+    NaN: A NaN exception occurs when the result of a function is NaN.
 
-   * Inexact: An inexact exception occurs when the result of a function
+    Inexact: An inexact exception occurs when the result of a function
      cannot be represented exactly and must be rounded.
 
-   * Range error: A range exception occurs when a function that does
-     not return a MPFR number (such as comparisons and conversions to
-     an integer) has an invalid result (e.g., an argument is NaN in
-     `mpfr_cmp', or a conversion to an integer cannot be represented in
+    Range error: A range exception occurs when a function that does not
+     return a MPFR number (such as comparisons and conversions to an
+     integer) has an invalid result (e.g., an argument is NaN in
+     mpfr_cmp, or a conversion to an integer cannot be represented in
      the target type).
 
-
    MPFR has a global flag for each exception, which can be cleared, set
 or tested by functions described in *note Exception Related Functions::.
 
    Differences with the ISO C99 standard:
 
-   * In C, only quiet NaNs are specified, and a NaN propagation does not
-     raise an invalid exception. Unless explicitly stated otherwise,
-     MPFR sets the NaN flag whenever a NaN is generated, even when a
-     NaN is propagated (e.g., in NaN + NaN), as if all NaNs were
-     signaling.
+    In C, only quiet NaNs are specified, and a NaN propagation does not
+     raise an invalid exception.  Unless explicitly stated otherwise,
+     MPFR sets the NaN flag whenever a NaN is generated, even when a NaN
+     is propagated (e.g., in NaN + NaN), as if all NaNs were signaling.
 
-   * An invalid exception in C corresponds to either a NaN exception or
+    An invalid exception in C corresponds to either a NaN exception or
      a range error in MPFR.
 
-
 4.7 Memory Handling
 ===================
 
-MPFR functions may create caches, e.g., when computing constants such
-as Pi, either because the user has called a function like
-`mpfr_const_pi' directly or because such a function was called
-internally by the MPFR library itself to compute some other function.
+MPFR functions may create caches, e.g., when computing constants such as
+Pi, either because the user has called a function like mpfr_const_pi
+directly or because such a function was called internally by the MPFR
+library itself to compute some other function.
 
    At any time, the user can free the various caches with
-`mpfr_free_cache'. It is strongly advised to do that before terminating
-a thread, or before exiting when using tools like `valgrind' (to avoid
+mpfr_free_cache.  It is strongly advised to do that before terminating
+a thread, or before exiting when using tools like valgrind (to avoid
 memory leaks being reported).
 
    MPFR internal data such as flags, the exponent range, the default
@@ -651,33 +637,33 @@ File: mpfr.info,  Node: MPFR Interface,  Next: API Compatibility,  Prev: MPFR Ba
 5 MPFR Interface
 ****************
 
-The floating-point functions expect arguments of type `mpfr_t'.
+The floating-point functions expect arguments of type mpfr_t.
 
    The MPFR floating-point functions have an interface that is similar
 to the GNU MP functions.  The function prefix for floating-point
-operations is `mpfr_'.
+operations is mpfr_.
 
    The user has to specify the precision of each variable.  A
 computation that assigns a variable will take place with the precision
-of the assigned variable; the cost of that computation should not
-depend on the precision of variables used as input (on average).
+of the assigned variable; the cost of that computation should not depend
+on the precision of variables used as input (on average).
 
    The semantics of a calculation in MPFR is specified as follows:
-Compute the requested operation exactly (with "infinite accuracy"), and
+Compute the requested operation exactly (with infinite accuracy), and
 round the result to the precision of the destination variable, with the
 given rounding mode.  The MPFR floating-point functions are intended to
-be a smooth extension of the IEEE 754 arithmetic. The results obtained
-on a given computer are identical to those obtained on a computer with
-a different word size, or with a different compiler or operating system.
+be a smooth extension of the IEEE 754 arithmetic.  The results obtained
+on a given computer are identical to those obtained on a computer with a
+different word size, or with a different compiler or operating system.
 
-   MPFR _does not keep track_ of the accuracy of a computation. This is
+   MPFR _does not keep track_ of the accuracy of a computation.  This is
 left to the user or to a higher layer (for example the MPFI library for
 interval arithmetic).  As a consequence, if two variables are used to
 store only a few significant bits, and their product is stored in a
 variable with large precision, then MPFR will still compute the result
 with full precision.
 
-   The value of the standard C macro `errno' may be set to non-zero by
+   The value of the standard C macro errno may be set to non-zero by
 any MPFR function or macro, whether or not there is an error.
 
 * Menu:
@@ -705,8 +691,8 @@ File: mpfr.info,  Node: Initialization Functions,  Next: Assignment Functions,
 5.1 Initialization Functions
 ============================
 
-An `mpfr_t' object must be initialized before storing the first value in
-it.  The functions `mpfr_init' and `mpfr_init2' are used for that
+An mpfr_t object must be initialized before storing the first value in
+it.  The functions mpfr_init and mpfr_init2 are used for that
 purpose.
 
  -- Function: void mpfr_init2 (mpfr_t X, mpfr_prec_t PREC)
@@ -714,36 +700,36 @@ purpose.
      value to NaN. (Warning: the corresponding MPF function initializes
      to zero instead.)
 
-     Normally, a variable should be initialized once only or at least
-     be cleared, using `mpfr_clear', between initializations.  To
-     change the precision of a variable which has already been
-     initialized, use `mpfr_set_prec'.  The precision PREC must be an
-     integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX' (otherwise the
-     behavior is undefined).
+     Normally, a variable should be initialized once only or at least be
+     cleared, using mpfr_clear, between initializations.  To change
+     the precision of a variable which has already been initialized, use
+     mpfr_set_prec.  The precision PREC must be an integer between
+     MPFR_PREC_MIN and MPFR_PREC_MAX (otherwise the behavior is
+     undefined).
 
  -- Function: void mpfr_inits2 (mpfr_prec_t PREC, mpfr_t X, ...)
-     Initialize all the `mpfr_t' variables of the given variable
-     argument `va_list', set their precision to be *exactly* PREC bits
-     and their value to NaN.  See `mpfr_init2' for more details.  The
-     `va_list' is assumed to be composed only of type `mpfr_t' (or
-     equivalently `mpfr_ptr').  It begins from X, and ends when it
-     encounters a null pointer (whose type must also be `mpfr_ptr').
+     Initialize all the mpfr_t variables of the given variable
+     argument va_list, set their precision to be *exactly* PREC bits
+     and their value to NaN. See mpfr_init2 for more details.  The
+     va_list is assumed to be composed only of type mpfr_t (or
+     equivalently mpfr_ptr).  It begins from X, and ends when it
+     encounters a null pointer (whose type must also be mpfr_ptr).
 
  -- Function: void mpfr_clear (mpfr_t X)
-     Free the space occupied by the significand of X.  Make sure to
-     call this function for all `mpfr_t' variables when you are done
-     with them.
+     Free the space occupied by the significand of X.  Make sure to call
+     this function for all mpfr_t variables when you are done with
+     them.
 
  -- Function: void mpfr_clears (mpfr_t X, ...)
-     Free the space occupied by all the `mpfr_t' variables of the given
-     `va_list'. See `mpfr_clear' for more details.  The `va_list' is
-     assumed to be composed only of type `mpfr_t' (or equivalently
-     `mpfr_ptr').  It begins from X, and ends when it encounters a null
-     pointer (whose type must also be `mpfr_ptr').
+     Free the space occupied by all the mpfr_t variables of the given
+     va_list.  See mpfr_clear for more details.  The va_list is
+     assumed to be composed only of type mpfr_t (or equivalently
+     mpfr_ptr).  It begins from X, and ends when it encounters a null
+     pointer (whose type must also be mpfr_ptr).
 
    Here is an example of how to use multiple initialization functions
-(since `NULL' is not necessarily defined in this context, we use
-`(mpfr_ptr) 0' instead, but `(mpfr_ptr) NULL' is also correct).
+(since NULL is not necessarily defined in this context, we use
+(mpfr_ptr) 0 instead, but (mpfr_ptr) NULL is also correct).
 
      {
        mpfr_t x, y, z, t;
@@ -754,59 +740,55 @@ purpose.
 
  -- Function: void mpfr_init (mpfr_t X)
      Initialize X, set its precision to the default precision, and set
-     its value to NaN.  The default precision can be changed by a call
-     to `mpfr_set_default_prec'.
+     its value to NaN. The default precision can be changed by a call to
+     mpfr_set_default_prec.
 
-     Warning! In a given program, some other libraries might change the
-     default precision and not restore it. Thus it is safer to use
-     `mpfr_init2'.
+     Warning!  In a given program, some other libraries might change the
+     default precision and not restore it.  Thus it is safer to use
+     mpfr_init2.
 
  -- Function: void mpfr_inits (mpfr_t X, ...)
-     Initialize all the `mpfr_t' variables of the given `va_list', set
+     Initialize all the mpfr_t variables of the given va_list, set
      their precision to the default precision and their value to NaN.
-     See `mpfr_init' for more details.  The `va_list' is assumed to be
-     composed only of type `mpfr_t' (or equivalently `mpfr_ptr').  It
+     See mpfr_init for more details.  The va_list is assumed to be
+     composed only of type mpfr_t (or equivalently mpfr_ptr).  It
      begins from X, and ends when it encounters a null pointer (whose
-     type must also be `mpfr_ptr').
+     type must also be mpfr_ptr).
 
-     Warning! In a given program, some other libraries might change the
-     default precision and not restore it. Thus it is safer to use
-     `mpfr_inits2'.
+     Warning!  In a given program, some other libraries might change the
+     default precision and not restore it.  Thus it is safer to use
+     mpfr_inits2.
 
  -- Macro: MPFR_DECL_INIT (NAME, PREC)
-     This macro declares NAME as an automatic variable of type `mpfr_t',
-     initializes it and sets its precision to be *exactly* PREC bits
-     and its value to NaN. NAME must be a valid identifier.  You must
-     use this macro in the declaration section.  This macro is much
-     faster than using `mpfr_init2' but has some drawbacks:
+     This macro declares NAME as an automatic variable of type mpfr_t,
+     initializes it and sets its precision to be *exactly* PREC bits and
+     its value to NaN. NAME must be a valid identifier.  You must use
+     this macro in the declaration section.  This macro is much faster
+     than using mpfr_init2 but has some drawbacks:
 
-        * You *must not* call `mpfr_clear' with variables created with
+         You *must not* call mpfr_clear with variables created with
           this macro (the storage is allocated at the point of
           declaration and deallocated when the brace-level is exited).
-
-        * You *cannot* change their precision.
-
-        * You *should not* create variables with huge precision with
+         You *cannot* change their precision.
+         You *should not* create variables with huge precision with
           this macro.
-
-        * Your compiler must support `Non-Constant Initializers'
-          (standard in C++ and ISO C99) and `Token Pasting' (standard
-          in ISO C89). If PREC is not a constant expression, your
-          compiler must support `variable-length automatic arrays'
-          (standard in ISO C99). GCC 2.95.3 and above supports all
-          these features.  If you compile your program with GCC in C89
-          mode and with `-pedantic', you may want to define the
-          `MPFR_USE_EXTENSION' macro to avoid warnings due to the
-          `MPFR_DECL_INIT' implementation.
+         Your compiler must support Non-Constant Initializers
+          (standard in C++ and ISO C99) and Token Pasting (standard in
+          ISO C89).  If PREC is not a constant expression, your compiler
+          must support variable-length automatic arrays (standard in
+          ISO C99).  GCC 2.95.3 and above supports all these features.
+          If you compile your program with GCC in C89 mode and with
+          -pedantic, you may want to define the MPFR_USE_EXTENSION
+          macro to avoid warnings due to the MPFR_DECL_INIT
+          implementation.
 
  -- Function: void mpfr_set_default_prec (mpfr_prec_t PREC)
-     Set the default precision to be *exactly* PREC bits, where PREC
-     can be any integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX'.
-     The precision of a variable means the number of bits used to store
-     its significand.  All subsequent calls to `mpfr_init' or
-     `mpfr_inits' will use this precision, but previously initialized
-     variables are unaffected.  The default precision is set to 53 bits
-     initially.
+     Set the default precision to be *exactly* PREC bits, where PREC can
+     be any integer between MPFR_PREC_MIN and MPFR_PREC_MAX.  The
+     precision of a variable means the number of bits used to store its
+     significand.  All subsequent calls to mpfr_init or mpfr_inits
+     will use this precision, but previously initialized variables are
+     unaffected.  The default precision is set to 53 bits initially.
 
  -- Function: mpfr_prec_t mpfr_get_default_prec (void)
      Return the current default MPFR precision in bits.
@@ -832,13 +814,13 @@ numbers.
 
  -- Function: void mpfr_set_prec (mpfr_t X, mpfr_prec_t PREC)
      Reset the precision of X to be *exactly* PREC bits, and set its
-     value to NaN.  The previous value stored in X is lost. It is
-     equivalent to a call to `mpfr_clear(x)' followed by a call to
-     `mpfr_init2(x, prec)', but more efficient as no allocation is done
+     value to NaN. The previous value stored in X is lost.  It is
+     equivalent to a call to mpfr_clear(x) followed by a call to
+     mpfr_init2(x, prec), but more efficient as no allocation is done
      in case the current allocated space for the significand of X is
      enough.  The precision PREC can be any integer between
-     `MPFR_PREC_MIN' and `MPFR_PREC_MAX'.  In case you want to keep the
-     previous value stored in X, use `mpfr_prec_round' instead.
+     MPFR_PREC_MIN and MPFR_PREC_MAX.  In case you want to keep the
+     previous value stored in X, use mpfr_prec_round instead.
 
  -- Function: mpfr_prec_t mpfr_get_prec (mpfr_t X)
      Return the precision of X, i.e., the number of bits used to store
@@ -869,24 +851,23 @@ Initialization Functions::).
  -- Function: int mpfr_set_q (mpfr_t ROP, mpq_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_set_f (mpfr_t ROP, mpf_t OP, mpfr_rnd_t RND)
      Set the value of ROP from OP, rounded toward the given direction
-     RND.  Note that the input 0 is converted to +0 by `mpfr_set_ui',
-     `mpfr_set_si', `mpfr_set_uj', `mpfr_set_sj', `mpfr_set_z',
-     `mpfr_set_q' and `mpfr_set_f', regardless of the rounding mode.
-     If the system does not support the IEEE 754 standard,
-     `mpfr_set_flt', `mpfr_set_d', `mpfr_set_ld' and
-     `mpfr_set_decimal64' might not preserve the signed zeros.  The
-     `mpfr_set_decimal64' function is built only with the configure
-     option `--enable-decimal-float', which also requires
-     `--with-gmp-build', and when the compiler or system provides the
-     `_Decimal64' data type (recent versions of GCC support this data
-     type).  `mpfr_set_q' might fail if the numerator (or the
-     denominator) can not be represented as a `mpfr_t'.
-
-     Note: If you want to store a floating-point constant to a `mpfr_t',
-     you should use `mpfr_set_str' (or one of the MPFR constant
-     functions, such as `mpfr_const_pi' for Pi) instead of
-     `mpfr_set_flt', `mpfr_set_d', `mpfr_set_ld' or
-     `mpfr_set_decimal64'.  Otherwise the floating-point constant will
+     RND.  Note that the input 0 is converted to +0 by mpfr_set_ui,
+     mpfr_set_si, mpfr_set_uj, mpfr_set_sj, mpfr_set_z,
+     mpfr_set_q and mpfr_set_f, regardless of the rounding mode.  If
+     the system does not support the IEEE 754 standard, mpfr_set_flt,
+     mpfr_set_d, mpfr_set_ld and mpfr_set_decimal64 might not
+     preserve the signed zeros.  The mpfr_set_decimal64 function is
+     built only with the configure option --enable-decimal-float,
+     which also requires --with-gmp-build, and when the compiler or
+     system provides the _Decimal64 data type (recent versions of GCC
+     support this data type).  mpfr_set_q might fail if the numerator
+     (or the denominator) can not be represented as a mpfr_t.
+
+     Note: If you want to store a floating-point constant to a mpfr_t,
+     you should use mpfr_set_str (or one of the MPFR constant
+     functions, such as mpfr_const_pi for Pi) instead of
+     mpfr_set_flt, mpfr_set_d, mpfr_set_ld or
+     mpfr_set_decimal64.  Otherwise the floating-point constant will
      be first converted into a reduced-precision (e.g., 53-bit) binary
      number before MPFR can work with it.
 
@@ -896,8 +877,8 @@ Initialization Functions::).
           E, mpfr_rnd_t RND)
  -- Function: int mpfr_set_uj_2exp (mpfr_t ROP, uintmax_t OP, intmax_t
           E, mpfr_rnd_t RND)
- -- Function: int mpfr_set_sj_2exp (mpfr_t ROP, intmax_t OP, intmax_t
-          E, mpfr_rnd_t RND)
+ -- Function: int mpfr_set_sj_2exp (mpfr_t ROP, intmax_t OP, intmax_t E,
+          mpfr_rnd_t RND)
  -- Function: int mpfr_set_z_2exp (mpfr_t ROP, mpz_t OP, mpfr_exp_t E,
           mpfr_rnd_t RND)
      Set the value of ROP from OP multiplied by two to the power E,
@@ -907,92 +888,91 @@ Initialization Functions::).
  -- Function: int mpfr_set_str (mpfr_t ROP, const char *S, int BASE,
           mpfr_rnd_t RND)
      Set ROP to the value of the string S in base BASE, rounded in the
-     direction RND.  See the documentation of `mpfr_strtofr' for a
+     direction RND.  See the documentation of mpfr_strtofr for a
      detailed description of the valid string formats.  Contrary to
-     `mpfr_strtofr', `mpfr_set_str' requires the _whole_ string to
+     mpfr_strtofr, mpfr_set_str requires the _whole_ string to
      represent a valid floating-point number.  This function returns 0
      if the entire string up to the final null character is a valid
-     number in base BASE; otherwise it returns -1, and ROP may have
-     changed.  Note: it is preferable to use `mpfr_set_str' if one
-     wants to distinguish between an infinite ROP value coming from an
+     number in base BASE; otherwise it returns 1, and ROP may have
+     changed.  Note: it is preferable to use mpfr_set_str if one wants
+     to distinguish between an infinite ROP value coming from an
      infinite S or from an overflow.
 
  -- Function: int mpfr_strtofr (mpfr_t ROP, const char *NPTR, char
           **ENDPTR, int BASE, mpfr_rnd_t RND)
+
      Read a floating-point number from a string NPTR in base BASE,
      rounded in the direction RND; BASE must be either 0 (to detect the
      base, as described below) or a number from 2 to 62 (otherwise the
-     behavior is undefined). If NPTR starts with valid data, the result
-     is stored in ROP and `*ENDPTR' points to the character just after
+     behavior is undefined).  If NPTR starts with valid data, the result
+     is stored in ROP and *ENDPTR points to the character just after
      the valid data (if ENDPTR is not a null pointer); otherwise ROP is
-     set to zero (for consistency with `strtod') and the value of NPTR
+     set to zero (for consistency with strtod) and the value of NPTR
      is stored in the location referenced by ENDPTR (if ENDPTR is not a
-     null pointer). The usual ternary value is returned.
+     null pointer).  The usual ternary value is returned.
 
-     Parsing follows the standard C `strtod' function with some
+     Parsing follows the standard C strtod function with some
      extensions.  After optional leading whitespace, one has a subject
-     sequence consisting of an optional sign (`+' or `-'), and either
-     numeric data or special data. The subject sequence is defined as
+     sequence consisting of an optional sign (+ or -), and either
+     numeric data or special data.  The subject sequence is defined as
      the longest initial subsequence of the input string, starting with
      the first non-whitespace character, that is of the expected form.
 
      The form of numeric data is a non-empty sequence of significand
      digits with an optional decimal point, and an optional exponent
-     consisting of an exponent prefix followed by an optional sign and
-     a non-empty sequence of decimal digits. A significand digit is
+     consisting of an exponent prefix followed by an optional sign and a
+     non-empty sequence of decimal digits.  A significand digit is
      either a decimal digit or a Latin letter (62 possible characters),
-     with `A' = 10, `B' = 11, ..., `Z' = 35; case is ignored in bases
-     less or equal to 36, in bases larger than 36, `a' = 36, `b' = 37,
-     ..., `z' = 61.  The value of a significand digit must be strictly
+     with A = 10, B = 11, ..., Z = 35; case is ignored in bases
+     less or equal to 36, in bases larger than 36, a = 36, b = 37,
+     ..., z = 61.  The value of a significand digit must be strictly
      less than the base.  The decimal point can be either the one
      defined by the current locale or the period (the first one is
      accepted for consistency with the C standard and the practice, the
      second one is accepted to allow the programmer to provide MPFR
      numbers from strings in a way that does not depend on the current
-     locale).  The exponent prefix can be `e' or `E' for bases up to
-     10, or `@' in any base; it indicates a multiplication by a power
-     of the base. In bases 2 and 16, the exponent prefix can also be
-     `p' or `P', in which case the exponent, called _binary exponent_,
+     locale).  The exponent prefix can be e or E for bases up to 10,
+     or @ in any base; it indicates a multiplication by a power of the
+     base.  In bases 2 and 16, the exponent prefix can also be p or
+     P, in which case the exponent, called _binary exponent_,
      indicates a multiplication by a power of 2 instead of the base
      (there is a difference only for base 16); in base 16 for example
-     `1p2' represents 4 whereas `1@2' represents 256. The value of an
+     1p2 represents 4 whereas 1@2 represents 256.  The value of an
      exponent is always written in base 10.
 
      If the argument BASE is 0, then the base is automatically detected
-     as follows. If the significand starts with `0b' or `0B', base 2 is
-     assumed. If the significand starts with `0x' or `0X', base 16 is
-     assumed. Otherwise base 10 is assumed.
+     as follows.  If the significand starts with 0b or 0B, base 2 is
+     assumed.  If the significand starts with 0x or 0X, base 16 is
+     assumed.  Otherwise base 10 is assumed.
 
      Note: The exponent (if present) must contain at least a digit.
-     Otherwise the possible exponent prefix and sign are not part of
-     the number (which ends with the significand). Similarly, if `0b',
-     `0B', `0x' or `0X' is not followed by a binary/hexadecimal digit,
-     then the subject sequence stops at the character `0', thus 0 is
+     Otherwise the possible exponent prefix and sign are not part of the
+     number (which ends with the significand).  Similarly, if 0b,
+     0B, 0x or 0X is not followed by a binary/hexadecimal digit,
+     then the subject sequence stops at the character 0, thus 0 is
      read.
 
-     Special data (for infinities and NaN) can be `@inf@' or
-     `@nan@(n-char-sequence-opt)', and if BASE <= 16, it can also be
-     `infinity', `inf', `nan' or `nan(n-char-sequence-opt)', all case
-     insensitive.  A `n-char-sequence-opt' is a possibly empty string
+     Special data (for infinities and NaN) can be @inf@ or
+     @nan@(n-char-sequence-opt), and if BASE <= 16, it can also be
+     infinity, inf, nan or nan(n-char-sequence-opt), all case
+     insensitive.  A n-char-sequence-opt is a possibly empty string
      containing only digits, Latin letters and the underscore (0, 1, 2,
-     ..., 9, a, b, ..., z, A, B, ..., Z, _). Note: one has an optional
-     sign for all data, even NaN.  For example,
-     `-@nAn@(This_Is_Not_17)' is a valid representation for NaN in base
-     17.
-
+     ..., 9, a, b, ..., z, A, B, ..., Z, _).  Note: one has an optional
+     sign for all data, even NaN. For example, -@nAn@(This_Is_Not_17)
+     is a valid representation for NaN in base 17.
 
  -- Function: void mpfr_set_nan (mpfr_t X)
  -- Function: void mpfr_set_inf (mpfr_t X, int SIGN)
  -- Function: void mpfr_set_zero (mpfr_t X, int SIGN)
      Set the variable X to NaN (Not-a-Number), infinity or zero
-     respectively.  In `mpfr_set_inf' or `mpfr_set_zero', X is set to
+     respectively.  In mpfr_set_inf or mpfr_set_zero, X is set to
      plus infinity or plus zero iff SIGN is nonnegative; in
-     `mpfr_set_nan', the sign bit of the result is unspecified.
+     mpfr_set_nan, the sign bit of the result is unspecified.
 
  -- Function: void mpfr_swap (mpfr_t X, mpfr_t Y)
-     Swap the values X and Y efficiently. Warning: the precisions are
-     exchanged too; in case the precisions are different, `mpfr_swap'
-     is thus not equivalent to three `mpfr_set' calls using a third
+     Swap the values X and Y efficiently.  Warning: the precisions are
+     exchanged too; in case the precisions are different, mpfr_swap is
+     thus not equivalent to three mpfr_set calls using a third
      auxiliary variable.
 
 
@@ -1014,12 +994,12 @@ File: mpfr.info,  Node: Combined Initialization and Assignment Functions,  Next:
  -- Macro: int mpfr_init_set_f (mpfr_t ROP, mpf_t OP, mpfr_rnd_t RND)
      Initialize ROP and set its value from OP, rounded in the direction
      RND.  The precision of ROP will be taken from the active default
-     precision, as set by `mpfr_set_default_prec'.
+     precision, as set by mpfr_set_default_prec.
 
  -- Function: int mpfr_init_set_str (mpfr_t X, const char *S, int BASE,
           mpfr_rnd_t RND)
      Initialize X and set its value from the string S in base BASE,
-     rounded in the direction RND.  See `mpfr_set_str'.
+     rounded in the direction RND.  See mpfr_set_str.
 
 
 File: mpfr.info,  Node: Conversion Functions,  Next: Basic Arithmetic Functions,  Prev: Combined Initialization and Assignment Functions,  Up: MPFR Interface
@@ -1031,35 +1011,35 @@ File: mpfr.info,  Node: Conversion Functions,  Next: Basic Arithmetic Functions,
  -- Function: double mpfr_get_d (mpfr_t OP, mpfr_rnd_t RND)
  -- Function: long double mpfr_get_ld (mpfr_t OP, mpfr_rnd_t RND)
  -- Function: _Decimal64 mpfr_get_decimal64 (mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a `float' (respectively `double', `long double' or
-     `_Decimal64'), using the rounding mode RND.  If OP is NaN, some
+     Convert OP to a float (respectively double, long double or
+     _Decimal64), using the rounding mode RND.  If OP is NaN, some
      fixed NaN (either quiet or signaling) or the result of 0.0/0.0 is
-     returned. If OP is Inf, an infinity of the same sign or the
-     result of 1.0/0.0 is returned. If OP is zero, these functions
+     returned.  If OP is Inf, an infinity of the same sign or the
+     result of 1.0/0.0 is returned.  If OP is zero, these functions
      return a zero, trying to preserve its sign, if possible.  The
-     `mpfr_get_decimal64' function is built only under some conditions:
-     see the documentation of `mpfr_set_decimal64'.
+     mpfr_get_decimal64 function is built only under some conditions:
+     see the documentation of mpfr_set_decimal64.
 
  -- Function: long mpfr_get_si (mpfr_t OP, mpfr_rnd_t RND)
  -- Function: unsigned long mpfr_get_ui (mpfr_t OP, mpfr_rnd_t RND)
  -- Function: intmax_t mpfr_get_sj (mpfr_t OP, mpfr_rnd_t RND)
  -- Function: uintmax_t mpfr_get_uj (mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a `long', an `unsigned long', an `intmax_t' or an
-     `uintmax_t' (respectively) after rounding it with respect to RND.
-     If OP is NaN, 0 is returned and the _erange_ flag is set.  If OP
-     is too big for the return type, the function returns the maximum
-     or the minimum of the corresponding C type, depending on the
-     direction of the overflow; the _erange_ flag is set too.  See also
-     `mpfr_fits_slong_p', `mpfr_fits_ulong_p', `mpfr_fits_intmax_p' and
-     `mpfr_fits_uintmax_p'.
+     Convert OP to a long, an unsigned long, an intmax_t or an
+     uintmax_t (respectively) after rounding it with respect to RND.
+     If OP is NaN, 0 is returned and the _erange_ flag is set.  If OP is
+     too big for the return type, the function returns the maximum or
+     the minimum of the corresponding C type, depending on the direction
+     of the overflow; the _erange_ flag is set too.  See also
+     mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and
+     mpfr_fits_uintmax_p.
 
  -- Function: double mpfr_get_d_2exp (long *EXP, mpfr_t OP, mpfr_rnd_t
           RND)
  -- Function: long double mpfr_get_ld_2exp (long *EXP, mpfr_t OP,
           mpfr_rnd_t RND)
      Return D and set EXP (formally, the value pointed to by EXP) such
-     that 0.5<=abs(D)<1 and D times 2 raised to EXP equals OP rounded
-     to double (resp. long double) precision, using the given rounding
+     that 0.5<=abs(D)<1 and D times 2 raised to EXP equals OP rounded to
+     double (resp. long double) precision, using the given rounding
      mode.  If OP is zero, then a zero of the same sign (or an unsigned
      zero, if the implementation does not have signed zeros) is
      returned, and EXP is set to 0.  If OP is NaN or an infinity, then
@@ -1071,45 +1051,45 @@ File: mpfr.info,  Node: Conversion Functions,  Next: Basic Arithmetic Functions,
      precision of OP) into ROP, and return the exponent EXP (which may
      be outside the current exponent range) such that OP exactly equals
      ROP times 2 raised to the power EXP.  If OP is zero, the minimal
-     exponent `emin' is returned.  If OP is NaN or an infinity, the
-     _erange_ flag is set, ROP is set to 0, and the the minimal
-     exponent `emin' is returned.  The returned exponent may be less
-     than the minimal exponent `emin' of MPFR numbers in the current
-     exponent range; in case the exponent is not representable in the
-     `mpfr_exp_t' type, the _erange_ flag is set and the minimal value
-     of the `mpfr_exp_t' type is returned.
+     exponent emin is returned.  If OP is NaN or an infinity, the
+     _erange_ flag is set, ROP is set to 0, and the the minimal exponent
+     emin is returned.  The returned exponent may be less than the
+     minimal exponent emin of MPFR numbers in the current exponent
+     range; in case the exponent is not representable in the
+     mpfr_exp_t type, the _erange_ flag is set and the minimal value
+     of the mpfr_exp_t type is returned.
 
  -- Function: int mpfr_get_z (mpz_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a `mpz_t', after rounding it with respect to RND. If
+     Convert OP to a mpz_t, after rounding it with respect to RND.  If
      OP is NaN or an infinity, the _erange_ flag is set, ROP is set to
      0, and 0 is returned.
 
  -- Function: int mpfr_get_f (mpf_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a `mpf_t', after rounding it with respect to RND.
+     Convert OP to a mpf_t, after rounding it with respect to RND.
      The _erange_ flag is set if OP is NaN or Inf, which do not exist in
      MPF.
 
- -- Function: char * mpfr_get_str (char *STR, mpfr_exp_t *EXPPTR, int
-          B, size_t N, mpfr_t OP, mpfr_rnd_t RND)
+ -- Function: char * mpfr_get_str (char *STR, mpfr_exp_t *EXPPTR, int B,
+          size_t N, mpfr_t OP, mpfr_rnd_t RND)
      Convert OP to a string of digits in base B, with rounding in the
      direction RND, where N is either zero (see below) or the number of
-     significant digits output in the string; in the latter case, N
-     must be greater or equal to 2. The base may vary from 2 to 62.  If
-     the input number is an ordinary number, the exponent is written
-     through the pointer EXPPTR (for input 0, the current minimal
-     exponent is written).
+     significant digits output in the string; in the latter case, N must
+     be greater or equal to 2.  The base may vary from 2 to 62.  If the
+     input number is an ordinary number, the exponent is written through
+     the pointer EXPPTR (for input 0, the current minimal exponent is
+     written).
 
      The generated string is a fraction, with an implicit radix point
      immediately to the left of the first digit.  For example, the
-     number -3.1416 would be returned as "-31416" in the string and 1
+     number 3.1416 would be returned as "31416" in the string and 1
      written at EXPPTR.  If RND is to nearest, and OP is exactly in the
      middle of two consecutive possible outputs, the one with an even
      significand is chosen, where both significands are considered with
      the exponent of OP.  Note that for an odd base, this may not
-     correspond to an even last digit: for example with 2 digits in
-     base 7, (14) and a half is rounded to (15) which is 12 in decimal,
-     (16) and a half is rounded to (20) which is 14 in decimal, and
-     (26) and a half is rounded to (26) which is 20 in decimal.
+     correspond to an even last digit: for example with 2 digits in base
+     7, (14) and a half is rounded to (15) which is 12 in decimal, (16)
+     and a half is rounded to (20) which is 14 in decimal, and (26) and
+     a half is rounded to (26) which is 20 in decimal.
 
      If N is zero, the number of digits of the significand is chosen
      large enough so that re-reading the printed value with the same
@@ -1118,29 +1098,29 @@ File: mpfr.info,  Node: Conversion Functions,  Next: Basic Arithmetic Functions,
      cases, the chosen precision of STR is the minimal precision m
      depending only on P = PREC(OP) and B that satisfies the above
      property, i.e., m = 1 + ceil(P*log(2)/log(B)), with P replaced by
-     P-1 if B is a power of 2, but in some very rare cases, it might be
+     P1 if B is a power of 2, but in some very rare cases, it might be
      m+1 (the smallest case for bases up to 62 is when P equals
      186564318007 for bases 7 and 49).
 
      If STR is a null pointer, space for the significand is allocated
      using the current allocation function, and a pointer to the string
      is returned.  To free the returned string, you must use
-     `mpfr_free_str'.
+     mpfr_free_str.
 
      If STR is not a null pointer, it should point to a block of storage
-     large enough for the significand, i.e., at least `max(N + 2, 7)'.
+     large enough for the significand, i.e., at least max(N + 2, 7).
      The extra two bytes are for a possible minus sign, and for the
-     terminating null character, and the value 7 accounts for `-@Inf@'
+     terminating null character, and the value 7 accounts for -@Inf@
      plus the terminating null character.
 
      A pointer to the string is returned, unless there is an error, in
      which case a null pointer is returned.
 
  -- Function: void mpfr_free_str (char *STR)
-     Free a string allocated by `mpfr_get_str' using the current
-     unallocation function.  The block is assumed to be `strlen(STR)+1'
-     bytes.  For more information about how it is done: *note Custom
-     Allocation: (gmp.info)Custom Allocation.
+     Free a string allocated by mpfr_get_str using the current
+     unallocation function.  The block is assumed to be strlen(STR)+1
+     bytes.  For more information about how it is done: *note
+     (gmp.info)Custom Allocation::.
 
  -- Function: int mpfr_fits_ulong_p (mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_fits_slong_p (mpfr_t OP, mpfr_rnd_t RND)
@@ -1151,9 +1131,9 @@ File: mpfr.info,  Node: Conversion Functions,  Next: Basic Arithmetic Functions,
  -- Function: int mpfr_fits_uintmax_p (mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_fits_intmax_p (mpfr_t OP, mpfr_rnd_t RND)
      Return non-zero if OP would fit in the respective C data type,
-     respectively `unsigned long', `long', `unsigned int', `int',
-     `unsigned short', `short', `uintmax_t', `intmax_t', when rounded
-     to an integer in the direction RND.
+     respectively unsigned long, long, unsigned int, int,
+     unsigned short, short, uintmax_t, intmax_t, when rounded to
+     an integer in the direction RND.
 
 
 File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,  Prev: Conversion Functions,  Up: MPFR Interface
@@ -1163,8 +1143,8 @@ File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,
 
  -- Function: int mpfr_add (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
- -- Function: int mpfr_add_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
+ -- Function: int mpfr_add_ui (mpfr_t ROP, mpfr_t OP1, unsigned long int
+          OP2, mpfr_rnd_t RND)
  -- Function: int mpfr_add_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
           mpfr_rnd_t RND)
  -- Function: int mpfr_add_d (mpfr_t ROP, mpfr_t OP1, double OP2,
@@ -1173,19 +1153,19 @@ File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,
           mpfr_rnd_t RND)
  -- Function: int mpfr_add_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
           mpfr_rnd_t RND)
-     Set ROP to OP1 + OP2 rounded in the direction RND. For types
+     Set ROP to OP1 + OP2 rounded in the direction RND.  For types
      having no signed zero, it is considered unsigned (i.e., (+0) + 0 =
-     (+0) and (-0) + 0 = (-0)).  The `mpfr_add_d' function assumes that
-     the radix of the `double' type is a power of 2, with a precision
-     at most that declared by the C implementation (macro
-     `IEEE_DBL_MANT_DIG', and if not defined 53 bits).
+     (+0) and (0) + 0 = (0)).  The mpfr_add_d function assumes that
+     the radix of the double type is a power of 2, with a precision at
+     most that declared by the C implementation (macro
+     IEEE_DBL_MANT_DIG, and if not defined 53 bits).
 
  -- Function: int mpfr_sub (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
- -- Function: int mpfr_ui_sub (mpfr_t ROP, unsigned long int OP1,
-          mpfr_t OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_sub_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
+ -- Function: int mpfr_ui_sub (mpfr_t ROP, unsigned long int OP1, mpfr_t
+          OP2, mpfr_rnd_t RND)
+ -- Function: int mpfr_sub_ui (mpfr_t ROP, mpfr_t OP1, unsigned long int
+          OP2, mpfr_rnd_t RND)
  -- Function: int mpfr_si_sub (mpfr_t ROP, long int OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
  -- Function: int mpfr_sub_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
@@ -1198,16 +1178,16 @@ File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,
           mpfr_rnd_t RND)
  -- Function: int mpfr_sub_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
           mpfr_rnd_t RND)
-     Set ROP to OP1 - OP2 rounded in the direction RND. For types
-     having no signed zero, it is considered unsigned (i.e., (+0) - 0 =
-     (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).  The
-     same restrictions than for `mpfr_add_d' apply to `mpfr_d_sub' and
-     `mpfr_sub_d'.
+     Set ROP to OP1 - OP2 rounded in the direction RND.  For types
+     having no signed zero, it is considered unsigned (i.e., (+0)  0 =
+     (+0), (0)  0 = (0), 0  (+0) = (0) and 0  (0) = (+0)).  The
+     same restrictions than for mpfr_add_d apply to mpfr_d_sub and
+     mpfr_sub_d.
 
  -- Function: int mpfr_mul (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
- -- Function: int mpfr_mul_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
+ -- Function: int mpfr_mul_ui (mpfr_t ROP, mpfr_t OP1, unsigned long int
+          OP2, mpfr_rnd_t RND)
  -- Function: int mpfr_mul_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
           mpfr_rnd_t RND)
  -- Function: int mpfr_mul_d (mpfr_t ROP, mpfr_t OP1, double OP2,
@@ -1219,18 +1199,18 @@ File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,
      Set ROP to OP1 times OP2 rounded in the direction RND.  When a
      result is zero, its sign is the product of the signs of the
      operands (for types having no signed zero, it is considered
-     positive).  The same restrictions than for `mpfr_add_d' apply to
-     `mpfr_mul_d'.
+     positive).  The same restrictions than for mpfr_add_d apply to
+     mpfr_mul_d.
 
  -- Function: int mpfr_sqr (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
      Set ROP to the square of OP rounded in the direction RND.
 
  -- Function: int mpfr_div (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
- -- Function: int mpfr_ui_div (mpfr_t ROP, unsigned long int OP1,
-          mpfr_t OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_div_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
+ -- Function: int mpfr_ui_div (mpfr_t ROP, unsigned long int OP1, mpfr_t
+          OP2, mpfr_rnd_t RND)
+ -- Function: int mpfr_div_ui (mpfr_t ROP, mpfr_t OP1, unsigned long int
+          OP2, mpfr_rnd_t RND)
  -- Function: int mpfr_si_div (mpfr_t ROP, long int OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
  -- Function: int mpfr_div_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
@@ -1246,84 +1226,70 @@ File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,
      Set ROP to OP1/OP2 rounded in the direction RND.  When a result is
      zero, its sign is the product of the signs of the operands (for
      types having no signed zero, it is considered positive).  The same
-     restrictions than for `mpfr_add_d' apply to `mpfr_d_div' and
-     `mpfr_div_d'.
+     restrictions than for mpfr_add_d apply to mpfr_d_div and
+     mpfr_div_d.
 
  -- Function: int mpfr_sqrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_sqrt_ui (mpfr_t ROP, unsigned long int OP,
           mpfr_rnd_t RND)
      Set ROP to the square root of OP rounded in the direction RND (set
-     ROP to -0 if OP is -0, to be consistent with the IEEE 754
+     ROP to 0 if OP is 0, to be consistent with the IEEE 754
      standard).  Set ROP to NaN if OP is negative.
 
  -- Function: int mpfr_rec_sqrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
      Set ROP to the reciprocal square root of OP rounded in the
-     direction RND. Set ROP to +Inf if OP is 0, +0 if OP is +Inf, and
+     direction RND.  Set ROP to +Inf if OP is 0, +0 if OP is +Inf, and
      NaN if OP is negative.
 
  -- Function: int mpfr_cbrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_root (mpfr_t ROP, mpfr_t OP, unsigned long int
-          K, mpfr_rnd_t RND)
-     Set ROP to the cubic root (resp. the Kth root) of OP rounded in
-     the direction RND.  For K odd (resp. even) and OP negative
-     (including -Inf), set ROP to a negative number (resp. NaN).  The
-     Kth root of -0 is defined to be -0, whatever the parity of K.
+ -- Function: int mpfr_root (mpfr_t ROP, mpfr_t OP, unsigned long int K,
+          mpfr_rnd_t RND)
+     Set ROP to the cubic root (resp. the Kth root) of OP rounded in the
+     direction RND.  For K odd (resp. even) and OP negative (including
+     Inf), set ROP to a negative number (resp. NaN). The Kth root of 0
+     is defined to be 0, whatever the parity of K.
 
  -- Function: int mpfr_pow (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
- -- Function: int mpfr_pow_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
+ -- Function: int mpfr_pow_ui (mpfr_t ROP, mpfr_t OP1, unsigned long int
+          OP2, mpfr_rnd_t RND)
  -- Function: int mpfr_pow_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
           mpfr_rnd_t RND)
  -- Function: int mpfr_pow_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
           mpfr_rnd_t RND)
  -- Function: int mpfr_ui_pow_ui (mpfr_t ROP, unsigned long int OP1,
           unsigned long int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_ui_pow (mpfr_t ROP, unsigned long int OP1,
-          mpfr_t OP2, mpfr_rnd_t RND)
+ -- Function: int mpfr_ui_pow (mpfr_t ROP, unsigned long int OP1, mpfr_t
+          OP2, mpfr_rnd_t RND)
      Set ROP to OP1 raised to OP2, rounded in the direction RND.
      Special values are handled as described in the ISO C99 and IEEE
-     754-2008 standards for the `pow' function:
-        * `pow(0, Y)' returns plus or minus infinity for Y a negative
+     754-2008 standards for the pow function:
+         pow(0, Y) returns plus or minus infinity for Y a negative
           odd integer.
-
-        * `pow(0, Y)' returns plus infinity for Y negative and not an
+         pow(0, Y) returns plus infinity for Y negative and not an
           odd integer.
-
-        * `pow(0, Y)' returns plus or minus zero for Y a positive odd
+         pow(0, Y) returns plus or minus zero for Y a positive odd
           integer.
-
-        * `pow(0, Y)' returns plus zero for Y positive and not an odd
+         pow(0, Y) returns plus zero for Y positive and not an odd
           integer.
-
-        * `pow(-1, Inf)' returns 1.
-
-        * `pow(+1, Y)' returns 1 for any Y, even a NaN.
-
-        * `pow(X, 0)' returns 1 for any X, even a NaN.
-
-        * `pow(X, Y)' returns NaN for finite negative X and finite
+         pow(-1, Inf) returns 1.
+         pow(+1, Y) returns 1 for any Y, even a NaN.
+         pow(X, 0) returns 1 for any X, even a NaN.
+         pow(X, Y) returns NaN for finite negative X and finite
           non-integer Y.
-
-        * `pow(X, -Inf)' returns plus infinity for 0 < abs(x) < 1, and
+         pow(X, -Inf) returns plus infinity for 0 < abs(x) < 1, and
           plus zero for abs(x) > 1.
-
-        * `pow(X, +Inf)' returns plus zero for 0 < abs(x) < 1, and plus
+         pow(X, +Inf) returns plus zero for 0 < abs(x) < 1, and plus
           infinity for abs(x) > 1.
-
-        * `pow(-Inf, Y)' returns minus zero for Y a negative odd
+         pow(-Inf, Y) returns minus zero for Y a negative odd
           integer.
-
-        * `pow(-Inf, Y)' returns plus zero for Y negative and not an
-          odd integer.
-
-        * `pow(-Inf, Y)' returns minus infinity for Y a positive odd
+         pow(-Inf, Y) returns plus zero for Y negative and not an odd
           integer.
-
-        * `pow(-Inf, Y)' returns plus infinity for Y positive and not
-          an odd integer.
-
-        * `pow(+Inf, Y)' returns plus zero for Y negative, and plus
+         pow(-Inf, Y) returns minus infinity for Y a positive odd
+          integer.
+         pow(-Inf, Y) returns plus infinity for Y positive and not an
+          odd integer.
+         pow(+Inf, Y) returns plus zero for Y negative, and plus
           infinity for Y positive.
 
  -- Function: int mpfr_neg (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
@@ -1351,7 +1317,7 @@ File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,
  -- Function: int mpfr_div_2si (mpfr_t ROP, mpfr_t OP1, long int OP2,
           mpfr_rnd_t RND)
      Set ROP to OP1 divided by 2 raised to OP2 rounded in the direction
-     RND. Just decreases the exponent by OP2 when ROP and OP1 are
+     RND.  Just decreases the exponent by OP2 when ROP and OP1 are
      identical.
 
 
@@ -1368,14 +1334,14 @@ File: mpfr.info,  Node: Comparison Functions,  Next: Special Functions,  Prev: B
  -- Function: int mpfr_cmp_z (mpfr_t OP1, mpz_t OP2)
  -- Function: int mpfr_cmp_q (mpfr_t OP1, mpq_t OP2)
  -- Function: int mpfr_cmp_f (mpfr_t OP1, mpf_t OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, and a negative value if OP1 < OP2.  Both OP1 and OP2
-     are considered to their full own precision, which may differ.  If
-     one of the operands is NaN, set the _erange_ flag and return zero.
+     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero if
+     OP1 = OP2, and a negative value if OP1 < OP2.  Both OP1 and OP2 are
+     considered to their full own precision, which may differ.  If one
+     of the operands is NaN, set the _erange_ flag and return zero.
 
      Note: These functions may be useful to distinguish the three
      possible cases.  If you need to distinguish two cases only, it is
-     recommended to use the predicate functions (e.g., `mpfr_equal_p'
+     recommended to use the predicate functions (e.g., mpfr_equal_p
      for the equality) described below; they behave like the IEEE 754
      comparisons, in particular when one or both arguments are NaN. But
      only floating-point numbers can be compared (you may need to do a
@@ -1383,16 +1349,15 @@ File: mpfr.info,  Node: Comparison Functions,  Next: Special Functions,  Prev: B
 
  -- Function: int mpfr_cmp_ui_2exp (mpfr_t OP1, unsigned long int OP2,
           mpfr_exp_t E)
- -- Function: int mpfr_cmp_si_2exp (mpfr_t OP1, long int OP2,
-          mpfr_exp_t E)
-     Compare OP1 and OP2 multiplied by two to the power E. Similar as
+ -- Function: int mpfr_cmp_si_2exp (mpfr_t OP1, long int OP2, mpfr_exp_t
+          E)
+     Compare OP1 and OP2 multiplied by two to the power E.  Similar as
      above.
 
  -- Function: int mpfr_cmpabs (mpfr_t OP1, mpfr_t OP2)
-     Compare |OP1| and |OP2|.  Return a positive value if |OP1| >
-     |OP2|, zero if |OP1| = |OP2|, and a negative value if |OP1| <
-     |OP2|.  If one of the operands is NaN, set the _erange_ flag and
-     return zero.
+     Compare |OP1| and |OP2|.  Return a positive value if |OP1| > |OP2|,
+     zero if |OP1| = |OP2|, and a negative value if |OP1| < |OP2|.  If
+     one of the operands is NaN, set the _erange_ flag and return zero.
 
  -- Function: int mpfr_nan_p (mpfr_t OP)
  -- Function: int mpfr_inf_p (mpfr_t OP)
@@ -1401,14 +1366,14 @@ File: mpfr.info,  Node: Comparison Functions,  Next: Special Functions,  Prev: B
  -- Function: int mpfr_regular_p (mpfr_t OP)
      Return non-zero if OP is respectively NaN, an infinity, an ordinary
      number (i.e., neither NaN nor an infinity), zero, or a regular
-     number (i.e., neither NaN, nor an infinity nor zero). Return zero
+     number (i.e., neither NaN, nor an infinity nor zero).  Return zero
      otherwise.
 
  -- Macro: int mpfr_sgn (mpfr_t OP)
      Return a positive value if OP > 0, zero if OP = 0, and a negative
      value if OP < 0.  If the operand is NaN, set the _erange_ flag and
-     return zero.  This is equivalent to `mpfr_cmp_ui (op, 0)', but
-     more efficient.
+     return zero.  This is equivalent to mpfr_cmp_ui (op, 0), but more
+     efficient.
 
  -- Function: int mpfr_greater_p (mpfr_t OP1, mpfr_t OP2)
  -- Function: int mpfr_greaterequal_p (mpfr_t OP1, mpfr_t OP2)
@@ -1416,8 +1381,8 @@ File: mpfr.info,  Node: Comparison Functions,  Next: Special Functions,  Prev: B
  -- Function: int mpfr_lessequal_p (mpfr_t OP1, mpfr_t OP2)
  -- Function: int mpfr_equal_p (mpfr_t OP1, mpfr_t OP2)
      Return non-zero if OP1 > OP2, OP1 >= OP2, OP1 < OP2, OP1 <= OP2,
-     OP1 = OP2 respectively, and zero otherwise.  Those functions
-     return zero whenever OP1 and/or OP2 is NaN.
+     OP1 = OP2 respectively, and zero otherwise.  Those functions return
+     zero whenever OP1 and/or OP2 is NaN.
 
  -- Function: int mpfr_lessgreater_p (mpfr_t OP1, mpfr_t OP2)
      Return non-zero if OP1 < OP2 or OP1 > OP2 (i.e., neither OP1, nor
@@ -1435,8 +1400,8 @@ File: mpfr.info,  Node: Special Functions,  Next: Input and Output Functions,  P
 =====================
 
 All those functions, except explicitly stated (for example
-`mpfr_sin_cos'), return a ternary value as defined in Section "Rounding
-Modes", i.e., zero for an exact return value, a positive value for a
+mpfr_sin_cos), return a ternary value as defined in Section Rounding
+Modes, i.e., zero for an exact return value, a positive value for a
 return value larger than the exact result, and a negative value
 otherwise.
 
@@ -1449,13 +1414,13 @@ argument.
  -- Function: int mpfr_log2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_log10 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
      Set ROP to the natural logarithm of OP, log2(OP) or log10(OP),
-     respectively, rounded in the direction RND.  Set ROP to -Inf if OP
-     is -0 (i.e., the sign of the zero has no influence on the result).
+     respectively, rounded in the direction RND.  Set ROP to Inf if OP
+     is 0 (i.e., the sign of the zero has no influence on the result).
 
  -- Function: int mpfr_exp (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_exp2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_exp10 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the exponential of OP,  to 2 power of OP or to 10 power
+     Set ROP to the exponential of OP, to 2 power of OP or to 10 power
      of OP, respectively, rounded in the direction RND.
 
  -- Function: int mpfr_cos (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
@@ -1469,10 +1434,10 @@ argument.
      Set simultaneously SOP to the sine of OP and COP to the cosine of
      OP, rounded in the direction RND with the corresponding precisions
      of SOP and COP, which must be different variables.  Return 0 iff
-     both results are exact, more precisely it returns s+4c where s=0
-     if SOP is exact, s=1 if SOP is larger than the sine of OP, s=2 if
-     SOP is smaller than the sine of OP, and similarly for c and the
-     cosine of OP.
+     both results are exact, more precisely it returns s+4c where s=0 if
+     SOP is exact, s=1 if SOP is larger than the sine of OP, s=2 if SOP
+     is smaller than the sine of OP, and similarly for c and the cosine
+     of OP.
 
  -- Function: int mpfr_sec (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_csc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
@@ -1484,79 +1449,59 @@ argument.
  -- Function: int mpfr_asin (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_atan (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
      Set ROP to the arc-cosine, arc-sine or arc-tangent of OP, rounded
-     in the direction RND.  Note that since `acos(-1)' returns the
-     floating-point number closest to Pi according to the given
-     rounding mode, this number might not be in the output range 0 <=
-     ROP < \pi of the arc-cosine function; still, the result lies in
-     the image of the output range by the rounding function.  The same
-     holds for `asin(-1)', `asin(1)', `atan(-Inf)', `atan(+Inf)' or for
-     `atan(op)' with large OP and small precision of ROP.
-
- -- Function: int mpfr_atan2 (mpfr_t ROP, mpfr_t Y, mpfr_t X,
-          mpfr_rnd_t RND)
+     in the direction RND.  Note that since acos(-1) returns the
+     floating-point number closest to Pi according to the given rounding
+     mode, this number might not be in the output range 0 <= ROP < \pi
+     of the arc-cosine function; still, the result lies in the image of
+     the output range by the rounding function.  The same holds for
+     asin(-1), asin(1), atan(-Inf), atan(+Inf) or for atan(op)
+     with large OP and small precision of ROP.
+
+ -- Function: int mpfr_atan2 (mpfr_t ROP, mpfr_t Y, mpfr_t X, mpfr_rnd_t
+          RND)
      Set ROP to the arc-tangent2 of Y and X, rounded in the direction
-     RND: if `x > 0', `atan2(y, x) = atan (y/x)'; if `x < 0', `atan2(y,
-     x) = sign(y)*(Pi - atan (abs(y/x)))', thus a number from -Pi to Pi.
-     As for `atan', in case the exact mathematical result is +Pi or -Pi,
+     RND: if x > 0, atan2(y, x) = atan (y/x); if x < 0, atan2(y,
+     x) = sign(y)*(Pi - atan (abs(y/x))), thus a number from -Pi to Pi.
+     As for atan, in case the exact mathematical result is +Pi or -Pi,
      its rounded result might be outside the function output range.
 
-     `atan2(y, 0)' does not raise any floating-point exception.
-     Special values are handled as described in the ISO C99 and IEEE
-     754-2008 standards for the `atan2' function:
-        * `atan2(+0, -0)' returns +Pi.
-
-        * `atan2(-0, -0)' returns -Pi.
-
-        * `atan2(+0, +0)' returns +0.
-
-        * `atan2(-0, +0)' returns -0.
-
-        * `atan2(+0, x)' returns +Pi for x < 0.
-
-        * `atan2(-0, x)' returns -Pi for x < 0.
-
-        * `atan2(+0, x)' returns +0 for x > 0.
-
-        * `atan2(-0, x)' returns -0 for x > 0.
-
-        * `atan2(y, 0)' returns -Pi/2 for y < 0.
-
-        * `atan2(y, 0)' returns +Pi/2 for y > 0.
-
-        * `atan2(+Inf, -Inf)' returns +3*Pi/4.
-
-        * `atan2(-Inf, -Inf)' returns -3*Pi/4.
-
-        * `atan2(+Inf, +Inf)' returns +Pi/4.
-
-        * `atan2(-Inf, +Inf)' returns -Pi/4.
-
-        * `atan2(+Inf, x)' returns +Pi/2 for finite x.
-
-        * `atan2(-Inf, x)' returns -Pi/2 for finite x.
-
-        * `atan2(y, -Inf)' returns +Pi for finite y > 0.
-
-        * `atan2(y, -Inf)' returns -Pi for finite y < 0.
-
-        * `atan2(y, +Inf)' returns +0 for finite y > 0.
-
-        * `atan2(y, +Inf)' returns -0 for finite y < 0.
+     atan2(y, 0) does not raise any floating-point exception.  Special
+     values are handled as described in the ISO C99 and IEEE 754-2008
+     standards for the atan2 function:
+         atan2(+0, -0) returns +Pi.
+         atan2(-0, -0) returns -Pi.
+         atan2(+0, +0) returns +0.
+         atan2(-0, +0) returns 0.
+         atan2(+0, x) returns +Pi for x < 0.
+         atan2(-0, x) returns -Pi for x < 0.
+         atan2(+0, x) returns +0 for x > 0.
+         atan2(-0, x) returns 0 for x > 0.
+         atan2(y, 0) returns -Pi/2 for y < 0.
+         atan2(y, 0) returns +Pi/2 for y > 0.
+         atan2(+Inf, -Inf) returns +3*Pi/4.
+         atan2(-Inf, -Inf) returns -3*Pi/4.
+         atan2(+Inf, +Inf) returns +Pi/4.
+         atan2(-Inf, +Inf) returns -Pi/4.
+         atan2(+Inf, x) returns +Pi/2 for finite x.
+         atan2(-Inf, x) returns -Pi/2 for finite x.
+         atan2(y, -Inf) returns +Pi for finite y > 0.
+         atan2(y, -Inf) returns -Pi for finite y < 0.
+         atan2(y, +Inf) returns +0 for finite y > 0.
+         atan2(y, +Inf) returns 0 for finite y < 0.
 
  -- Function: int mpfr_cosh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_sinh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_tanh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the hyperbolic cosine, sine or tangent of OP, rounded
-     in the direction RND.
+     Set ROP to the hyperbolic cosine, sine or tangent of OP, rounded in
+     the direction RND.
 
  -- Function: int mpfr_sinh_cosh (mpfr_t SOP, mpfr_t COP, mpfr_t OP,
           mpfr_rnd_t RND)
      Set simultaneously SOP to the hyperbolic sine of OP and COP to the
      hyperbolic cosine of OP, rounded in the direction RND with the
      corresponding precision of SOP and COP, which must be different
-     variables.  Return 0 iff both results are exact (see
-     `mpfr_sin_cos' for a more detailed description of the return
-     value).
+     variables.  Return 0 iff both results are exact (see mpfr_sin_cos
+     for a more detailed description of the return value).
 
  -- Function: int mpfr_sech (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_csch (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
@@ -1583,33 +1528,33 @@ argument.
      rounded in the direction RND.
 
  -- Function: int mpfr_eint (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the exponential integral of OP, rounded in the
-     direction RND.  For positive OP, the exponential integral is the
-     sum of Euler's constant, of the logarithm of OP, and of the sum
-     for k from 1 to infinity of OP to the power k, divided by k and
-     factorial(k).  For negative OP, ROP is set to NaN.
+     Set ROP to the exponential integral of OP, rounded in the direction
+     RND.  For positive OP, the exponential integral is the sum of
+     Eulers constant, of the logarithm of OP, and of the sum for k from
+     1 to infinity of OP to the power k, divided by k and factorial(k).
+     For negative OP, ROP is set to NaN.
 
  -- Function: int mpfr_li2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
      Set ROP to real part of the dilogarithm of OP, rounded in the
-     direction RND. MPFR defines the dilogarithm function as the
+     direction RND.  MPFR defines the dilogarithm function as the
      integral of -log(1-t)/t from 0 to OP.
 
  -- Function: int mpfr_gamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
      Set ROP to the value of the Gamma function on OP, rounded in the
-     direction RND. When OP is a negative integer, ROP is set to NaN.
+     direction RND.  When OP is a negative integer, ROP is set to NaN.
 
  -- Function: int mpfr_lngamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
      Set ROP to the value of the logarithm of the Gamma function on OP,
-     rounded in the direction RND.  When -2K-1 <= OP <= -2K, K being a
-     non-negative integer, ROP is set to NaN.  See also `mpfr_lgamma'.
+     rounded in the direction RND.  When 2K1 <= OP <= 2K, K being a
+     non-negative integer, ROP is set to NaN. See also mpfr_lgamma.
 
  -- Function: int mpfr_lgamma (mpfr_t ROP, int *SIGNP, mpfr_t OP,
           mpfr_rnd_t RND)
      Set ROP to the value of the logarithm of the absolute value of the
-     Gamma function on OP, rounded in the direction RND. The sign (1 or
-     -1) of Gamma(OP) is returned in the object pointed to by SIGNP.
+     Gamma function on OP, rounded in the direction RND.  The sign (1 or
+     1) of Gamma(OP) is returned in the object pointed to by SIGNP.
      When OP is an infinity or a non-positive integer, set ROP to +Inf.
-     When OP is NaN, -Inf or a negative integer, *SIGNP is undefined,
+     When OP is NaN, Inf or a negative integer, *SIGNP is undefined,
      and when OP is 0, *SIGNP is the sign of the zero.
 
  -- Function: int mpfr_digamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
@@ -1618,10 +1563,10 @@ argument.
      negative integer, set ROP to NaN.
 
  -- Function: int mpfr_zeta (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_zeta_ui (mpfr_t ROP, unsigned long OP,
-          mpfr_rnd_t RND)
-     Set ROP to the value of the Riemann Zeta function on OP, rounded
-     in the direction RND.
+ -- Function: int mpfr_zeta_ui (mpfr_t ROP, unsigned long OP, mpfr_rnd_t
+          RND)
+     Set ROP to the value of the Riemann Zeta function on OP, rounded in
+     the direction RND.
 
  -- Function: int mpfr_erf (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
  -- Function: int mpfr_erfc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
@@ -1633,10 +1578,10 @@ argument.
  -- Function: int mpfr_jn (mpfr_t ROP, long N, mpfr_t OP, mpfr_rnd_t
           RND)
      Set ROP to the value of the first kind Bessel function of order 0,
-     (resp. 1 and N) on OP, rounded in the direction RND. When OP is
+     (resp. 1 and N) on OP, rounded in the direction RND.  When OP is
      NaN, ROP is always set to NaN. When OP is plus or minus Infinity,
-     ROP is set to +0. When OP is zero, and N is not zero, ROP is set
-     to +0 or -0 depending on the parity and sign of N, and the sign of
+     ROP is set to +0.  When OP is zero, and N is not zero, ROP is set
+     to +0 or 0 depending on the parity and sign of N, and the sign of
      OP.
 
  -- Function: int mpfr_y0 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
@@ -1644,9 +1589,9 @@ argument.
  -- Function: int mpfr_yn (mpfr_t ROP, long N, mpfr_t OP, mpfr_rnd_t
           RND)
      Set ROP to the value of the second kind Bessel function of order 0
-     (resp. 1 and N) on OP, rounded in the direction RND. When OP is
+     (resp. 1 and N) on OP, rounded in the direction RND.  When OP is
      NaN or negative, ROP is always set to NaN. When OP is +Inf, ROP is
-     set to +0. When OP is zero, ROP is set to +Inf or -Inf depending
+     set to +0.  When OP is zero, ROP is set to +Inf or Inf depending
      on the parity and sign of N.
 
  -- Function: int mpfr_fma (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2, mpfr_t
@@ -1658,56 +1603,55 @@ argument.
 
  -- Function: int mpfr_agm (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
-     Set ROP to the arithmetic-geometric mean of OP1 and OP2, rounded
-     in the direction RND.  The arithmetic-geometric mean is the common
-     limit of the sequences U_N and V_N, where U_0=OP1, V_0=OP2,
-     U_(N+1) is the arithmetic mean of U_N and V_N, and V_(N+1) is the
-     geometric mean of U_N and V_N.  If any operand is negative, set
-     ROP to NaN.
-
- -- Function: int mpfr_hypot (mpfr_t ROP, mpfr_t X, mpfr_t Y,
-          mpfr_rnd_t RND)
+     Set ROP to the arithmetic-geometric mean of OP1 and OP2, rounded in
+     the direction RND.  The arithmetic-geometric mean is the common
+     limit of the sequences U_N and V_N, where U_0=OP1, V_0=OP2, U_(N+1)
+     is the arithmetic mean of U_N and V_N, and V_(N+1) is the geometric
+     mean of U_N and V_N.  If any operand is negative, set ROP to NaN.
+
+ -- Function: int mpfr_hypot (mpfr_t ROP, mpfr_t X, mpfr_t Y, mpfr_rnd_t
+          RND)
      Set ROP to the Euclidean norm of X and Y, i.e., the square root of
      the sum of the squares of X and Y, rounded in the direction RND.
      Special values are handled as described in Section F.9.4.3 of the
-     ISO C99 and IEEE 754-2008 standards: If X or Y is an infinity,
-     then +Inf is returned in ROP, even if the other number is NaN.
+     ISO C99 and IEEE 754-2008 standards: If X or Y is an infinity, then
+     +Inf is returned in ROP, even if the other number is NaN.
 
  -- Function: int mpfr_ai (mpfr_t ROP, mpfr_t X, mpfr_rnd_t RND)
-     Set ROP to the value of the Airy function Ai  on X, rounded in the
+     Set ROP to the value of the Airy function Ai on X, rounded in the
      direction RND.  When X is NaN, ROP is always set to NaN. When X is
-     +Inf or -Inf, ROP is +0.  The current implementation is not
+     +Inf or Inf, ROP is +0.  The current implementation is not
      intended to be used with large arguments.  It works with abs(X)
-     typically smaller than 500. For larger arguments, other methods
+     typically smaller than 500.  For larger arguments, other methods
      should be used and will be implemented in a future version.
 
  -- Function: int mpfr_const_log2 (mpfr_t ROP, mpfr_rnd_t RND)
  -- Function: int mpfr_const_pi (mpfr_t ROP, mpfr_rnd_t RND)
  -- Function: int mpfr_const_euler (mpfr_t ROP, mpfr_rnd_t RND)
  -- Function: int mpfr_const_catalan (mpfr_t ROP, mpfr_rnd_t RND)
-     Set ROP to the logarithm of 2, the value of Pi, of Euler's
-     constant 0.577..., of Catalan's constant 0.915..., respectively,
-     rounded in the direction RND. These functions cache the computed
-     values to avoid other calculations if a lower or equal precision
-     is requested. To free these caches, use `mpfr_free_cache'.
+     Set ROP to the logarithm of 2, the value of Pi, of Eulers constant
+     0.577..., of Catalans constant 0.915..., respectively, rounded in
+     the direction RND.  These functions cache the computed values to
+     avoid other calculations if a lower or equal precision is
+     requested.  To free these caches, use mpfr_free_cache.
 
  -- Function: void mpfr_free_cache (void)
      Free various caches used by MPFR internally, in particular the
      caches used by the functions computing constants
-     (`mpfr_const_log2', `mpfr_const_pi', `mpfr_const_euler' and
-     `mpfr_const_catalan').  You should call this function before
+     (mpfr_const_log2, mpfr_const_pi, mpfr_const_euler and
+     mpfr_const_catalan).  You should call this function before
      terminating a thread, even if you did not call these functions
      directly (they could have been called internally).
 
  -- Function: int mpfr_sum (mpfr_t ROP, mpfr_ptr const TAB[], unsigned
           long int N, mpfr_rnd_t RND)
-     Set ROP to the sum of all elements of TAB, whose size is N,
-     rounded in the direction RND. Warning: for efficiency reasons, TAB
-     is an array of pointers to `mpfr_t', not an array of `mpfr_t'.  If
-     the returned `int' value is zero, ROP is guaranteed to be the
-     exact sum; otherwise ROP might be smaller than, equal to, or
-     larger than the exact sum (in accordance to the rounding mode).
-     However, `mpfr_sum' does guarantee the result is correctly rounded.
+     Set ROP to the sum of all elements of TAB, whose size is N, rounded
+     in the direction RND.  Warning: for efficiency reasons, TAB is an
+     array of pointers to mpfr_t, not an array of mpfr_t.  If the
+     returned int value is zero, ROP is guaranteed to be the exact
+     sum; otherwise ROP might be smaller than, equal to, or larger than
+     the exact sum (in accordance to the rounding mode).  However,
+     mpfr_sum does guarantee the result is correctly rounded.
 
 
 File: mpfr.info,  Node: Input and Output Functions,  Next: Formatted Output Functions,  Prev: Special Functions,  Up: MPFR Interface
@@ -1717,11 +1661,11 @@ File: mpfr.info,  Node: Input and Output Functions,  Next: Formatted Output Func
 
 This section describes functions that perform input from an input/output
 stream, and functions that output to an input/output stream.  Passing a
-null pointer for a `stream' to any of these functions will make them
-read from `stdin' and write to `stdout', respectively.
+null pointer for a stream to any of these functions will make them
+read from stdin and write to stdout, respectively.
 
-   When using any of these functions, you must include the `<stdio.h>'
-standard header before `mpfr.h', to allow `mpfr.h' to define prototypes
+   When using any of these functions, you must include the <stdio.h>
+standard header before mpfr.h, to allow mpfr.h to define prototypes
 for these functions.
 
  -- Function: size_t mpfr_out_str (FILE *STREAM, int BASE, size_t N,
@@ -1729,12 +1673,12 @@ for these functions.
      Output OP on stream STREAM, as a string of digits in base BASE,
      rounded in the direction RND.  The base may vary from 2 to 62.
      Print N significant digits exactly, or if N is 0, enough digits so
-     that OP can be read back exactly (see `mpfr_get_str').
+     that OP can be read back exactly (see mpfr_get_str).
 
      In addition to the significant digits, a decimal point (defined by
      the current locale) at the right of the first digit and a trailing
-     exponent in base 10, in the form `eNNN', are printed. If BASE is
-     greater than 10, `@' will be used instead of `e' as exponent
+     exponent in base 10, in the form eNNN, are printed.  If BASE is
+     greater than 10, @ will be used instead of e as exponent
      delimiter.
 
      Return the number of characters written, or if an error occurred,
@@ -1746,8 +1690,8 @@ for these functions.
      direction RND, and put the read float in ROP.
 
      This function reads a word (defined as a sequence of characters
-     between whitespace) and parses it using `mpfr_set_str'.  See the
-     documentation of `mpfr_strtofr' for a detailed description of the
+     between whitespace) and parses it using mpfr_set_str.  See the
+     documentation of mpfr_strtofr for a detailed description of the
      valid string formats.
 
      Return the number of bytes read, or if an error occurred, return 0.
@@ -1761,71 +1705,71 @@ File: mpfr.info,  Node: Formatted Output Functions,  Next: Integer Related Funct
 5.9.1 Requirements
 ------------------
 
-The class of `mpfr_printf' functions provides formatted output in a
-similar manner as the standard C `printf'. These functions are defined
+The class of mpfr_printf functions provides formatted output in a
+similar manner as the standard C printf.  These functions are defined
 only if your system supports ISO C variadic functions and the
 corresponding argument access macros.
 
-   When using any of these functions, you must include the `<stdio.h>'
-standard header before `mpfr.h', to allow `mpfr.h' to define prototypes
+   When using any of these functions, you must include the <stdio.h>
+standard header before mpfr.h, to allow mpfr.h to define prototypes
 for these functions.
 
 5.9.2 Format String
 -------------------
 
-The format specification accepted by `mpfr_printf' is an extension of
-the `printf' one. The conversion specification is of the form:
+The format specification accepted by mpfr_printf is an extension of
+the printf one.  The conversion specification is of the form:
      % [flags] [width] [.[precision]] [type] [rounding] conv
-   `flags', `width', and `precision' have the same meaning as for the
-standard `printf' (in particular, notice that the `precision' is
-related to the number of digits displayed in the base chosen by `conv'
-and not related to the internal precision of the `mpfr_t' variable).
-`mpfr_printf' accepts the same `type' specifiers as GMP (except the
-non-standard and deprecated `q', use `ll' instead), namely the length
+   flags, width, and precision have the same meaning as for the
+standard printf (in particular, notice that the precision is related
+to the number of digits displayed in the base chosen by conv and not
+related to the internal precision of the mpfr_t variable).
+mpfr_printf accepts the same type specifiers as GMP (except the
+non-standard and deprecated q, use ll instead), namely the length
 modifiers defined in the C standard:
 
-     `h'       `short'
-     `hh'      `char'
-     `j'       `intmax_t' or `uintmax_t'
-     `l'       `long' or `wchar_t'
-     `ll'      `long long'
-     `L'       `long double'
-     `t'       `ptrdiff_t'
-     `z'       `size_t'
-
-   and the `type' specifiers defined in GMP plus `R' and `P' specific
-to MPFR (the second column in the table below shows the type of the
-argument read in the argument list and the kind of `conv' specifier to
-use after the `type' specifier):
-
-     `F'       `mpf_t', float conversions
-     `Q'       `mpq_t', integer conversions
-     `M'       `mp_limb_t', integer conversions
-     `N'       `mp_limb_t' array, integer conversions
-     `Z'       `mpz_t', integer conversions
-     `P'       `mpfr_prec_t', integer conversions
-     `R'       `mpfr_t', float conversions
-
-   The `type' specifiers have the same restrictions as those mentioned
-in the GMP documentation: *note Formatted Output Strings:
-(gmp.info)Formatted Output Strings.  In particular, the `type'
-specifiers (except `R' and `P') are supported only if they are
-supported by `gmp_printf' in your GMP build; this implies that the
-standard specifiers, such as `t', must _also_ be supported by your C
-library if you want to use them.
-
-   The `rounding' field is specific to `mpfr_t' arguments and should
-not be used with other types.
-
-   With conversion specification not involving `P' and `R' types,
-`mpfr_printf' behaves exactly as `gmp_printf'.
-
-   The `P' type specifies that a following `o', `u', `x', or `X'
-conversion specifier applies to a `mpfr_prec_t' argument.  It is needed
-because the `mpfr_prec_t' type does not necessarily correspond to an
-`unsigned int' or any fixed standard type.  The `precision' field
-specifies the minimum number of digits to appear. The default
-`precision' is 1.  For example:
+     h       short
+     hh      char
+     j       intmax_t or uintmax_t
+     l       long or wchar_t
+     ll      long long
+     L       long double
+     t       ptrdiff_t
+     z       size_t
+
+   and the type specifiers defined in GMP plus R and P specific to
+MPFR (the second column in the table below shows the type of the
+argument read in the argument list and the kind of conv specifier to
+use after the type specifier):
+
+     F       mpf_t, float conversions
+     Q       mpq_t, integer conversions
+     M       mp_limb_t, integer conversions
+     N       mp_limb_t array, integer conversions
+     Z       mpz_t, integer conversions
+               
+     P       mpfr_prec_t, integer conversions
+     R       mpfr_t, float conversions
+
+   The type specifiers have the same restrictions as those mentioned
+in the GMP documentation: *note (gmp.info)Formatted Output Strings::.
+In particular, the type specifiers (except R and P) are supported
+only if they are supported by gmp_printf in your GMP build; this
+implies that the standard specifiers, such as t, must _also_ be
+supported by your C library if you want to use them.
+
+   The rounding field is specific to mpfr_t arguments and should not
+be used with other types.
+
+   With conversion specification not involving P and R types,
+mpfr_printf behaves exactly as gmp_printf.
+
+   The P type specifies that a following o, u, x, or X
+conversion specifier applies to a mpfr_prec_t argument.  It is needed
+because the mpfr_prec_t type does not necessarily correspond to an
+unsigned int or any fixed standard type.  The precision field
+specifies the minimum number of digits to appear.  The default
+precision is 1.  For example:
      mpfr_t x;
      mpfr_prec_t p;
      mpfr_init (x);
@@ -1833,19 +1777,19 @@ specifies the minimum number of digits to appear. The default
      p = mpfr_get_prec (x);
      mpfr_printf ("variable x with %Pu bits", p);
 
-   The `R' type specifies that a following `a', `A', `b', `e', `E',
-`f', `F', `g', `G', or `n' conversion specifier applies to a `mpfr_t'
-argument.  The `R' type can be followed by a `rounding' specifier
+   The R type specifies that a following a, A, b, e, E, f,
+F, g, G, or n conversion specifier applies to a mpfr_t
+argument.  The R type can be followed by a rounding specifier
 denoted by one of the following characters:
 
-     `U'       round toward plus infinity
-     `D'       round toward minus infinity
-     `Y'       round away from zero
-     `Z'       round toward zero
-     `N'       round to nearest
-     `*'       rounding mode indicated by the
-               `mpfr_rnd_t' argument just before the
-               corresponding `mpfr_t' variable.
+     U       round toward plus infinity
+     D       round toward minus infinity
+     Y       round away from zero
+     Z       round toward zero
+     N       round to nearest
+     *       rounding mode indicated by the
+               mpfr_rnd_t argument just before the
+               corresponding mpfr_t variable.
 
    The default rounding mode is rounding to nearest.  The following
 three examples are equivalent:
@@ -1856,69 +1800,69 @@ three examples are equivalent:
      mpfr_printf ("%.128RNf", x);
      mpfr_printf ("%.128R*f", MPFR_RNDN, x);
 
-   Note that the rounding away from zero mode is specified with `Y'
-because ISO C reserves the `A' specifier for hexadecimal output (see
+   Note that the rounding away from zero mode is specified with Y
+because ISO C reserves the A specifier for hexadecimal output (see
 below).
 
-   The output `conv' specifiers allowed with `mpfr_t' parameter are:
+   The output conv specifiers allowed with mpfr_t parameter are:
 
-     `a' `A'   hex float, C99 style
-     `b'       binary output
-     `e' `E'   scientific format float
-     `f' `F'   fixed point float
-     `g' `G'   fixed or scientific float
+     a A   hex float, C99 style
+     b       binary output
+     e E   scientific format float
+     f F   fixed point float
+     g G   fixed or scientific float
 
-   The conversion specifier `b' which displays the argument in binary is
-specific to `mpfr_t' arguments and should not be used with other types.
-Other conversion specifiers have the same meaning as for a `double'
+   The conversion specifier b which displays the argument in binary is
+specific to mpfr_t arguments and should not be used with other types.
+Other conversion specifiers have the same meaning as for a double
 argument.
 
    In case of non-decimal output, only the significand is written in the
 specified base, the exponent is always displayed in decimal.  Special
-values are always displayed as `nan', `-inf', and `inf' for `a', `b',
-`e', `f', and `g' specifiers and `NAN', `-INF', and `INF' for `A', `E',
-`F', and `G' specifiers.
-
-   If the `precision' field is not empty, the `mpfr_t' number is
-rounded to the given precision in the direction specified by the
-rounding mode.  If the precision is zero with rounding to nearest mode
-and one of the following `conv' specifiers: `a', `A', `b', `e', `E',
-tie case is rounded to even when it lies between two consecutive values
-at the wanted precision which have the same exponent, otherwise, it is
-rounded away from zero.  For instance, 85 is displayed as "8e+1" and 95
-is displayed as "1e+2" with the format specification `"%.0RNe"'.  This
-also applies when the `g' (resp. `G') conversion specifier uses the `e'
-(resp. `E') style.  If the precision is set to a value greater than the
-maximum value for an `int', it will be silently reduced down to
-`INT_MAX'.
-
-   If the `precision' field is empty (as in `%Re' or `%.RE') with
-`conv' specifier `e' and `E', the number is displayed with enough
-digits so that it can be read back exactly, assuming that the input and
-output variables have the same precision and that the input and output
-rounding modes are both rounding to nearest (as for `mpfr_get_str').
-The default precision for an empty `precision' field with `conv'
-specifiers `f', `F', `g', and `G' is 6.
+values are always displayed as nan, -inf, and inf for a, b,
+e, f, and g specifiers and NAN, -INF, and INF for A, E,
+F, and G specifiers.
+
+   If the precision field is not empty, the mpfr_t number is rounded
+to the given precision in the direction specified by the rounding mode.
+If the precision is zero with rounding to nearest mode and one of the
+following conv specifiers: a, A, b, e, E, tie case is
+rounded to even when it lies between two consecutive values at the
+wanted precision which have the same exponent, otherwise, it is rounded
+away from zero.  For instance, 85 is displayed as "8e+1" and 95 is
+displayed as "1e+2" with the format specification "%.0RNe".  This also
+applies when the g (resp.  G) conversion specifier uses the e
+(resp.  E) style.  If the precision is set to a value greater than the
+maximum value for an int, it will be silently reduced down to
+INT_MAX.
+
+   If the precision field is empty (as in %Re or %.RE) with conv
+specifier e and E, the number is displayed with enough digits so
+that it can be read back exactly, assuming that the input and output
+variables have the same precision and that the input and output rounding
+modes are both rounding to nearest (as for mpfr_get_str).  The default
+precision for an empty precision field with conv specifiers f,
+F, g, and G is 6.
 
 5.9.3 Functions
 ---------------
 
-For all the following functions, if the number of characters which
-ought to be written appears to exceed the maximum limit for an `int',
-nothing is written in the stream (resp. to `stdout', to BUF, to STR),
-the function returns -1, sets the _erange_ flag, and (in POSIX system
-only) `errno' is set to `EOVERFLOW'.
+For all the following functions, if the number of characters which ought
+to be written appears to exceed the maximum limit for an int, nothing
+is written in the stream (resp. to stdout, to BUF, to STR), the
+function returns 1, sets the _erange_ flag, and (in POSIX system only)
+errno is set to EOVERFLOW.
 
  -- Function: int mpfr_fprintf (FILE *STREAM, const char *TEMPLATE, ...)
  -- Function: int mpfr_vfprintf (FILE *STREAM, const char *TEMPLATE,
           va_list AP)
-     Print to the stream STREAM the optional arguments under the
-     control of the template string TEMPLATE.  Return the number of
-     characters written or a negative value if an error occurred.
+     Print to the stream STREAM the optional arguments under the control
+     of the template string TEMPLATE.  Return the number of characters
+     written or a negative value if an error occurred.
 
  -- Function: int mpfr_printf (const char *TEMPLATE, ...)
  -- Function: int mpfr_vprintf (const char *TEMPLATE, va_list AP)
-     Print to `stdout' the optional arguments under the control of the
+     Print to stdout the optional arguments under the control of the
      template string TEMPLATE.  Return the number of characters written
      or a negative value if an error occurred.
 
@@ -1927,7 +1871,7 @@ only) `errno' is set to `EOVERFLOW'.
           va_list AP)
      Form a null-terminated string corresponding to the optional
      arguments under the control of the template string TEMPLATE, and
-     print it in BUF. No overlap is permitted between BUF and the other
+     print it in BUF.  No overlap is permitted between BUF and the other
      arguments.  Return the number of characters written in the array
      BUF _not counting_ the terminating null character or a negative
      value if an error occurred.
@@ -1938,22 +1882,22 @@ only) `errno' is set to `EOVERFLOW'.
           *TEMPLATE, va_list AP)
      Form a null-terminated string corresponding to the optional
      arguments under the control of the template string TEMPLATE, and
-     print it in BUF. If N is zero, nothing is written and BUF may be a
-     null pointer, otherwise, the N-1 first characters are written in
+     print it in BUF.  If N is zero, nothing is written and BUF may be a
+     null pointer, otherwise, the N1 first characters are written in
      BUF and the N-th is a null character.  Return the number of
      characters that would have been written had N be sufficiently
-     large, _not counting_ the terminating null character, or a
-     negative value if an error occurred.
+     large, _not counting_ the terminating null character, or a negative
+     value if an error occurred.
 
  -- Function: int mpfr_asprintf (char **STR, const char *TEMPLATE, ...)
  -- Function: int mpfr_vasprintf (char **STR, const char *TEMPLATE,
           va_list AP)
-     Write their output as a null terminated string in a block of
-     memory allocated using the current allocation function. A pointer
-     to the block is stored in STR. The block of memory must be freed
-     using `mpfr_free_str'.  The return value is the number of
-     characters written in the string, excluding the null-terminator,
-     or a negative value if an error occurred.
+     Write their output as a null terminated string in a block of memory
+     allocated using the current allocation function.  A pointer to the
+     block is stored in STR.  The block of memory must be freed using
+     mpfr_free_str.  The return value is the number of characters
+     written in the string, excluding the null-terminator, or a negative
+     value if an error occurred.
 
 
 File: mpfr.info,  Node: Integer Related Functions,  Next: Rounding Related Functions,  Prev: Formatted Output Functions,  Up: MPFR Interface
@@ -1966,28 +1910,28 @@ File: mpfr.info,  Node: Integer Related Functions,  Next: Rounding Related Funct
  -- Function: int mpfr_floor (mpfr_t ROP, mpfr_t OP)
  -- Function: int mpfr_round (mpfr_t ROP, mpfr_t OP)
  -- Function: int mpfr_trunc (mpfr_t ROP, mpfr_t OP)
-     Set ROP to OP rounded to an integer.  `mpfr_rint' rounds to the
+     Set ROP to OP rounded to an integer.  mpfr_rint rounds to the
      nearest representable integer in the given direction RND,
-     `mpfr_ceil' rounds to the next higher or equal representable
-     integer, `mpfr_floor' to the next lower or equal representable
-     integer, `mpfr_round' to the nearest representable integer,
+     mpfr_ceil rounds to the next higher or equal representable
+     integer, mpfr_floor to the next lower or equal representable
+     integer, mpfr_round to the nearest representable integer,
      rounding halfway cases away from zero (as in the roundTiesToAway
-     mode of IEEE 754-2008), and `mpfr_trunc' to the next representable
+     mode of IEEE 754-2008), and mpfr_trunc to the next representable
      integer toward zero.
 
      The returned value is zero when the result is exact, positive when
      it is greater than the original value of OP, and negative when it
      is smaller.  More precisely, the returned value is 0 when OP is an
-     integer representable in ROP, 1 or -1 when OP is an integer that
-     is not representable in ROP, 2 or -2 when OP is not an integer.
-
-     Note that `mpfr_round' is different from `mpfr_rint' called with
-     the rounding to nearest mode (where halfway cases are rounded to
-     an even integer or significand). Note also that no double rounding
-     is performed; for instance, 10.5 (1010.1 in binary) is rounded by
-     `mpfr_rint' with rounding to nearest to 12 (1100 in binary) in
-     2-bit precision, because the two enclosing numbers representable
-     on two bits are 8 and 12, and the closest is 12.  (If one first
+     integer representable in ROP, 1 or 1 when OP is an integer that is
+     not representable in ROP, 2 or 2 when OP is not an integer.
+
+     Note that mpfr_round is different from mpfr_rint called with
+     the rounding to nearest mode (where halfway cases are rounded to an
+     even integer or significand).  Note also that no double rounding is
+     performed; for instance, 10.5 (1010.1 in binary) is rounded by
+     mpfr_rint with rounding to nearest to 12 (1100 in binary) in
+     2-bit precision, because the two enclosing numbers representable on
+     two bits are 8 and 12, and the closest is 12.  (If one first
      rounded to an integer, one would round 10.5 to 10 with even
      rounding, and then 10 would be rounded to 8 again with even
      rounding.)
@@ -1999,26 +1943,26 @@ File: mpfr.info,  Node: Integer Related Functions,  Next: Rounding Related Funct
           RND)
  -- Function: int mpfr_rint_trunc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t
           RND)
-     Set ROP to OP rounded to an integer.  `mpfr_rint_ceil' rounds to
-     the next higher or equal integer, `mpfr_rint_floor' to the next
-     lower or equal integer, `mpfr_rint_round' to the nearest integer,
-     rounding halfway cases away from zero, and `mpfr_rint_trunc' to
-     the next integer toward zero.  If the result is not representable,
-     it is rounded in the direction RND.  The returned value is the
-     ternary value associated with the considered round-to-integer
-     function (regarded in the same way as any other mathematical
-     function).  Contrary to `mpfr_rint', those functions do perform a
-     double rounding: first OP is rounded to the nearest integer in the
-     direction given by the function name, then this nearest integer
-     (if not representable) is rounded in the given direction RND.  For
-     example, `mpfr_rint_round' with rounding to nearest and a precision
+     Set ROP to OP rounded to an integer.  mpfr_rint_ceil rounds to
+     the next higher or equal integer, mpfr_rint_floor to the next
+     lower or equal integer, mpfr_rint_round to the nearest integer,
+     rounding halfway cases away from zero, and mpfr_rint_trunc to the
+     next integer toward zero.  If the result is not representable, it
+     is rounded in the direction RND.  The returned value is the ternary
+     value associated with the considered round-to-integer function
+     (regarded in the same way as any other mathematical function).
+     Contrary to mpfr_rint, those functions do perform a double
+     rounding: first OP is rounded to the nearest integer in the
+     direction given by the function name, then this nearest integer (if
+     not representable) is rounded in the given direction RND.  For
+     example, mpfr_rint_round with rounding to nearest and a precision
      of two bits rounds 6.5 to 7 (halfway cases away from zero), then 7
      is rounded to 8 by the round-even rule, despite the fact that 6 is
      also representable on two bits, and is closer to 6.5 than 8.
 
  -- Function: int mpfr_frac (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
      Set ROP to the fractional part of OP, having the same sign as OP,
-     rounded in the direction RND (unlike in `mpfr_rint', RND affects
+     rounded in the direction RND (unlike in mpfr_rint, RND affects
      only how the exact fractional part is rounded, not how the
      fractional part is generated).
 
@@ -2027,9 +1971,9 @@ File: mpfr.info,  Node: Integer Related Functions,  Next: Rounding Related Funct
      Set simultaneously IOP to the integral part of OP and FOP to the
      fractional part of OP, rounded in the direction RND with the
      corresponding precision of IOP and FOP (equivalent to
-     `mpfr_trunc(IOP, OP, RND)' and `mpfr_frac(FOP, OP, RND)'). The
-     variables IOP and FOP must be different. Return 0 iff both results
-     are exact (see `mpfr_sin_cos' for a more detailed description of
+     mpfr_trunc(IOP, OP, RND) and mpfr_frac(FOP, OP, RND)).  The
+     variables IOP and FOP must be different.  Return 0 iff both results
+     are exact (see mpfr_sin_cos for a more detailed description of
      the return value).
 
  -- Function: int mpfr_fmod (mpfr_t R, mpfr_t X, mpfr_t Y, mpfr_rnd_t
@@ -2040,23 +1984,23 @@ File: mpfr.info,  Node: Integer Related Functions,  Next: Rounding Related Funct
           mpfr_rnd_t RND)
      Set R to the value of X - NY, rounded according to the direction
      RND, where N is the integer quotient of X divided by Y, defined as
-     follows: N is rounded toward zero for `mpfr_fmod', and to the
-     nearest integer (ties rounded to even) for `mpfr_remainder' and
-     `mpfr_remquo'.
+     follows: N is rounded toward zero for mpfr_fmod, and to the
+     nearest integer (ties rounded to even) for mpfr_remainder and
+     mpfr_remquo.
 
      Special values are handled as described in Section F.9.7.1 of the
-     ISO C99 standard: If X is infinite or Y is zero, R is NaN.  If Y
-     is infinite and X is finite, R is X rounded to the precision of R.
-     If R is zero, it has the sign of X.  The return value is the
-     ternary value corresponding to R.
-
-     Additionally, `mpfr_remquo' stores the low significant bits from
-     the quotient N in *Q (more precisely the number of bits in a
-     `long' minus one), with the sign of X divided by Y (except if
-     those low bits are all zero, in which case zero is returned).
-     Note that X may be so large in magnitude relative to Y that an
-     exact representation of the quotient is not practical.  The
-     `mpfr_remainder' and `mpfr_remquo' functions are useful for
+     ISO C99 standard: If X is infinite or Y is zero, R is NaN. If Y is
+     infinite and X is finite, R is X rounded to the precision of R.  If
+     R is zero, it has the sign of X.  The return value is the ternary
+     value corresponding to R.
+
+     Additionally, mpfr_remquo stores the low significant bits from
+     the quotient N in *Q (more precisely the number of bits in a long
+     minus one), with the sign of X divided by Y (except if those low
+     bits are all zero, in which case zero is returned).  Note that X
+     may be so large in magnitude relative to Y that an exact
+     representation of the quotient is not practical.  The
+     mpfr_remainder and mpfr_remquo functions are useful for
      additive argument reduction.
 
  -- Function: int mpfr_integer_p (mpfr_t OP)
@@ -2069,8 +2013,8 @@ File: mpfr.info,  Node: Rounding Related Functions,  Next: Miscellaneous Functio
 ===============================
 
  -- Function: void mpfr_set_default_rounding_mode (mpfr_rnd_t RND)
-     Set the default rounding mode to RND.  The default rounding mode
-     is to nearest initially.
+     Set the default rounding mode to RND.  The default rounding mode is
+     to nearest initially.
 
  -- Function: mpfr_rnd_t mpfr_get_default_rounding_mode (void)
      Get the default rounding mode.
@@ -2078,15 +2022,15 @@ File: mpfr.info,  Node: Rounding Related Functions,  Next: Miscellaneous Functio
  -- Function: int mpfr_prec_round (mpfr_t X, mpfr_prec_t PREC,
           mpfr_rnd_t RND)
      Round X according to RND with precision PREC, which must be an
-     integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX' (otherwise the
+     integer between MPFR_PREC_MIN and MPFR_PREC_MAX (otherwise the
      behavior is undefined).  If PREC is greater or equal to the
      precision of X, then new space is allocated for the significand,
-     and it is filled with zeros.  Otherwise, the significand is
-     rounded to precision PREC with the given direction. In both cases,
-     the precision of X is changed to PREC.
+     and it is filled with zeros.  Otherwise, the significand is rounded
+     to precision PREC with the given direction.  In both cases, the
+     precision of X is changed to PREC.
 
-     Here is an example of how to use `mpfr_prec_round' to implement
-     Newton's algorithm to compute the inverse of A, assuming X is
+     Here is an example of how to use mpfr_prec_round to implement
+     Newtons algorithm to compute the inverse of A, assuming X is
      already an approximation to N bits:
             mpfr_set_prec (t, 2 * n);
             mpfr_set (t, a, MPFR_RNDN);         /* round a to 2n bits */
@@ -2102,28 +2046,29 @@ File: mpfr.info,  Node: Rounding Related Functions,  Next: Miscellaneous Functio
      Assuming B is an approximation of an unknown number X in the
      direction RND1 with error at most two to the power E(b)-ERR where
      E(b) is the exponent of B, return a non-zero value if one is able
-     to round correctly X to precision PREC with the direction RND2,
-     and 0 otherwise (including for NaN and Inf).  This function *does
-     not modify* its arguments.
-
-     If RND1 is `MPFR_RNDN', then the sign of the error is unknown, but
-     its absolute value is the same, so that the possible range is
-     twice as large as with a directed rounding for RND1.
-
-     Note: if one wants to also determine the correct ternary value
-     when rounding B to precision PREC with rounding mode RND, a useful
-     trick is the following: if (mpfr_can_round (b, err, MPFR_RNDN, MPFR_RNDZ, prec + (rnd == MPFR_RNDN)))
+     to round correctly X to precision PREC with the direction RND2, and
+     0 otherwise (including for NaN and Inf).  This function *does not
+     modify* its arguments.
+
+     If RND1 is MPFR_RNDN, then the sign of the error is unknown, but
+     its absolute value is the same, so that the possible range is twice
+     as large as with a directed rounding for RND1.
+
+     Note: if one wants to also determine the correct ternary value when
+     rounding B to precision PREC with rounding mode RND, a useful trick
+     is the following:
+     if (mpfr_can_round (b, err, MPFR_RNDN, MPFR_RNDZ, prec + (rnd == MPFR_RNDN)))
         ...
-      Indeed, if RND is `MPFR_RNDN', this will check if one can round
-     to PREC+1 bits with a directed rounding: if so, one can surely
-     round to nearest to PREC bits, and in addition one can determine
-     the correct ternary value, which would not be the case when B is
-     near from a value exactly representable on PREC bits.
+     Indeed, if RND is MPFR_RNDN, this will check if one can round to
+     PREC+1 bits with a directed rounding: if so, one can surely round
+     to nearest to PREC bits, and in addition one can determine the
+     correct ternary value, which would not be the case when B is near
+     from a value exactly representable on PREC bits.
 
  -- Function: mpfr_prec_t mpfr_min_prec (mpfr_t X)
-     Return the minimal number of bits required to store the
-     significand of X, and 0 for special values, including 0. (Warning:
-     the returned value can be less than `MPFR_PREC_MIN'.)
+     Return the minimal number of bits required to store the significand
+     of X, and 0 for special values, including 0.  (Warning: the
+     returned value can be less than MPFR_PREC_MIN.)
 
      The function name is subject to change.
 
@@ -2140,41 +2085,41 @@ File: mpfr.info,  Node: Miscellaneous Functions,  Next: Exception Related Functi
 
  -- Function: void mpfr_nexttoward (mpfr_t X, mpfr_t Y)
      If X or Y is NaN, set X to NaN. If X and Y are equal, X is
-     unchanged. Otherwise, if X is different from Y, replace X by the
-     next floating-point number (with the precision of X and the
-     current exponent range) in the direction of Y (the infinite values
-     are seen as the smallest and largest floating-point numbers). If
-     the result is zero, it keeps the same sign. No underflow or
-     overflow is generated.
+     unchanged.  Otherwise, if X is different from Y, replace X by the
+     next floating-point number (with the precision of X and the current
+     exponent range) in the direction of Y (the infinite values are seen
+     as the smallest and largest floating-point numbers).  If the result
+     is zero, it keeps the same sign.  No underflow or overflow is
+     generated.
 
  -- Function: void mpfr_nextabove (mpfr_t X)
  -- Function: void mpfr_nextbelow (mpfr_t X)
-     Equivalent to `mpfr_nexttoward' where Y is plus infinity (resp.
+     Equivalent to mpfr_nexttoward where Y is plus infinity (resp.
      minus infinity).
 
  -- Function: int mpfr_min (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
  -- Function: int mpfr_max (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
-     Set ROP to the minimum (resp. maximum) of OP1 and OP2. If OP1 and
+     Set ROP to the minimum (resp. maximum) of OP1 and OP2.  If OP1 and
      OP2 are both NaN, then ROP is set to NaN. If OP1 or OP2 is NaN,
-     then ROP is set to the numeric value. If OP1 and OP2 are zeros of
-     different signs, then ROP is set to -0 (resp. +0).
+     then ROP is set to the numeric value.  If OP1 and OP2 are zeros of
+     different signs, then ROP is set to 0 (resp. +0).
 
  -- Function: int mpfr_urandomb (mpfr_t ROP, gmp_randstate_t STATE)
      Generate a uniformly distributed random float in the interval 0 <=
-     ROP < 1. More precisely, the number can be seen as a float with a
+     ROP < 1.  More precisely, the number can be seen as a float with a
      random non-normalized significand and exponent 0, which is then
      normalized (thus if E denotes the exponent after normalization,
      then the least -E significant bits of the significand are always
      0).
 
-     Return 0, unless the exponent is not in the current exponent
-     range, in which case ROP is set to NaN and a non-zero value is
-     returned (this should never happen in practice, except in very
-     specific cases). The second argument is a `gmp_randstate_t'
-     structure which should be created using the GMP `gmp_randinit'
-     function (see the GMP manual).
+     Return 0, unless the exponent is not in the current exponent range,
+     in which case ROP is set to NaN and a non-zero value is returned
+     (this should never happen in practice, except in very specific
+     cases).  The second argument is a gmp_randstate_t structure which
+     should be created using the GMP gmp_randinit function (see the
+     GMP manual).
 
  -- Function: int mpfr_urandom (mpfr_t ROP, gmp_randstate_t STATE,
           mpfr_rnd_t RND)
@@ -2183,13 +2128,13 @@ File: mpfr.info,  Node: Miscellaneous Functions,  Next: Exception Related Functi
      according to the continuous uniform distribution on the interval
      [0, 1] and then rounded in the direction RND.
 
-     The second argument is a `gmp_randstate_t' structure which should
-     be created using the GMP `gmp_randinit' function (see the GMP
+     The second argument is a gmp_randstate_t structure which should
+     be created using the GMP gmp_randinit function (see the GMP
      manual).
 
  -- Function: mpfr_exp_t mpfr_get_exp (mpfr_t X)
      Return the exponent of X, assuming that X is a non-zero ordinary
-     number and the significand is considered in [1/2,1). The behavior
+     number and the significand is considered in [1/2,1).  The behavior
      for NaN, infinity or zero is undefined.
 
  -- Function: int mpfr_set_exp (mpfr_t X, mpfr_exp_t E)
@@ -2200,10 +2145,10 @@ File: mpfr.info,  Node: Miscellaneous Functions,  Next: Exception Related Functi
 
  -- Function: int mpfr_signbit (mpfr_t OP)
      Return a non-zero value iff OP has its sign bit set (i.e., if it is
-     negative, -0, or a NaN whose representation has its sign bit set).
+     negative, 0, or a NaN whose representation has its sign bit set).
 
- -- Function: int mpfr_setsign (mpfr_t ROP, mpfr_t OP, int S,
-          mpfr_rnd_t RND)
+ -- Function: int mpfr_setsign (mpfr_t ROP, mpfr_t OP, int S, mpfr_rnd_t
+          RND)
      Set the value of ROP from OP, rounded toward the given direction
      RND, then set (resp. clear) its sign bit if S is non-zero (resp.
      zero), even when OP is a NaN.
@@ -2212,8 +2157,8 @@ File: mpfr.info,  Node: Miscellaneous Functions,  Next: Exception Related Functi
           mpfr_rnd_t RND)
      Set the value of ROP from OP1, rounded toward the given direction
      RND, then set its sign bit to that of OP2 (even when OP1 or OP2 is
-     a NaN). This function is equivalent to `mpfr_setsign (ROP, OP1,
-     mpfr_signbit (OP2), RND)'.
+     a NaN). This function is equivalent to mpfr_setsign (ROP, OP1,
+     mpfr_signbit (OP2), RND).
 
  -- Function: const char * mpfr_get_version (void)
      Return the MPFR version, as a null-terminated string.
@@ -2223,32 +2168,32 @@ File: mpfr.info,  Node: Miscellaneous Functions,  Next: Exception Related Functi
  -- Macro: MPFR_VERSION_MINOR
  -- Macro: MPFR_VERSION_PATCHLEVEL
  -- Macro: MPFR_VERSION_STRING
-     `MPFR_VERSION' is the version of MPFR as a preprocessing constant.
-     `MPFR_VERSION_MAJOR', `MPFR_VERSION_MINOR' and
-     `MPFR_VERSION_PATCHLEVEL' are respectively the major, minor and
+     MPFR_VERSION is the version of MPFR as a preprocessing constant.
+     MPFR_VERSION_MAJOR, MPFR_VERSION_MINOR and
+     MPFR_VERSION_PATCHLEVEL are respectively the major, minor and
      patch level of MPFR version, as preprocessing constants.
-     `MPFR_VERSION_STRING' is the version (with an optional suffix, used
+     MPFR_VERSION_STRING is the version (with an optional suffix, used
      in development and pre-release versions) as a string constant,
-     which can be compared to the result of `mpfr_get_version' to check
+     which can be compared to the result of mpfr_get_version to check
      at run time the header file and library used match:
           if (strcmp (mpfr_get_version (), MPFR_VERSION_STRING))
             fprintf (stderr, "Warning: header and library do not match\n");
      Note: Obtaining different strings is not necessarily an error, as
      in general, a program compiled with some old MPFR version can be
-     dynamically linked with a newer MPFR library version (if allowed
-     by the library versioning system).
+     dynamically linked with a newer MPFR library version (if allowed by
+     the library versioning system).
 
  -- Macro: long MPFR_VERSION_NUM (MAJOR, MINOR, PATCHLEVEL)
-     Create an integer in the same format as used by `MPFR_VERSION'
-     from the given MAJOR, MINOR and PATCHLEVEL.  Here is an example of
-     how to check the MPFR version at compile time:
+     Create an integer in the same format as used by MPFR_VERSION from
+     the given MAJOR, MINOR and PATCHLEVEL.  Here is an example of how
+     to check the MPFR version at compile time:
           #if (!defined(MPFR_VERSION) || (MPFR_VERSION<MPFR_VERSION_NUM(3,0,0)))
           # error "Wrong MPFR version."
           #endif
 
  -- Function: const char * mpfr_get_patches (void)
      Return a null-terminated string containing the ids of the patches
-     applied to the MPFR library (contents of the `PATCHES' file),
+     applied to the MPFR library (contents of the PATCHES file),
      separated by spaces.  Note: If the program has been compiled with
      an older MPFR version and is dynamically linked with a new MPFR
      library version, the identifiers of the patches applied to the old
@@ -2258,12 +2203,12 @@ File: mpfr.info,  Node: Miscellaneous Functions,  Next: Exception Related Functi
  -- Function: int mpfr_buildopt_tls_p (void)
      Return a non-zero value if MPFR was compiled as thread safe using
      compiler-level Thread Local Storage (that is MPFR was built with
-     the `--enable-thread-safe' configure option, see `INSTALL' file),
+     the --enable-thread-safe configure option, see INSTALL file),
      return zero otherwise.
 
  -- Function: int mpfr_buildopt_decimal_p (void)
      Return a non-zero value if MPFR was compiled with decimal float
-     support (that is MPFR was built with the `--enable-decimal-float'
+     support (that is MPFR was built with the --enable-decimal-float
      configure option), return zero otherwise.
 
 
@@ -2275,7 +2220,7 @@ File: mpfr.info,  Node: Exception Related Functions,  Next: Compatibility with M
  -- Function: mpfr_exp_t mpfr_get_emin (void)
  -- Function: mpfr_exp_t mpfr_get_emax (void)
      Return the (current) smallest and largest exponents allowed for a
-     floating-point variable. The smallest positive value of a
+     floating-point variable.  The smallest positive value of a
      floating-point variable is one half times 2 raised to the smallest
      exponent and the largest value has the form (1 - epsilon) times 2
      raised to the largest exponent, where epsilon depends on the
@@ -2283,46 +2228,46 @@ File: mpfr.info,  Node: Exception Related Functions,  Next: Compatibility with M
 
  -- Function: int mpfr_set_emin (mpfr_exp_t EXP)
  -- Function: int mpfr_set_emax (mpfr_exp_t EXP)
-     Set the smallest and largest exponents allowed for a
-     floating-point variable.  Return a non-zero value when EXP is not
-     in the range accepted by the implementation (in that case the
-     smallest or largest exponent is not changed), and zero otherwise.
-     If the user changes the exponent range, it is her/his
-     responsibility to check that all current floating-point variables
-     are in the new allowed range (for example using
-     `mpfr_check_range'), otherwise the subsequent behavior will be
-     undefined, in the sense of the ISO C standard.
+     Set the smallest and largest exponents allowed for a floating-point
+     variable.  Return a non-zero value when EXP is not in the range
+     accepted by the implementation (in that case the smallest or
+     largest exponent is not changed), and zero otherwise.  If the user
+     changes the exponent range, it is her/his responsibility to check
+     that all current floating-point variables are in the new allowed
+     range (for example using mpfr_check_range), otherwise the
+     subsequent behavior will be undefined, in the sense of the ISO C
+     standard.
 
  -- Function: mpfr_exp_t mpfr_get_emin_min (void)
  -- Function: mpfr_exp_t mpfr_get_emin_max (void)
  -- Function: mpfr_exp_t mpfr_get_emax_min (void)
  -- Function: mpfr_exp_t mpfr_get_emax_max (void)
      Return the minimum and maximum of the exponents allowed for
-     `mpfr_set_emin' and `mpfr_set_emax' respectively.  These values
-     are implementation dependent, thus a program using
-     `mpfr_set_emax(mpfr_get_emax_max())' or
-     `mpfr_set_emin(mpfr_get_emin_min())' may not be portable.
+     mpfr_set_emin and mpfr_set_emax respectively.  These values are
+     implementation dependent, thus a program using
+     mpfr_set_emax(mpfr_get_emax_max()) or
+     mpfr_set_emin(mpfr_get_emin_min()) may not be portable.
 
  -- Function: int mpfr_check_range (mpfr_t X, int T, mpfr_rnd_t RND)
      This function assumes that X is the correctly-rounded value of some
-     real value Y in the direction RND and some extended exponent
-     range, and that T is the corresponding ternary value.  For
-     example, one performed `t = mpfr_log (x, u, rnd)', and Y is the
-     exact logarithm of U.  Thus T is negative if X is smaller than Y,
-     positive if X is larger than Y, and zero if X equals Y.  This
-     function modifies X if needed to be in the current range of
-     acceptable values: It generates an underflow or an overflow if the
-     exponent of X is outside the current allowed range; the value of T
-     may be used to avoid a double rounding. This function returns zero
-     if the new value of X equals the exact one Y, a positive value if
-     that new value is larger than Y, and a negative value if it is
-     smaller than Y.  Note that unlike most functions, the new result X
-     is compared to the (unknown) exact one Y, not the input value X,
-     i.e., the ternary value is propagated.
+     real value Y in the direction RND and some extended exponent range,
+     and that T is the corresponding ternary value.  For example, one
+     performed t = mpfr_log (x, u, rnd), and Y is the exact logarithm
+     of U.  Thus T is negative if X is smaller than Y, positive if X is
+     larger than Y, and zero if X equals Y.  This function modifies X if
+     needed to be in the current range of acceptable values: It
+     generates an underflow or an overflow if the exponent of X is
+     outside the current allowed range; the value of T may be used to
+     avoid a double rounding.  This function returns zero if the new
+     value of X equals the exact one Y, a positive value if that new
+     value is larger than Y, and a negative value if it is smaller than
+     Y.  Note that unlike most functions, the new result X is compared
+     to the (unknown) exact one Y, not the input value X, i.e., the
+     ternary value is propagated.
 
      Note: If X is an infinity and T is different from zero (i.e., if
      the rounded result is an inexact infinity), then the overflow flag
-     is set. This is useful because `mpfr_check_range' is typically
+     is set.  This is useful because mpfr_check_range is typically
      called (at least in MPFR functions) after restoring the flags that
      could have been set due to internal computations.
 
@@ -2330,22 +2275,22 @@ File: mpfr.info,  Node: Exception Related Functions,  Next: Compatibility with M
      This function rounds X emulating subnormal number arithmetic: if X
      is outside the subnormal exponent range, it just propagates the
      ternary value T; otherwise, it rounds X to precision
-     `EXP(x)-emin+1' according to rounding mode RND and previous
-     ternary value T, avoiding double rounding problems.  More
-     precisely in the subnormal domain, denoting by E the value of
-     `emin', X is rounded in fixed-point arithmetic to an integer
-     multiple of two to the power E-1; as a consequence, 1.5 multiplied
-     by two to the power E-1 when T is zero is rounded to two to the
-     power E with rounding to nearest.
-
-     `PREC(x)' is not modified by this function.  RND and T must be the
+     EXP(x)-emin+1 according to rounding mode RND and previous ternary
+     value T, avoiding double rounding problems.  More precisely in the
+     subnormal domain, denoting by E the value of emin, X is rounded
+     in fixed-point arithmetic to an integer multiple of two to the
+     power E1; as a consequence, 1.5 multiplied by two to the power E1
+     when T is zero is rounded to two to the power E with rounding to
+     nearest.
+
+     PREC(x) is not modified by this function.  RND and T must be the
      rounding mode and the returned ternary value used when computing X
-     (as in `mpfr_check_range').  The subnormal exponent range is from
-     `emin' to `emin+PREC(x)-1'.  If the result cannot be represented
-     in the current exponent range (due to a too small `emax'), the
-     behavior is undefined.  Note that unlike most functions, the
-     result is compared to the exact one, not the input value X, i.e.,
-     the ternary value is propagated.
+     (as in mpfr_check_range).  The subnormal exponent range is from
+     emin to emin+PREC(x)-1.  If the result cannot be represented in
+     the current exponent range (due to a too small emax), the
+     behavior is undefined.  Note that unlike most functions, the result
+     is compared to the exact one, not the input value X, i.e., the
+     ternary value is propagated.
 
      As usual, if the returned ternary value is non zero, the inexact
      flag is set.  Moreover, if a second rounding occurred (because the
@@ -2408,55 +2353,54 @@ File: mpfr.info,  Node: Compatibility with MPF,  Next: Custom Interface,  Prev:
 5.14 Compatibility With MPF
 ===========================
 
-A header file `mpf2mpfr.h' is included in the distribution of MPFR for
-compatibility with the GNU MP class MPF.  By inserting the following
-two lines after the `#include <gmp.h>' line,
+A header file mpf2mpfr.h is included in the distribution of MPFR for
+compatibility with the GNU MP class MPF. By inserting the following two
+lines after the #include <gmp.h> line,
 #include <mpfr.h>
 #include <mpf2mpfr.h>
- any program written for MPF can be compiled directly with MPFR without
-any changes (except the `gmp_printf' functions will not work for
-arguments of type `mpfr_t').  All operations are then performed with
-the default MPFR rounding mode, which can be reset with
-`mpfr_set_default_rounding_mode'.
+any program written for MPF can be compiled directly with MPFR without
+any changes (except the gmp_printf functions will not work for
+arguments of type mpfr_t).  All operations are then performed with the
+default MPFR rounding mode, which can be reset with
+mpfr_set_default_rounding_mode.
 
-   Warning: the `mpf_init' and `mpf_init2' functions initialize to
-zero, whereas the corresponding MPFR functions initialize to NaN: this
-is useful to detect uninitialized values, but is slightly incompatible
-with MPF.
+   Warning: the mpf_init and mpf_init2 functions initialize to zero,
+whereas the corresponding MPFR functions initialize to NaN: this is
+useful to detect uninitialized values, but is slightly incompatible with
+MPF.
 
  -- Function: void mpfr_set_prec_raw (mpfr_t X, mpfr_prec_t PREC)
      Reset the precision of X to be *exactly* PREC bits.  The only
-     difference with `mpfr_set_prec' is that PREC is assumed to be
-     small enough so that the significand fits into the current
-     allocated memory space for X. Otherwise the behavior is undefined.
+     difference with mpfr_set_prec is that PREC is assumed to be small
+     enough so that the significand fits into the current allocated
+     memory space for X.  Otherwise the behavior is undefined.
 
  -- Function: int mpfr_eq (mpfr_t OP1, mpfr_t OP2, unsigned long int
           OP3)
      Return non-zero if OP1 and OP2 are both non-zero ordinary numbers
      with the same exponent and the same first OP3 bits, both zero, or
-     both infinities of the same sign. Return zero otherwise.  This
+     both infinities of the same sign.  Return zero otherwise.  This
      function is defined for compatibility with MPF, we do not recommend
      to use it otherwise.  Do not use it either if you want to know
-     whether two numbers are close to each other; for instance,
-     1.011111 and 1.100000 are regarded as different for any value of
-     OP3 larger than 1.
+     whether two numbers are close to each other; for instance, 1.011111
+     and 1.100000 are regarded as different for any value of OP3 larger
+     than 1.
 
  -- Function: void mpfr_reldiff (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
           mpfr_rnd_t RND)
      Compute the relative difference between OP1 and OP2 and store the
      result in ROP.  This function does not guarantee the correct
      rounding on the relative difference; it just computes
-     |OP1-OP2|/OP1, using the precision of ROP and the rounding mode
-     RND for all operations.
+     |OP1-OP2|/OP1, using the precision of ROP and the rounding mode RND
+     for all operations.
 
  -- Function: int mpfr_mul_2exp (mpfr_t ROP, mpfr_t OP1, unsigned long
           int OP2, mpfr_rnd_t RND)
  -- Function: int mpfr_div_2exp (mpfr_t ROP, mpfr_t OP1, unsigned long
           int OP2, mpfr_rnd_t RND)
-     These functions are identical to `mpfr_mul_2ui' and `mpfr_div_2ui'
-     respectively.  These functions are only kept for compatibility
-     with MPF, one should prefer `mpfr_mul_2ui' and `mpfr_div_2ui'
-     otherwise.
+     These functions are identical to mpfr_mul_2ui and mpfr_div_2ui
+     respectively.  These functions are only kept for compatibility with
+     MPF, one should prefer mpfr_mul_2ui and mpfr_div_2ui otherwise.
 
 
 File: mpfr.info,  Node: Custom Interface,  Next: Internals,  Prev: Compatibility with MPF,  Up: MPFR Interface
@@ -2465,31 +2409,30 @@ File: mpfr.info,  Node: Custom Interface,  Next: Internals,  Prev: Compatibility
 =====================
 
 Some applications use a stack to handle the memory and their objects.
-However, the MPFR memory design is not well suited for such a thing. So
+However, the MPFR memory design is not well suited for such a thing.  So
 that such applications are able to use MPFR, an auxiliary memory
 interface has been created: the Custom Interface.
 
    The following interface allows one to use MPFR in two ways:
-   * Either directly store a floating-point number as a `mpfr_t' on the
+    Either directly store a floating-point number as a mpfr_t on the
      stack.
-
-   * Either store its own representation on the stack and construct a
-     new temporary `mpfr_t' each time it is needed.
+    Either store its own representation on the stack and construct a
+     new temporary mpfr_t each time it is needed.
    Nothing has to be done to destroy the floating-point numbers except
 garbaging the used memory: all the memory management (allocating,
 destroying, garbaging) is left to the application.
 
    Each function in this interface is also implemented as a macro for
-efficiency reasons: for example `mpfr_custom_init (s, p)' uses the
-macro, while `(mpfr_custom_init) (s, p)' uses the function.
+efficiency reasons: for example mpfr_custom_init (s, p) uses the
+macro, while (mpfr_custom_init) (s, p) uses the function.
 
    Note 1: MPFR functions may still initialize temporary floating-point
-numbers using `mpfr_init' and similar functions. See Custom Allocation
+numbers using mpfr_init and similar functions.  See Custom Allocation
 (GNU MP).
 
-   Note 2: MPFR functions may use the cached functions (`mpfr_const_pi'
-for example), even if they are not explicitly called. You have to call
-`mpfr_free_cache' each time you garbage the memory iff `mpfr_init',
+   Note 2: MPFR functions may use the cached functions (mpfr_const_pi
+for example), even if they are not explicitly called.  You have to call
+mpfr_free_cache each time you garbage the memory iff mpfr_init,
 through GMP Custom Allocation, allocates its memory on the application
 stack.
 
@@ -2500,54 +2443,50 @@ stack.
  -- Function: void mpfr_custom_init (void *SIGNIFICAND, mpfr_prec_t
           PREC)
      Initialize a significand of precision PREC, where SIGNIFICAND must
-     be an area of `mpfr_custom_get_size (prec)' bytes at least and be
-     suitably aligned for an array of `mp_limb_t' (GMP type, *note
+     be an area of mpfr_custom_get_size (prec) bytes at least and be
+     suitably aligned for an array of mp_limb_t (GMP type, *note
      Internals::).
 
  -- Function: void mpfr_custom_init_set (mpfr_t X, int KIND, mpfr_exp_t
           EXP, mpfr_prec_t PREC, void *SIGNIFICAND)
-     Perform a dummy initialization of a `mpfr_t' and set it to:
-        * if `ABS(kind) == MPFR_NAN_KIND', X is set to NaN;
-
-        * if `ABS(kind) == MPFR_INF_KIND', X is set to the infinity of
-          sign `sign(kind)';
-
-        * if `ABS(kind) == MPFR_ZERO_KIND', X is set to the zero of
-          sign `sign(kind)';
-
-        * if `ABS(kind) == MPFR_REGULAR_KIND', X is set to a regular
-          number: `x = sign(kind)*significand*2^exp'.
+     Perform a dummy initialization of a mpfr_t and set it to:
+         if ABS(kind) == MPFR_NAN_KIND, X is set to NaN;
+         if ABS(kind) == MPFR_INF_KIND, X is set to the infinity of
+          sign sign(kind);
+         if ABS(kind) == MPFR_ZERO_KIND, X is set to the zero of sign
+          sign(kind);
+         if ABS(kind) == MPFR_REGULAR_KIND, X is set to a regular
+          number: x = sign(kind)*significand*2^exp.
      In all cases, it uses SIGNIFICAND directly for further computing
-     involving X. It will not allocate anything.  A floating-point
+     involving X.  It will not allocate anything.  A floating-point
      number initialized with this function cannot be resized using
-     `mpfr_set_prec' or `mpfr_prec_round', or cleared using
-     `mpfr_clear'!  The SIGNIFICAND must have been initialized with
-     `mpfr_custom_init' using the same precision PREC.
+     mpfr_set_prec or mpfr_prec_round, or cleared using
+     mpfr_clear!  The SIGNIFICAND must have been initialized with
+     mpfr_custom_init using the same precision PREC.
 
  -- Function: int mpfr_custom_get_kind (mpfr_t X)
-     Return the current kind of a `mpfr_t' as created by
-     `mpfr_custom_init_set'.  The behavior of this function for any
-     `mpfr_t' not initialized with `mpfr_custom_init_set' is undefined.
+     Return the current kind of a mpfr_t as created by
+     mpfr_custom_init_set.  The behavior of this function for any
+     mpfr_t not initialized with mpfr_custom_init_set is undefined.
 
  -- Function: void * mpfr_custom_get_significand (mpfr_t X)
-     Return a pointer to the significand used by a `mpfr_t' initialized
-     with `mpfr_custom_init_set'.  The behavior of this function for
-     any `mpfr_t' not initialized with `mpfr_custom_init_set' is
-     undefined.
+     Return a pointer to the significand used by a mpfr_t initialized
+     with mpfr_custom_init_set.  The behavior of this function for any
+     mpfr_t not initialized with mpfr_custom_init_set is undefined.
 
  -- Function: mpfr_exp_t mpfr_custom_get_exp (mpfr_t X)
      Return the exponent of X, assuming that X is a non-zero ordinary
-     number. The return value for NaN, Infinity or zero is unspecified
+     number.  The return value for NaN, Infinity or zero is unspecified
      but does not produce any trap.  The behavior of this function for
-     any `mpfr_t' not initialized with `mpfr_custom_init_set' is
+     any mpfr_t not initialized with mpfr_custom_init_set is
      undefined.
 
  -- Function: void mpfr_custom_move (mpfr_t X, void *NEW_POSITION)
      Inform MPFR that the significand of X has moved due to a garbage
-     collect and update its new position to `new_position'.  However
-     the application has to move the significand and the `mpfr_t'
-     itself.  The behavior of this function for any `mpfr_t' not
-     initialized with `mpfr_custom_init_set' is undefined.
+     collect and update its new position to new_position.  However the
+     application has to move the significand and the mpfr_t itself.
+     The behavior of this function for any mpfr_t not initialized with
+     mpfr_custom_init_set is undefined.
 
 
 File: mpfr.info,  Node: Internals,  Prev: Custom Interface,  Up: MPFR Interface
@@ -2555,35 +2494,34 @@ File: mpfr.info,  Node: Internals,  Prev: Custom Interface,  Up: MPFR Interface
 5.16 Internals
 ==============
 
-A "limb" means the part of a multi-precision number that fits in a
-single word. Usually a limb contains 32 or 64 bits.  The C data type
-for a limb is `mp_limb_t'.
+A limb means the part of a multi-precision number that fits in a
+single word.  Usually a limb contains 32 or 64 bits.  The C data type
+for a limb is mp_limb_t.
 
-   The `mpfr_t' type is internally defined as a one-element array of a
-structure, and `mpfr_ptr' is the C data type representing a pointer to
-this structure.  The `mpfr_t' type consists of four fields:
+   The mpfr_t type is internally defined as a one-element array of a
+structure, and mpfr_ptr is the C data type representing a pointer to
+this structure.  The mpfr_t type consists of four fields:
 
-   * The `_mpfr_prec' field is used to store the precision of the
-     variable (in bits); this is not less than `MPFR_PREC_MIN'.
+    The _mpfr_prec field is used to store the precision of the
+     variable (in bits); this is not less than MPFR_PREC_MIN.
 
-   * The `_mpfr_sign' field is used to store the sign of the variable.
+    The _mpfr_sign field is used to store the sign of the variable.
 
-   * The `_mpfr_exp' field stores the exponent.  An exponent of 0 means
+    The _mpfr_exp field stores the exponent.  An exponent of 0 means
      a radix point just above the most significant limb.  Non-zero
      values n are a multiplier 2^n relative to that point.  A NaN, an
      infinity and a zero are indicated by special values of the exponent
      field.
 
-   * Finally, the `_mpfr_d' field is a pointer to the limbs, least
+    Finally, the _mpfr_d field is a pointer to the limbs, least
      significant limbs stored first.  The number of limbs in use is
-     controlled by `_mpfr_prec', namely
-     ceil(`_mpfr_prec'/`mp_bits_per_limb').  Non-singular (i.e.,
+     controlled by _mpfr_prec, namely
+     ceil(_mpfr_prec/mp_bits_per_limb).  Non-singular (i.e.,
      different from NaN, Infinity or zero) values always have the most
      significant bit of the most significant limb set to 1.  When the
      precision does not correspond to a whole number of limbs, the
      excess bits at the low end of the data are zeros.
 
-
 
 File: mpfr.info,  Node: API Compatibility,  Next: Contributors,  Prev: MPFR Interface,  Up: Top
 
@@ -2596,30 +2534,28 @@ compiled and run with older MPFR versions.  The minimum MPFR version
 that is considered here is 2.2.0 (released on 20 September 2005).
 
    API changes can only occur between major or minor versions.  Thus the
-patchlevel (the third number in the MPFR version) will be ignored in
-the following.  If a program does not use MPFR internals, changes in
-the behavior between two versions differing only by the patchlevel
-should only result from what was regarded as a bug or unspecified
-behavior.
+patchlevel (the third number in the MPFR version) will be ignored in the
+following.  If a program does not use MPFR internals, changes in the
+behavior between two versions differing only by the patchlevel should
+only result from what was regarded as a bug or unspecified behavior.
 
    As a general rule, a program written for some MPFR version should
 work with later versions, possibly except at a new major version, where
 some features (described as obsolete for some time) can be removed.  In
-such a case, a failure should occur during compilation or linking.  If
-a result becomes incorrect because of such a change, please look at the
+such a case, a failure should occur during compilation or linking.  If a
+result becomes incorrect because of such a change, please look at the
 various changes below (they are minimal, and most software should be
-unaffected), at the FAQ and at the MPFR web page for your version (a
-bug could have been introduced and be already fixed); and if the
-problem is not mentioned, please send us a bug report (*note Reporting
-Bugs::).
+unaffected), at the FAQ and at the MPFR web page for your version (a bug
+could have been introduced and be already fixed); and if the problem is
+not mentioned, please send us a bug report (*note Reporting Bugs::).
 
    However, a program written for the current MPFR version (as
 documented by this manual) may not necessarily work with previous
-versions of MPFR.  This section should help developers to write
-portable code.
+versions of MPFR. This section should help developers to write portable
+code.
 
-   Note: Information given here may be incomplete.  API changes are
-also described in the NEWS file (for each version, instead of being
+   Note: Information given here may be incomplete.  API changes are also
+described in the NEWS file (for each version, instead of being
 classified like here), together with other changes.
 
 * Menu:
@@ -2636,23 +2572,23 @@ File: mpfr.info,  Node: Type and Macro Changes,  Next: Added Functions,  Prev: A
 6.1 Type and Macro Changes
 ==========================
 
-The official type for exponent values changed from `mp_exp_t' to
-`mpfr_exp_t' in MPFR 3.0.  The type `mp_exp_t' will remain available as
-it comes from GMP (with a different meaning).  These types are
-currently the same (`mpfr_exp_t' is defined as `mp_exp_t' with
-`typedef'), so that programs can still use `mp_exp_t'; but this may
-change in the future.  Alternatively, using the following code after
-including `mpfr.h' will work with official MPFR versions, as
-`mpfr_exp_t' was never defined in MPFR 2.x:
+The official type for exponent values changed from mp_exp_t to
+mpfr_exp_t in MPFR 3.0.  The type mp_exp_t will remain available as
+it comes from GMP (with a different meaning).  These types are currently
+the same (mpfr_exp_t is defined as mp_exp_t with typedef), so that
+programs can still use mp_exp_t; but this may change in the future.
+Alternatively, using the following code after including mpfr.h will
+work with official MPFR versions, as mpfr_exp_t was never defined in
+MPFR 2.x:
      #if MPFR_VERSION_MAJOR < 3
      typedef mp_exp_t mpfr_exp_t;
      #endif
 
    The official types for precision values and for rounding modes
-respectively changed from `mp_prec_t' and `mp_rnd_t' to `mpfr_prec_t'
-and `mpfr_rnd_t' in MPFR 3.0.  This change was actually done a long
-time ago in MPFR, at least since MPFR 2.2.0, with the following code in
-`mpfr.h':
+respectively changed from mp_prec_t and mp_rnd_t to mpfr_prec_t
+and mpfr_rnd_t in MPFR 3.0.  This change was actually done a long time
+ago in MPFR, at least since MPFR 2.2.0, with the following code in
+mpfr.h:
      #ifndef mp_rnd_t
      # define mp_rnd_t  mpfr_rnd_t
      #endif
@@ -2660,33 +2596,33 @@ time ago in MPFR, at least since MPFR 2.2.0, with the following code in
      # define mp_prec_t mpfr_prec_t
      #endif
    This means that it is safe to use the new official types
-`mpfr_prec_t' and `mpfr_rnd_t' in your programs.  The types `mp_prec_t'
-and `mp_rnd_t' (defined in MPFR only) may be removed in the future, as
-the prefix `mp_' is reserved by GMP.
-
-   The precision type `mpfr_prec_t' (`mp_prec_t') was unsigned before
-MPFR 3.0; it is now signed.  `MPFR_PREC_MAX' has not changed, though.
-Indeed the MPFR code requires that `MPFR_PREC_MAX' be representable in
-the exponent type, which may have the same size as `mpfr_prec_t' but
-has always been signed.  The consequence is that valid code that does
-not assume anything about the signedness of `mpfr_prec_t' should work
-with past and new MPFR versions.  This change was useful as the use of
+mpfr_prec_t and mpfr_rnd_t in your programs.  The types mp_prec_t
+and mp_rnd_t (defined in MPFR only) may be removed in the future, as
+the prefix mp_ is reserved by GMP.
+
+   The precision type mpfr_prec_t (mp_prec_t) was unsigned before
+MPFR 3.0; it is now signed.  MPFR_PREC_MAX has not changed, though.
+Indeed the MPFR code requires that MPFR_PREC_MAX be representable in
+the exponent type, which may have the same size as mpfr_prec_t but has
+always been signed.  The consequence is that valid code that does not
+assume anything about the signedness of mpfr_prec_t should work with
+past and new MPFR versions.  This change was useful as the use of
 unsigned types tends to convert signed values to unsigned ones in
 expressions due to the usual arithmetic conversions, which can yield
 incorrect results if a negative value is converted in such a way.
-Warning!  A program assuming (intentionally or not) that `mpfr_prec_t'
+Warning!  A program assuming (intentionally or not) that mpfr_prec_t
 is signed may be affected by this problem when it is built and run
 against MPFR 2.x.
 
-   The rounding modes `GMP_RNDx' were renamed to `MPFR_RNDx' in MPFR
-3.0. However the old names `GMP_RNDx' have been kept for compatibility
+   The rounding modes GMP_RNDx were renamed to MPFR_RNDx in MPFR
+3.0.  However the old names GMP_RNDx have been kept for compatibility
 (this might change in future versions), using:
      #define GMP_RNDN MPFR_RNDN
      #define GMP_RNDZ MPFR_RNDZ
      #define GMP_RNDU MPFR_RNDU
      #define GMP_RNDD MPFR_RNDD
-   The rounding mode "round away from zero" (`MPFR_RNDA') was added in
-MPFR 3.0 (however no rounding mode `GMP_RNDA' exists).
+   The rounding mode round away from zero (MPFR_RNDA) was added in
+MPFR 3.0 (however no rounding mode GMP_RNDA exists).
 
 
 File: mpfr.info,  Node: Added Functions,  Next: Changed Functions,  Prev: Type and Macro Changes,  Up: API Compatibility
@@ -2697,91 +2633,90 @@ File: mpfr.info,  Node: Added Functions,  Next: Changed Functions,  Prev: Type a
 We give here in alphabetical order the functions that were added after
 MPFR 2.2, and in which MPFR version.
 
-   * `mpfr_add_d' in MPFR 2.4.
+    mpfr_add_d in MPFR 2.4.
 
-   * `mpfr_ai' in MPFR 3.0 (incomplete, experimental).
+    mpfr_ai in MPFR 3.0 (incomplete, experimental).
 
-   * `mpfr_asprintf' in MPFR 2.4.
+    mpfr_asprintf in MPFR 2.4.
 
-   * `mpfr_buildopt_decimal_p' and `mpfr_buildopt_tls_p' in MPFR 3.0.
+    mpfr_buildopt_decimal_p and mpfr_buildopt_tls_p in MPFR 3.0.
 
-   * `mpfr_copysign' in MPFR 2.3.  Note: MPFR 2.2 had a `mpfr_copysign'
+    mpfr_copysign in MPFR 2.3.  Note: MPFR 2.2 had a mpfr_copysign
      function that was available, but not documented, and with a slight
      difference in the semantics (when the second input operand is a
      NaN).
 
-   * `mpfr_custom_get_significand' in MPFR 3.0.  This function was
-     named `mpfr_custom_get_mantissa' in previous versions;
-     `mpfr_custom_get_mantissa' is still available via a macro in
-     `mpfr.h':
+    mpfr_custom_get_significand in MPFR 3.0.  This function was named
+     mpfr_custom_get_mantissa in previous versions;
+     mpfr_custom_get_mantissa is still available via a macro in
+     mpfr.h:
           #define mpfr_custom_get_mantissa mpfr_custom_get_significand
      Thus code that needs to work with both MPFR 2.x and MPFR 3.x should
-     use `mpfr_custom_get_mantissa'.
+     use mpfr_custom_get_mantissa.
 
-   * `mpfr_d_div' and `mpfr_d_sub' in MPFR 2.4.
+    mpfr_d_div and mpfr_d_sub in MPFR 2.4.
 
-   * `mpfr_digamma' in MPFR 3.0.
+    mpfr_digamma in MPFR 3.0.
 
-   * `mpfr_div_d' in MPFR 2.4.
+    mpfr_div_d in MPFR 2.4.
 
-   * `mpfr_fmod' in MPFR 2.4.
+    mpfr_fmod in MPFR 2.4.
 
-   * `mpfr_fms' in MPFR 2.3.
+    mpfr_fms in MPFR 2.3.
 
-   * `mpfr_fprintf' in MPFR 2.4.
+    mpfr_fprintf in MPFR 2.4.
 
-   * `mpfr_get_flt' in MPFR 3.0.
+    mpfr_get_flt in MPFR 3.0.
 
-   * `mpfr_get_patches' in MPFR 2.3.
+    mpfr_get_patches in MPFR 2.3.
 
-   * `mpfr_get_z_2exp' in MPFR 3.0.  This function was named
-     `mpfr_get_z_exp' in previous versions; `mpfr_get_z_exp' is still
-     available via a macro in `mpfr.h':
+    mpfr_get_z_2exp in MPFR 3.0.  This function was named
+     mpfr_get_z_exp in previous versions; mpfr_get_z_exp is still
+     available via a macro in mpfr.h:
           #define mpfr_get_z_exp mpfr_get_z_2exp
      Thus code that needs to work with both MPFR 2.x and MPFR 3.x should
-     use `mpfr_get_z_exp'.
+     use mpfr_get_z_exp.
 
-   * `mpfr_j0', `mpfr_j1' and `mpfr_jn' in MPFR 2.3.
+    mpfr_j0, mpfr_j1 and mpfr_jn in MPFR 2.3.
 
-   * `mpfr_lgamma' in MPFR 2.3.
+    mpfr_lgamma in MPFR 2.3.
 
-   * `mpfr_li2' in MPFR 2.4.
+    mpfr_li2 in MPFR 2.4.
 
-   * `mpfr_modf' in MPFR 2.4.
+    mpfr_modf in MPFR 2.4.
 
-   * `mpfr_mul_d' in MPFR 2.4.
+    mpfr_mul_d in MPFR 2.4.
 
-   * `mpfr_printf' in MPFR 2.4.
+    mpfr_printf in MPFR 2.4.
 
-   * `mpfr_rec_sqrt' in MPFR 2.4.
+    mpfr_rec_sqrt in MPFR 2.4.
 
-   * `mpfr_regular_p' in MPFR 3.0.
+    mpfr_regular_p in MPFR 3.0.
 
-   * `mpfr_remainder' and `mpfr_remquo' in MPFR 2.3.
+    mpfr_remainder and mpfr_remquo in MPFR 2.3.
 
-   * `mpfr_set_flt' in MPFR 3.0.
+    mpfr_set_flt in MPFR 3.0.
 
-   * `mpfr_set_z_2exp' in MPFR 3.0.
+    mpfr_set_z_2exp in MPFR 3.0.
 
-   * `mpfr_set_zero' in MPFR 3.0.
+    mpfr_set_zero in MPFR 3.0.
 
-   * `mpfr_setsign' in MPFR 2.3.
+    mpfr_setsign in MPFR 2.3.
 
-   * `mpfr_signbit' in MPFR 2.3.
+    mpfr_signbit in MPFR 2.3.
 
-   * `mpfr_sinh_cosh' in MPFR 2.4.
+    mpfr_sinh_cosh in MPFR 2.4.
 
-   * `mpfr_snprintf' and `mpfr_sprintf' in MPFR 2.4.
+    mpfr_snprintf and mpfr_sprintf in MPFR 2.4.
 
-   * `mpfr_sub_d' in MPFR 2.4.
+    mpfr_sub_d in MPFR 2.4.
 
-   * `mpfr_urandom' in MPFR 3.0.
+    mpfr_urandom in MPFR 3.0.
 
-   * `mpfr_vasprintf', `mpfr_vfprintf', `mpfr_vprintf',
-     `mpfr_vsprintf' and `mpfr_vsnprintf' in MPFR 2.4.
-
-   * `mpfr_y0', `mpfr_y1' and `mpfr_yn' in MPFR 2.3.
+    mpfr_vasprintf, mpfr_vfprintf, mpfr_vprintf, mpfr_vsprintf
+     and mpfr_vsnprintf in MPFR 2.4.
 
+    mpfr_y0, mpfr_y1 and mpfr_yn in MPFR 2.3.
 
 
 File: mpfr.info,  Node: Changed Functions,  Next: Removed Functions,  Prev: Added Functions,  Up: API Compatibility
@@ -2789,73 +2724,72 @@ File: mpfr.info,  Node: Changed Functions,  Next: Removed Functions,  Prev: Adde
 6.3 Changed Functions
 =====================
 
-The following functions have changed after MPFR 2.2. Changes can affect
+The following functions have changed after MPFR 2.2.  Changes can affect
 the behavior of code written for some MPFR version when built and run
 against another MPFR version (older or newer), as described below.
 
-   * `mpfr_check_range' changed in MPFR 2.3.2 and MPFR 2.4.  If the
-     value is an inexact infinity, the overflow flag is now set (in
-     case it was lost), while it was previously left unchanged.  This
-     is really what is expected in practice (and what the MPFR code was
+    mpfr_check_range changed in MPFR 2.3.2 and MPFR 2.4.  If the
+     value is an inexact infinity, the overflow flag is now set (in case
+     it was lost), while it was previously left unchanged.  This is
+     really what is expected in practice (and what the MPFR code was
      expecting), so that the previous behavior was regarded as a bug.
      Hence the change in MPFR 2.3.2.
 
-   * `mpfr_get_f' changed in MPFR 3.0.  This function was returning
+    mpfr_get_f changed in MPFR 3.0.  This function was returning
      zero, except for NaN and Inf, which do not exist in MPF. The
-     _erange_ flag is now set in these cases, and `mpfr_get_f' now
+     _erange_ flag is now set in these cases, and mpfr_get_f now
      returns the usual ternary value.
 
-   * `mpfr_get_si', `mpfr_get_sj', `mpfr_get_ui' and `mpfr_get_uj'
+    mpfr_get_si, mpfr_get_sj, mpfr_get_ui and mpfr_get_uj
      changed in MPFR 3.0.  In previous MPFR versions, the cases where
      the _erange_ flag is set were unspecified.
 
-   * `mpfr_get_z' changed in MPFR 3.0.  The return type was `void'; it
-     is now `int', and the usual ternary value is returned.  Thus
+    mpfr_get_z changed in MPFR 3.0.  The return type was void; it
+     is now int, and the usual ternary value is returned.  Thus
      programs that need to work with both MPFR 2.x and 3.x must not use
-     the return value.  Even in this case, C code using `mpfr_get_z' as
+     the return value.  Even in this case, C code using mpfr_get_z as
      the second or third term of a conditional operator may also be
-     affected. For instance, the following is correct with MPFR 3.0,
+     affected.  For instance, the following is correct with MPFR 3.0,
      but not with MPFR 2.x:
             bool ? mpfr_get_z(...) : mpfr_add(...);
      On the other hand, the following is correct with MPFR 2.x, but not
      with MPFR 3.0:
             bool ? mpfr_get_z(...) : (void) mpfr_add(...);
-     Portable code should cast `mpfr_get_z(...)' to `void' to use the
-     type `void' for both terms of the conditional operator, as in:
+     Portable code should cast mpfr_get_z(...) to void to use the
+     type void for both terms of the conditional operator, as in:
             bool ? (void) mpfr_get_z(...) : (void) mpfr_add(...);
-     Alternatively, `if ... else' can be used instead of the
-     conditional operator.
+     Alternatively, if ... else can be used instead of the conditional
+     operator.
 
      Moreover the cases where the _erange_ flag is set were unspecified
      in MPFR 2.x.
 
-   * `mpfr_get_z_exp' changed in MPFR 3.0.  In previous MPFR versions,
+    mpfr_get_z_exp changed in MPFR 3.0.  In previous MPFR versions,
      the cases where the _erange_ flag is set were unspecified.  Note:
-     this function has been renamed to `mpfr_get_z_2exp' in MPFR 3.0,
-     but `mpfr_get_z_exp' is still available for compatibility reasons.
+     this function has been renamed to mpfr_get_z_2exp in MPFR 3.0,
+     but mpfr_get_z_exp is still available for compatibility reasons.
 
-   * `mpfr_strtofr' changed in MPFR 2.3.1 and MPFR 2.4.  This was
+    mpfr_strtofr changed in MPFR 2.3.1 and MPFR 2.4.  This was
      actually a bug fix since the code and the documentation did not
      match.  But both were changed in order to have a more consistent
      and useful behavior.  The main changes in the code are as follows.
-     The binary exponent is now accepted even without the `0b' or `0x'
+     The binary exponent is now accepted even without the 0b or 0x
      prefix.  Data corresponding to NaN can now have an optional sign
      (such data were previously invalid).
 
-   * `mpfr_strtofr' changed in MPFR 3.0.  This function now accepts
+    mpfr_strtofr changed in MPFR 3.0.  This function now accepts
      bases from 37 to 62 (no changes for the other bases).  Note: if an
      unsupported base is provided to this function, the behavior is
      undefined; more precisely, in MPFR 2.3.1 and later, providing an
      unsupported base yields an assertion failure (this behavior may
      change in the future).
 
-   * `mpfr_subnormalize' changed in MPFR 3.0.1.  This was actually
-     regarded as a bug fix. The `mpfr_subnormalize' implementation up
-     to MPFR 3.0.0 did not change the flags. In particular, it did not
-     follow the generic rule concerning the inexact flag (and no
-     special behavior was specified). The case of the underflow flag
-     was more a lack of specification.
-
+    mpfr_subnormalize changed in MPFR 3.0.1.  This was actually
+     regarded as a bug fix.  The mpfr_subnormalize implementation up
+     to MPFR 3.0.0 did not change the flags.  In particular, it did not
+     follow the generic rule concerning the inexact flag (and no special
+     behavior was specified).  The case of the underflow flag was more a
+     lack of specification.
 
 
 File: mpfr.info,  Node: Removed Functions,  Next: Other Changes,  Prev: Changed Functions,  Up: API Compatibility
@@ -2863,10 +2797,10 @@ File: mpfr.info,  Node: Removed Functions,  Next: Other Changes,  Prev: Changed
 6.4 Removed Functions
 =====================
 
-Functions `mpfr_random' and `mpfr_random2' have been removed in MPFR
-3.0 (this only affects old code built against MPFR 3.0 or later).  (The
-function `mpfr_random' had been deprecated since at least MPFR 2.2.0,
-and `mpfr_random2' since MPFR 2.4.0.)
+Functions mpfr_random and mpfr_random2 have been removed in MPFR 3.0
+(this only affects old code built against MPFR 3.0 or later).  (The
+function mpfr_random had been deprecated since at least MPFR 2.2.0,
+and mpfr_random2 since MPFR 2.4.0.)
 
 
 File: mpfr.info,  Node: Other Changes,  Prev: Removed Functions,  Up: API Compatibility
@@ -2874,26 +2808,25 @@ File: mpfr.info,  Node: Other Changes,  Prev: Removed Functions,  Up: API Compat
 6.5 Other Changes
 =================
 
-For users of a C++ compiler, the way how the availability of `intmax_t'
-is detected has changed in MPFR 3.0.  In MPFR 2.x, if a macro
-`INTMAX_C' or `UINTMAX_C' was defined (e.g. when the
-`__STDC_CONSTANT_MACROS' macro had been defined before `<stdint.h>' or
-`<inttypes.h>' has been included), `intmax_t' was assumed to be defined.
-However this was not always the case (more precisely, `intmax_t' can be
-defined only in the namespace `std', as with Boost), so that
-compilations could fail.  Thus the check for `INTMAX_C' or `UINTMAX_C'
-is now disabled for C++ compilers, with the following consequences:
-
-   * Programs written for MPFR 2.x that need `intmax_t' may no longer
-     be compiled against MPFR 3.0: a `#define MPFR_USE_INTMAX_T' may be
-     necessary before `mpfr.h' is included.
-
-   * The compilation of programs that work with MPFR 3.0 may fail with
+For users of a C++ compiler, the way how the availability of intmax_t
+is detected has changed in MPFR 3.0.  In MPFR 2.x, if a macro INTMAX_C
+or UINTMAX_C was defined (e.g.  when the __STDC_CONSTANT_MACROS
+macro had been defined before <stdint.h> or <inttypes.h> has been
+included), intmax_t was assumed to be defined.  However this was not
+always the case (more precisely, intmax_t can be defined only in the
+namespace std, as with Boost), so that compilations could fail.  Thus
+the check for INTMAX_C or UINTMAX_C is now disabled for C++
+compilers, with the following consequences:
+
+    Programs written for MPFR 2.x that need intmax_t may no longer be
+     compiled against MPFR 3.0: a #define MPFR_USE_INTMAX_T may be
+     necessary before mpfr.h is included.
+
+    The compilation of programs that work with MPFR 3.0 may fail with
      MPFR 2.x due to the problem described above.  Workarounds are
-     possible, such as defining `intmax_t' and `uintmax_t' in the global
+     possible, such as defining intmax_t and uintmax_t in the global
      namespace, though this is not clean.
 
-
 
 File: mpfr.info,  Node: Contributors,  Next: References,  Prev: API Compatibility,  Up: Top
 
@@ -2904,32 +2837,32 @@ The main developers of MPFR are Guillaume Hanrot, Vincent Lefvre,
 Patrick Plissier, Philippe Thveny and Paul Zimmermann.
 
    Sylvie Boldo from ENS-Lyon, France, contributed the functions
-`mpfr_agm' and `mpfr_log'.  Emmanuel Jeandel, from ENS-Lyon too,
+mpfr_agm and mpfr_log.  Emmanuel Jeandel, from ENS-Lyon too,
 contributed the generic hypergeometric code, as well as the internal
-function `mpfr_exp3', a first implementation of the sine and cosine,
-and improved versions of `mpfr_const_log2' and `mpfr_const_pi'.
-Mathieu Dutour contributed the functions `mpfr_atan' and `mpfr_asin',
-and a previous version of `mpfr_gamma'; David Daney contributed the
-hyperbolic and inverse hyperbolic functions, the base-2 exponential,
-and the factorial function. Fabrice Rouillier contributed the
-`mpfr_xxx_z' and `mpfr_xxx_q' functions, and helped to the Microsoft
-Windows porting.  Jean-Luc Rmy contributed the `mpfr_zeta' code.
-Ludovic Meunier helped in the design of the `mpfr_erf' code.  Damien
-Stehl contributed the `mpfr_get_ld_2exp' function.  Sylvain Chevillard
-contributed the `mpfr_ai' function.
+function mpfr_exp3, a first implementation of the sine and cosine, and
+improved versions of mpfr_const_log2 and mpfr_const_pi.  Mathieu
+Dutour contributed the functions mpfr_atan and mpfr_asin, and a
+previous version of mpfr_gamma; David Daney contributed the hyperbolic
+and inverse hyperbolic functions, the base-2 exponential, and the
+factorial function.  Fabrice Rouillier contributed the mpfr_xxx_z and
+mpfr_xxx_q functions, and helped to the Microsoft Windows porting.
+Jean-Luc Rmy contributed the mpfr_zeta code.  Ludovic Meunier helped
+in the design of the mpfr_erf code.  Damien Stehl contributed the
+mpfr_get_ld_2exp function.  Sylvain Chevillard contributed the
+mpfr_ai function.
 
    We would like to thank Jean-Michel Muller and Joris van der Hoeven
-for very fruitful discussions at the beginning of that project,
-Torbjrn Granlund and Kevin Ryde for their help about design issues,
-and Nathalie Revol for her careful reading of a previous version of
-this documentation. In particular Kevin Ryde did a tremendous job for
-the portability of MPFR in 2002-2004.
+for very fruitful discussions at the beginning of that project, Torbjrn
+Granlund and Kevin Ryde for their help about design issues, and Nathalie
+Revol for her careful reading of a previous version of this
+documentation.  In particular Kevin Ryde did a tremendous job for the
+portability of MPFR in 2002-2004.
 
    The development of the MPFR library would not have been possible
 without the continuous support of INRIA, and of the LORIA (Nancy,
-France) and LIP (Lyon, France) laboratories. In particular the main
+France) and LIP (Lyon, France) laboratories.  In particular the main
 authors were or are members of the PolKA, Spaces, Cacao and Caramel
-project-teams at LORIA and of the Arnaire project-team at LIP.  This
+project-teams at LORIA and of the Arnaire project-team at LIP. This
 project was started during the Fiable (reliable in French) action
 supported by INRIA, and continued during the AOC action.  The
 development of MPFR was also supported by a grant (202F0659 00 MPN 121)
@@ -2944,40 +2877,39 @@ File: mpfr.info,  Node: References,  Next: GNU Free Documentation License,  Prev
 References
 **********
 
-   * Richard Brent and Paul Zimmermann, "Modern Computer Arithmetic",
+    Richard Brent and Paul Zimmermann, "Modern Computer Arithmetic",
      Cambridge University Press (to appear), also available from the
-     authors' web pages.
+     authors web pages.
 
-   * Laurent Fousse, Guillaume Hanrot, Vincent Lefvre, Patrick
+    Laurent Fousse, Guillaume Hanrot, Vincent Lefvre, Patrick
      Plissier and Paul Zimmermann, "MPFR: A Multiple-Precision Binary
      Floating-Point Library With Correct Rounding", ACM Transactions on
      Mathematical Software, volume 33, issue 2, article 13, 15 pages,
-     2007, `http://doi.acm.org/10.1145/1236463.1236468'.
+     2007, <http://doi.acm.org/10.1145/1236463.1236468>.
 
-   * Torbjrn Granlund, "GNU MP: The GNU Multiple Precision Arithmetic
-     Library",   version 5.0.1, 2010, `http://gmplib.org'.
+    Torbjrn Granlund, "GNU MP: The GNU Multiple Precision Arithmetic
+     Library", version 5.0.1, 2010, <http://gmplib.org>.
 
-   * IEEE standard for binary floating-point arithmetic, Technical
-     Report ANSI-IEEE Standard 754-1985, New York, 1985.  Approved
-     March 21, 1985: IEEE Standards Board; approved July 26,   1985:
-     American National Standards Institute, 18 pages.
+    IEEE standard for binary floating-point arithmetic, Technical
+     Report ANSI-IEEE Standard 754-1985, New York, 1985.  Approved March
+     21, 1985: IEEE Standards Board; approved July 26, 1985: American
+     National Standards Institute, 18 pages.
 
-   * IEEE Standard for Floating-Point Arithmetic, ANSI-IEEE Standard
+    IEEE Standard for Floating-Point Arithmetic, ANSI-IEEE Standard
      754-2008, 2008.  Revision of ANSI-IEEE Standard 754-1985, approved
      June 12, 2008: IEEE Standards Board, 70 pages.
 
-   * Donald E. Knuth, "The Art of Computer Programming", vol 2,
+    Donald E. Knuth, "The Art of Computer Programming", vol 2,
      "Seminumerical Algorithms", 2nd edition, Addison-Wesley, 1981.
 
-   * Jean-Michel Muller, "Elementary Functions, Algorithms and
+    Jean-Michel Muller, "Elementary Functions, Algorithms and
      Implementation", Birkhuser, Boston, 2nd edition, 2006.
 
-   * Jean-Michel Muller, Nicolas Brisebarre, Florent de Dinechin,
+    Jean-Michel Muller, Nicolas Brisebarre, Florent de Dinechin,
      Claude-Pierre Jeannerod, Vincent Lefvre, Guillaume Melquiond,
      Nathalie Revol, Damien Stehl and Serge Torrs, "Handbook of
      Floating-Point Arithmetic", Birkhuser, Boston, 2009.
 
-
 
 File: mpfr.info,  Node: GNU Free Documentation License,  Next: Concept Index,  Prev: References,  Up: Top
 
@@ -2986,7 +2918,7 @@ Appendix A GNU Free Documentation License
 
                       Version 1.2, November 2002
 
-     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
+     Copyright  2000,2001,2002 Free Software Foundation, Inc.
      51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
 
      Everyone is permitted to copy and distribute verbatim copies
@@ -2995,14 +2927,14 @@ Appendix A GNU Free Documentation License
   0. PREAMBLE
 
      The purpose of this License is to make a manual, textbook, or other
-     functional and useful document "free" in the sense of freedom: to
+     functional and useful document free in the sense of freedom: to
      assure everyone the effective freedom to copy and redistribute it,
      with or without modifying it, either commercially or
      noncommercially.  Secondarily, this License preserves for the
      author and publisher a way to get credit for their work, while not
      being considered responsible for modifications made by others.
 
-     This License is a kind of "copyleft", which means that derivative
+     This License is a kind of copyleft, which means that derivative
      works of the document must themselves be free in the same sense.
      It complements the GNU General Public License, which is a copyleft
      license designed for free software.
@@ -3012,29 +2944,29 @@ Appendix A GNU Free Documentation License
      free program should come with manuals providing the same freedoms
      that the software does.  But this License is not limited to
      software manuals; it can be used for any textual work, regardless
-     of subject matter or whether it is published as a printed book.
-     We recommend this License principally for works whose purpose is
+     of subject matter or whether it is published as a printed book.  We
+     recommend this License principally for works whose purpose is
      instruction or reference.
 
   1. APPLICABILITY AND DEFINITIONS
 
      This License applies to any manual or other work, in any medium,
-     that contains a notice placed by the copyright holder saying it
-     can be distributed under the terms of this License.  Such a notice
+     that contains a notice placed by the copyright holder saying it can
+     be distributed under the terms of this License.  Such a notice
      grants a world-wide, royalty-free license, unlimited in duration,
      to use that work under the conditions stated herein.  The
-     "Document", below, refers to any such manual or work.  Any member
-     of the public is a licensee, and is addressed as "you".  You
-     accept the license if you copy, modify or distribute the work in a
-     way requiring permission under copyright law.
+     Document, below, refers to any such manual or work.  Any member
+     of the public is a licensee, and is addressed as you.  You accept
+     the license if you copy, modify or distribute the work in a way
+     requiring permission under copyright law.
 
-     A "Modified Version" of the Document means any work containing the
+     A Modified Version of the Document means any work containing the
      Document or a portion of it, either copied verbatim, or with
      modifications and/or translated into another language.
 
-     A "Secondary Section" is a named appendix or a front-matter section
+     A Secondary Section is a named appendix or a front-matter section
      of the Document that deals exclusively with the relationship of the
-     publishers or authors of the Document to the Document's overall
+     publishers or authors of the Document to the Documents overall
      subject (or to related matters) and contains nothing that could
      fall directly within that overall subject.  (Thus, if the Document
      is in part a textbook of mathematics, a Secondary Section may not
@@ -3043,59 +2975,59 @@ Appendix A GNU Free Documentation License
      of legal, commercial, philosophical, ethical or political position
      regarding them.
 
-     The "Invariant Sections" are certain Secondary Sections whose
-     titles are designated, as being those of Invariant Sections, in
-     the notice that says that the Document is released under this
-     License.  If a section does not fit the above definition of
-     Secondary then it is not allowed to be designated as Invariant.
-     The Document may contain zero Invariant Sections.  If the Document
-     does not identify any Invariant Sections then there are none.
+     The Invariant Sections are certain Secondary Sections whose
+     titles are designated, as being those of Invariant Sections, in the
+     notice that says that the Document is released under this License.
+     If a section does not fit the above definition of Secondary then it
+     is not allowed to be designated as Invariant.  The Document may
+     contain zero Invariant Sections.  If the Document does not identify
+     any Invariant Sections then there are none.
 
-     The "Cover Texts" are certain short passages of text that are
+     The Cover Texts are certain short passages of text that are
      listed, as Front-Cover Texts or Back-Cover Texts, in the notice
      that says that the Document is released under this License.  A
      Front-Cover Text may be at most 5 words, and a Back-Cover Text may
      be at most 25 words.
 
-     A "Transparent" copy of the Document means a machine-readable copy,
+     A Transparent copy of the Document means a machine-readable copy,
      represented in a format whose specification is available to the
      general public, that is suitable for revising the document
-     straightforwardly with generic text editors or (for images
-     composed of pixels) generic paint programs or (for drawings) some
-     widely available drawing editor, and that is suitable for input to
-     text formatters or for automatic translation to a variety of
-     formats suitable for input to text formatters.  A copy made in an
-     otherwise Transparent file format whose markup, or absence of
-     markup, has been arranged to thwart or discourage subsequent
-     modification by readers is not Transparent.  An image format is
-     not Transparent if used for any substantial amount of text.  A
-     copy that is not "Transparent" is called "Opaque".
+     straightforwardly with generic text editors or (for images composed
+     of pixels) generic paint programs or (for drawings) some widely
+     available drawing editor, and that is suitable for input to text
+     formatters or for automatic translation to a variety of formats
+     suitable for input to text formatters.  A copy made in an otherwise
+     Transparent file format whose markup, or absence of markup, has
+     been arranged to thwart or discourage subsequent modification by
+     readers is not Transparent.  An image format is not Transparent if
+     used for any substantial amount of text.  A copy that is not
+     Transparent is called Opaque.
 
      Examples of suitable formats for Transparent copies include plain
      ASCII without markup, Texinfo input format, LaTeX input format,
-     SGML or XML using a publicly available DTD, and
-     standard-conforming simple HTML, PostScript or PDF designed for
-     human modification.  Examples of transparent image formats include
-     PNG, XCF and JPG.  Opaque formats include proprietary formats that
-     can be read and edited only by proprietary word processors, SGML or
-     XML for which the DTD and/or processing tools are not generally
-     available, and the machine-generated HTML, PostScript or PDF
-     produced by some word processors for output purposes only.
-
-     The "Title Page" means, for a printed book, the title page itself,
+     SGML or XML using a publicly available DTD, and standard-conforming
+     simple HTML, PostScript or PDF designed for human modification.
+     Examples of transparent image formats include PNG, XCF and JPG.
+     Opaque formats include proprietary formats that can be read and
+     edited only by proprietary word processors, SGML or XML for which
+     the DTD and/or processing tools are not generally available, and
+     the machine-generated HTML, PostScript or PDF produced by some word
+     processors for output purposes only.
+
+     The Title Page means, for a printed book, the title page itself,
      plus such following pages as are needed to hold, legibly, the
      material this License requires to appear in the title page.  For
-     works in formats which do not have any title page as such, "Title
-     Page" means the text near the most prominent appearance of the
-     work's title, preceding the beginning of the body of the text.
+     works in formats which do not have any title page as such, Title
+     Page means the text near the most prominent appearance of the
+     works title, preceding the beginning of the body of the text.
 
-     A section "Entitled XYZ" means a named subunit of the Document
+     A section Entitled XYZ means a named subunit of the Document
      whose title either is precisely XYZ or contains XYZ in parentheses
      following text that translates XYZ in another language.  (Here XYZ
      stands for a specific section name mentioned below, such as
-     "Acknowledgements", "Dedications", "Endorsements", or "History".)
-     To "Preserve the Title" of such a section when you modify the
-     Document means that it remains a section "Entitled XYZ" according
+     Acknowledgements, Dedications, Endorsements, or History.)
+     To Preserve the Title of such a section when you modify the
+     Document means that it remains a section Entitled XYZ according
      to this definition.
 
      The Document may include Warranty Disclaimers next to the notice
@@ -3115,8 +3047,8 @@ Appendix A GNU Free Documentation License
      may not use technical measures to obstruct or control the reading
      or further copying of the copies you make or distribute.  However,
      you may accept compensation in exchange for copies.  If you
-     distribute a large enough number of copies you must also follow
-     the conditions in section 3.
+     distribute a large enough number of copies you must also follow the
+     conditions in section 3.
 
      You may also lend copies, under the same conditions stated above,
      and you may publicly display copies.
@@ -3125,17 +3057,16 @@ Appendix A GNU Free Documentation License
 
      If you publish printed copies (or copies in media that commonly
      have printed covers) of the Document, numbering more than 100, and
-     the Document's license notice requires Cover Texts, you must
+     the Documents license notice requires Cover Texts, you must
      enclose the copies in covers that carry, clearly and legibly, all
      these Cover Texts: Front-Cover Texts on the front cover, and
      Back-Cover Texts on the back cover.  Both covers must also clearly
      and legibly identify you as the publisher of these copies.  The
-     front cover must present the full title with all words of the
-     title equally prominent and visible.  You may add other material
-     on the covers in addition.  Copying with changes limited to the
-     covers, as long as they preserve the title of the Document and
-     satisfy these conditions, can be treated as verbatim copying in
-     other respects.
+     front cover must present the full title with all words of the title
+     equally prominent and visible.  You may add other material on the
+     covers in addition.  Copying with changes limited to the covers, as
+     long as they preserve the title of the Document and satisfy these
+     conditions, can be treated as verbatim copying in other respects.
 
      If the required texts for either cover are too voluminous to fit
      legibly, you should put the first ones listed (as many as fit
@@ -3143,40 +3074,39 @@ Appendix A GNU Free Documentation License
      adjacent pages.
 
      If you publish or distribute Opaque copies of the Document
-     numbering more than 100, you must either include a
-     machine-readable Transparent copy along with each Opaque copy, or
-     state in or with each Opaque copy a computer-network location from
-     which the general network-using public has access to download
-     using public-standard network protocols a complete Transparent
-     copy of the Document, free of added material.  If you use the
-     latter option, you must take reasonably prudent steps, when you
-     begin distribution of Opaque copies in quantity, to ensure that
-     this Transparent copy will remain thus accessible at the stated
-     location until at least one year after the last time you
-     distribute an Opaque copy (directly or through your agents or
-     retailers) of that edition to the public.
+     numbering more than 100, you must either include a machine-readable
+     Transparent copy along with each Opaque copy, or state in or with
+     each Opaque copy a computer-network location from which the general
+     network-using public has access to download using public-standard
+     network protocols a complete Transparent copy of the Document, free
+     of added material.  If you use the latter option, you must take
+     reasonably prudent steps, when you begin distribution of Opaque
+     copies in quantity, to ensure that this Transparent copy will
+     remain thus accessible at the stated location until at least one
+     year after the last time you distribute an Opaque copy (directly or
+     through your agents or retailers) of that edition to the public.
 
      It is requested, but not required, that you contact the authors of
-     the Document well before redistributing any large number of
-     copies, to give them a chance to provide you with an updated
-     version of the Document.
+     the Document well before redistributing any large number of copies,
+     to give them a chance to provide you with an updated version of the
+     Document.
 
   4. MODIFICATIONS
 
      You may copy and distribute a Modified Version of the Document
      under the conditions of sections 2 and 3 above, provided that you
-     release the Modified Version under precisely this License, with
-     the Modified Version filling the role of the Document, thus
-     licensing distribution and modification of the Modified Version to
-     whoever possesses a copy of it.  In addition, you must do these
-     things in the Modified Version:
+     release the Modified Version under precisely this License, with the
+     Modified Version filling the role of the Document, thus licensing
+     distribution and modification of the Modified Version to whoever
+     possesses a copy of it.  In addition, you must do these things in
+     the Modified Version:
 
        A. Use in the Title Page (and on the covers, if any) a title
-          distinct from that of the Document, and from those of
-          previous versions (which should, if there were any, be listed
-          in the History section of the Document).  You may use the
-          same title as a previous version if the original publisher of
-          that version gives permission.
+          distinct from that of the Document, and from those of previous
+          versions (which should, if there were any, be listed in the
+          History section of the Document).  You may use the same title
+          as a previous version if the original publisher of that
+          version gives permission.
 
        B. List on the Title Page, as authors, one or more persons or
           entities responsible for authorship of the modifications in
@@ -3199,72 +3129,71 @@ Appendix A GNU Free Documentation License
           the Addendum below.
 
        G. Preserve in that license notice the full lists of Invariant
-          Sections and required Cover Texts given in the Document's
+          Sections and required Cover Texts given in the Documents
           license notice.
 
        H. Include an unaltered copy of this License.
 
-       I. Preserve the section Entitled "History", Preserve its Title,
+       I. Preserve the section Entitled History, Preserve its Title,
           and add to it an item stating at least the title, year, new
-          authors, and publisher of the Modified Version as given on
-          the Title Page.  If there is no section Entitled "History" in
-          the Document, create one stating the title, year, authors,
-          and publisher of the Document as given on its Title Page,
-          then add an item describing the Modified Version as stated in
-          the previous sentence.
+          authors, and publisher of the Modified Version as given on the
+          Title Page.  If there is no section Entitled History in the
+          Document, create one stating the title, year, authors, and
+          publisher of the Document as given on its Title Page, then add
+          an item describing the Modified Version as stated in the
+          previous sentence.
 
        J. Preserve the network location, if any, given in the Document
           for public access to a Transparent copy of the Document, and
           likewise the network locations given in the Document for
-          previous versions it was based on.  These may be placed in
-          the "History" section.  You may omit a network location for a
-          work that was published at least four years before the
-          Document itself, or if the original publisher of the version
-          it refers to gives permission.
-
-       K. For any section Entitled "Acknowledgements" or "Dedications",
-          Preserve the Title of the section, and preserve in the
-          section all the substance and tone of each of the contributor
+          previous versions it was based on.  These may be placed in the
+          History section.  You may omit a network location for a work
+          that was published at least four years before the Document
+          itself, or if the original publisher of the version it refers
+          to gives permission.
+
+       K. For any section Entitled Acknowledgements or Dedications,
+          Preserve the Title of the section, and preserve in the section
+          all the substance and tone of each of the contributor
           acknowledgements and/or dedications given therein.
 
-       L. Preserve all the Invariant Sections of the Document,
-          unaltered in their text and in their titles.  Section numbers
-          or the equivalent are not considered part of the section
-          titles.
+       L. Preserve all the Invariant Sections of the Document, unaltered
+          in their text and in their titles.  Section numbers or the
+          equivalent are not considered part of the section titles.
 
-       M. Delete any section Entitled "Endorsements".  Such a section
+       M. Delete any section Entitled Endorsements.  Such a section
           may not be included in the Modified Version.
 
        N. Do not retitle any existing section to be Entitled
-          "Endorsements" or to conflict in title with any Invariant
+          Endorsements or to conflict in title with any Invariant
           Section.
 
        O. Preserve any Warranty Disclaimers.
 
      If the Modified Version includes new front-matter sections or
      appendices that qualify as Secondary Sections and contain no
-     material copied from the Document, you may at your option
-     designate some or all of these sections as invariant.  To do this,
-     add their titles to the list of Invariant Sections in the Modified
-     Version's license notice.  These titles must be distinct from any
-     other section titles.
+     material copied from the Document, you may at your option designate
+     some or all of these sections as invariant.  To do this, add their
+     titles to the list of Invariant Sections in the Modified Versions
+     license notice.  These titles must be distinct from any other
+     section titles.
 
-     You may add a section Entitled "Endorsements", provided it contains
+     You may add a section Entitled Endorsements, provided it contains
      nothing but endorsements of your Modified Version by various
-     parties--for example, statements of peer review or that the text
-     has been approved by an organization as the authoritative
-     definition of a standard.
+     partiesfor example, statements of peer review or that the text has
+     been approved by an organization as the authoritative definition of
+     a standard.
 
      You may add a passage of up to five words as a Front-Cover Text,
-     and a passage of up to 25 words as a Back-Cover Text, to the end
-     of the list of Cover Texts in the Modified Version.  Only one
-     passage of Front-Cover Text and one of Back-Cover Text may be
-     added by (or through arrangements made by) any one entity.  If the
-     Document already includes a cover text for the same cover,
-     previously added by you or by arrangement made by the same entity
-     you are acting on behalf of, you may not add another; but you may
-     replace the old one, on explicit permission from the previous
-     publisher that added the old one.
+     and a passage of up to 25 words as a Back-Cover Text, to the end of
+     the list of Cover Texts in the Modified Version.  Only one passage
+     of Front-Cover Text and one of Back-Cover Text may be added by (or
+     through arrangements made by) any one entity.  If the Document
+     already includes a cover text for the same cover, previously added
+     by you or by arrangement made by the same entity you are acting on
+     behalf of, you may not add another; but you may replace the old
+     one, on explicit permission from the previous publisher that added
+     the old one.
 
      The author(s) and publisher(s) of the Document do not by this
      License give permission to use their names for publicity for or to
@@ -3274,8 +3203,8 @@ Appendix A GNU Free Documentation License
 
      You may combine the Document with other documents released under
      this License, under the terms defined in section 4 above for
-     modified versions, provided that you include in the combination
-     all of the Invariant Sections of all of the original documents,
+     modified versions, provided that you include in the combination all
+     of the Invariant Sections of all of the original documents,
      unmodified, and list them all as Invariant Sections of your
      combined work in its license notice, and that you preserve all
      their Warranty Disclaimers.
@@ -3291,10 +3220,10 @@ Appendix A GNU Free Documentation License
      combined work.
 
      In the combination, you must combine any sections Entitled
-     "History" in the various original documents, forming one section
-     Entitled "History"; likewise combine any sections Entitled
-     "Acknowledgements", and any sections Entitled "Dedications".  You
-     must delete all sections Entitled "Endorsements."
+     History in the various original documents, forming one section
+     Entitled History; likewise combine any sections Entitled
+     Acknowledgements, and any sections Entitled Dedications.  You
+     must delete all sections Entitled Endorsements.
 
   6. COLLECTIONS OF DOCUMENTS
 
@@ -3302,29 +3231,29 @@ Appendix A GNU Free Documentation License
      documents released under this License, and replace the individual
      copies of this License in the various documents with a single copy
      that is included in the collection, provided that you follow the
-     rules of this License for verbatim copying of each of the
-     documents in all other respects.
+     rules of this License for verbatim copying of each of the documents
+     in all other respects.
 
      You may extract a single document from such a collection, and
      distribute it individually under this License, provided you insert
-     a copy of this License into the extracted document, and follow
-     this License in all other respects regarding verbatim copying of
-     that document.
+     a copy of this License into the extracted document, and follow this
+     License in all other respects regarding verbatim copying of that
+     document.
 
   7. AGGREGATION WITH INDEPENDENT WORKS
 
      A compilation of the Document or its derivatives with other
-     separate and independent documents or works, in or on a volume of
-     a storage or distribution medium, is called an "aggregate" if the
+     separate and independent documents or works, in or on a volume of a
+     storage or distribution medium, is called an aggregate if the
      copyright resulting from the compilation is not used to limit the
-     legal rights of the compilation's users beyond what the individual
+     legal rights of the compilations users beyond what the individual
      works permit.  When the Document is included in an aggregate, this
      License does not apply to the other works in the aggregate which
      are not themselves derivative works of the Document.
 
      If the Cover Text requirement of section 3 is applicable to these
      copies of the Document, then if the Document is less than one half
-     of the entire aggregate, the Document's Cover Texts may be placed
+     of the entire aggregate, the Documents Cover Texts may be placed
      on covers that bracket the Document within the aggregate, or the
      electronic equivalent of covers if the Document is in electronic
      form.  Otherwise they must appear on printed covers that bracket
@@ -3346,8 +3275,8 @@ Appendix A GNU Free Documentation License
      this License or a notice or disclaimer, the original version will
      prevail.
 
-     If a section in the Document is Entitled "Acknowledgements",
-     "Dedications", or "History", the requirement (section 4) to
+     If a section in the Document is Entitled Acknowledgements,
+     Dedications, or History, the requirement (section 4) to
      Preserve its Title (section 1) will typically require changing the
      actual title.
 
@@ -3358,26 +3287,26 @@ Appendix A GNU Free Documentation License
      attempt to copy, modify, sublicense or distribute the Document is
      void, and will automatically terminate your rights under this
      License.  However, parties who have received copies, or rights,
-     from you under this License will not have their licenses
-     terminated so long as such parties remain in full compliance.
+     from you under this License will not have their licenses terminated
+     so long as such parties remain in full compliance.
 
- 10. FUTURE REVISIONS OF THIS LICENSE
+  10. FUTURE REVISIONS OF THIS LICENSE
 
      The Free Software Foundation may publish new, revised versions of
      the GNU Free Documentation License from time to time.  Such new
      versions will be similar in spirit to the present version, but may
      differ in detail to address new problems or concerns.  See
-     `http://www.gnu.org/copyleft/'.
+     <http://www.gnu.org/copyleft/>.
 
      Each version of the License is given a distinguishing version
      number.  If the Document specifies that a particular numbered
-     version of this License "or any later version" applies to it, you
+     version of this License or any later version applies to it, you
      have the option of following the terms and conditions either of
      that specified version or of any later version that has been
-     published (not as a draft) by the Free Software Foundation.  If
-     the Document does not specify a version number of this License,
-     you may choose any version ever published (not as a draft) by the
-     Free Software Foundation.
+     published (not as a draft) by the Free Software Foundation.  If the
+     Document does not specify a version number of this License, you may
+     choose any version ever published (not as a draft) by the Free
+     Software Foundation.
 
 A.1 ADDENDUM: How to Use This License For Your Documents
 ========================================================
@@ -3395,7 +3324,7 @@ notices just after the title page:
        Free Documentation License''.
 
    If you have Invariant Sections, Front-Cover Texts and Back-Cover
-Texts, replace the "with...Texts." line with this:
+Texts, replace the with...Texts. line with this:
 
          with the Invariant Sections being LIST THEIR TITLES, with
          the Front-Cover Texts being LIST, and with the Back-Cover Texts
@@ -3406,9 +3335,9 @@ combination of the three, merge those two alternatives to suit the
 situation.
 
    If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License, to
-permit their use in free software.
+recommend releasing these examples in parallel under your choice of free
+software license, such as the GNU General Public License, to permit
+their use in free software.
 
 
 File: mpfr.info,  Node: Concept Index,  Next: Function Index,  Prev: GNU Free Documentation License,  Up: Top
@@ -3448,10 +3377,12 @@ Concept Index
 * Floating-point number:                 MPFR Basics.          (line 70)
 * GNU Free Documentation License:        GNU Free Documentation License.
                                                                (line  6)
-* I/O functions <1>:                     Formatted Output Functions.
-                                                               (line  3)
+* GNU Free Documentation License <1>:    GNU Free Documentation License.
+                                                               (line  6)
 * I/O functions:                         Input and Output Functions.
                                                                (line  3)
+* I/O functions <1>:                     Formatted Output Functions.
+                                                               (line  3)
 * Initialization functions:              Initialization Functions.
                                                                (line  3)
 * Input functions:                       Input and Output Functions.
@@ -3470,12 +3401,12 @@ Concept Index
 * Miscellaneous float functions:         Miscellaneous Functions.
                                                                (line  3)
 * mpfr.h:                                MPFR Basics.          (line  9)
-* Output functions <1>:                  Formatted Output Functions.
-                                                               (line  3)
 * Output functions:                      Input and Output Functions.
                                                                (line  3)
-* Precision <1>:                         MPFR Interface.       (line 17)
+* Output functions <1>:                  Formatted Output Functions.
+                                                               (line  3)
 * Precision:                             MPFR Basics.          (line 84)
+* Precision <1>:                         MPFR Interface.       (line 17)
 * Reporting bugs:                        Reporting Bugs.       (line  6)
 * Rounding mode related functions:       Rounding Related Functions.
                                                                (line  3)
@@ -3496,560 +3427,560 @@ Function and Type Index
 * Menu:
 
 * mpfr_abs:                              Basic Arithmetic Functions.
-                                                              (line 173)
-* mpfr_acos:                             Special Functions.   (line  53)
-* mpfr_acosh:                            Special Functions.   (line 137)
+                                                              (line 158)
+* mpfr_acos:                             Special Functions.   (line  52)
+* mpfr_acosh:                            Special Functions.   (line 116)
 * mpfr_add:                              Basic Arithmetic Functions.
-                                                              (line   8)
+                                                              (line   6)
 * mpfr_add_d:                            Basic Arithmetic Functions.
-                                                              (line  14)
+                                                              (line  12)
 * mpfr_add_q:                            Basic Arithmetic Functions.
-                                                              (line  18)
+                                                              (line  16)
 * mpfr_add_si:                           Basic Arithmetic Functions.
-                                                              (line  12)
-* mpfr_add_ui:                           Basic Arithmetic Functions.
                                                               (line  10)
+* mpfr_add_ui:                           Basic Arithmetic Functions.
+                                                              (line   8)
 * mpfr_add_z:                            Basic Arithmetic Functions.
-                                                              (line  16)
-* mpfr_agm:                              Special Functions.   (line 230)
-* mpfr_ai:                               Special Functions.   (line 246)
-* mpfr_asin:                             Special Functions.   (line  54)
-* mpfr_asinh:                            Special Functions.   (line 138)
+                                                              (line  14)
+* mpfr_agm:                              Special Functions.   (line 208)
+* mpfr_ai:                               Special Functions.   (line 224)
+* mpfr_asin:                             Special Functions.   (line  53)
+* mpfr_asinh:                            Special Functions.   (line 117)
 * mpfr_asprintf:                         Formatted Output Functions.
-                                                              (line 194)
-* mpfr_atan:                             Special Functions.   (line  55)
-* mpfr_atan2:                            Special Functions.   (line  66)
-* mpfr_atanh:                            Special Functions.   (line 139)
+                                                              (line 193)
+* mpfr_atan:                             Special Functions.   (line  54)
+* mpfr_atan2:                            Special Functions.   (line  64)
+* mpfr_atanh:                            Special Functions.   (line 118)
 * mpfr_buildopt_decimal_p:               Miscellaneous Functions.
-                                                              (line 130)
+                                                              (line 129)
 * mpfr_buildopt_tls_p:                   Miscellaneous Functions.
-                                                              (line 124)
+                                                              (line 123)
 * mpfr_can_round:                        Rounding Related Functions.
-                                                              (line  37)
+                                                              (line  35)
 * mpfr_cbrt:                             Basic Arithmetic Functions.
-                                                              (line 107)
+                                                              (line 106)
 * mpfr_ceil:                             Integer Related Functions.
-                                                              (line   8)
+                                                              (line   7)
 * mpfr_check_range:                      Exception Related Functions.
-                                                              (line  38)
+                                                              (line  37)
 * mpfr_clear:                            Initialization Functions.
-                                                              (line  31)
+                                                              (line  30)
+* mpfr_clears:                           Initialization Functions.
+                                                              (line  35)
 * mpfr_clear_erangeflag:                 Exception Related Functions.
-                                                              (line 115)
+                                                              (line 114)
 * mpfr_clear_flags:                      Exception Related Functions.
-                                                              (line 125)
+                                                              (line 124)
 * mpfr_clear_inexflag:                   Exception Related Functions.
-                                                              (line 114)
-* mpfr_clear_nanflag:                    Exception Related Functions.
                                                               (line 113)
-* mpfr_clear_overflow:                   Exception Related Functions.
+* mpfr_clear_nanflag:                    Exception Related Functions.
                                                               (line 112)
-* mpfr_clear_underflow:                  Exception Related Functions.
+* mpfr_clear_overflow:                   Exception Related Functions.
                                                               (line 111)
-* mpfr_clears:                           Initialization Functions.
-                                                              (line  36)
+* mpfr_clear_underflow:                  Exception Related Functions.
+                                                              (line 110)
 * mpfr_cmp:                              Comparison Functions.
-                                                              (line   7)
+                                                              (line   6)
+* mpfr_cmpabs:                           Comparison Functions.
+                                                              (line  34)
 * mpfr_cmp_d:                            Comparison Functions.
-                                                              (line  10)
+                                                              (line   9)
 * mpfr_cmp_f:                            Comparison Functions.
-                                                              (line  14)
+                                                              (line  13)
 * mpfr_cmp_ld:                           Comparison Functions.
-                                                              (line  11)
+                                                              (line  10)
 * mpfr_cmp_q:                            Comparison Functions.
-                                                              (line  13)
+                                                              (line  12)
 * mpfr_cmp_si:                           Comparison Functions.
-                                                              (line   9)
+                                                              (line   8)
 * mpfr_cmp_si_2exp:                      Comparison Functions.
-                                                              (line  31)
+                                                              (line  29)
 * mpfr_cmp_ui:                           Comparison Functions.
-                                                              (line   8)
+                                                              (line   7)
 * mpfr_cmp_ui_2exp:                      Comparison Functions.
-                                                              (line  29)
+                                                              (line  27)
 * mpfr_cmp_z:                            Comparison Functions.
-                                                              (line  12)
-* mpfr_cmpabs:                           Comparison Functions.
-                                                              (line  35)
-* mpfr_const_catalan:                    Special Functions.   (line 257)
-* mpfr_const_euler:                      Special Functions.   (line 256)
-* mpfr_const_log2:                       Special Functions.   (line 254)
-* mpfr_const_pi:                         Special Functions.   (line 255)
+                                                              (line  11)
+* mpfr_const_catalan:                    Special Functions.   (line 235)
+* mpfr_const_euler:                      Special Functions.   (line 234)
+* mpfr_const_log2:                       Special Functions.   (line 232)
+* mpfr_const_pi:                         Special Functions.   (line 233)
 * mpfr_copysign:                         Miscellaneous Functions.
-                                                              (line  78)
-* mpfr_cos:                              Special Functions.   (line  31)
-* mpfr_cosh:                             Special Functions.   (line 116)
-* mpfr_cot:                              Special Functions.   (line  49)
-* mpfr_coth:                             Special Functions.   (line 133)
-* mpfr_csc:                              Special Functions.   (line  48)
-* mpfr_csch:                             Special Functions.   (line 132)
-* mpfr_custom_get_exp:                   Custom Interface.    (line  78)
-* mpfr_custom_get_kind:                  Custom Interface.    (line  67)
-* mpfr_custom_get_significand:           Custom Interface.    (line  72)
-* mpfr_custom_get_size:                  Custom Interface.    (line  36)
-* mpfr_custom_init:                      Custom Interface.    (line  41)
-* mpfr_custom_init_set:                  Custom Interface.    (line  48)
-* mpfr_custom_move:                      Custom Interface.    (line  85)
-* mpfr_d_div:                            Basic Arithmetic Functions.
-                                                              (line  82)
-* mpfr_d_sub:                            Basic Arithmetic Functions.
-                                                              (line  37)
+                                                              (line  76)
+* mpfr_cos:                              Special Functions.   (line  30)
+* mpfr_cosh:                             Special Functions.   (line  96)
+* mpfr_cot:                              Special Functions.   (line  48)
+* mpfr_coth:                             Special Functions.   (line 112)
+* mpfr_csc:                              Special Functions.   (line  47)
+* mpfr_csch:                             Special Functions.   (line 111)
+* mpfr_custom_get_exp:                   Custom Interface.    (line  72)
+* mpfr_custom_get_kind:                  Custom Interface.    (line  62)
+* mpfr_custom_get_significand:           Custom Interface.    (line  67)
+* mpfr_custom_get_size:                  Custom Interface.    (line  34)
+* mpfr_custom_init:                      Custom Interface.    (line  38)
+* mpfr_custom_init_set:                  Custom Interface.    (line  45)
+* mpfr_custom_move:                      Custom Interface.    (line  79)
 * MPFR_DECL_INIT:                        Initialization Functions.
-                                                              (line  75)
-* mpfr_digamma:                          Special Functions.   (line 185)
+                                                              (line  74)
+* mpfr_digamma:                          Special Functions.   (line 164)
 * mpfr_dim:                              Basic Arithmetic Functions.
-                                                              (line 180)
+                                                              (line 164)
 * mpfr_div:                              Basic Arithmetic Functions.
-                                                              (line  72)
+                                                              (line  70)
 * mpfr_div_2exp:                         Compatibility with MPF.
-                                                              (line  51)
+                                                              (line  49)
 * mpfr_div_2si:                          Basic Arithmetic Functions.
-                                                              (line 195)
+                                                              (line 179)
 * mpfr_div_2ui:                          Basic Arithmetic Functions.
-                                                              (line 193)
+                                                              (line 177)
 * mpfr_div_d:                            Basic Arithmetic Functions.
-                                                              (line  84)
+                                                              (line  82)
 * mpfr_div_q:                            Basic Arithmetic Functions.
-                                                              (line  88)
+                                                              (line  86)
 * mpfr_div_si:                           Basic Arithmetic Functions.
-                                                              (line  80)
+                                                              (line  78)
 * mpfr_div_ui:                           Basic Arithmetic Functions.
-                                                              (line  76)
+                                                              (line  74)
 * mpfr_div_z:                            Basic Arithmetic Functions.
-                                                              (line  86)
-* mpfr_eint:                             Special Functions.   (line 155)
+                                                              (line  84)
+* mpfr_d_div:                            Basic Arithmetic Functions.
+                                                              (line  80)
+* mpfr_d_sub:                            Basic Arithmetic Functions.
+                                                              (line  35)
+* mpfr_eint:                             Special Functions.   (line 134)
 * mpfr_eq:                               Compatibility with MPF.
-                                                              (line  30)
+                                                              (line  28)
 * mpfr_equal_p:                          Comparison Functions.
-                                                              (line  61)
+                                                              (line  59)
 * mpfr_erangeflag_p:                     Exception Related Functions.
-                                                              (line 133)
-* mpfr_erf:                              Special Functions.   (line 196)
-* mpfr_erfc:                             Special Functions.   (line 197)
-* mpfr_exp:                              Special Functions.   (line  25)
-* mpfr_exp10:                            Special Functions.   (line  27)
-* mpfr_exp2:                             Special Functions.   (line  26)
-* mpfr_expm1:                            Special Functions.   (line 151)
-* mpfr_fac_ui:                           Special Functions.   (line 144)
+                                                              (line 132)
+* mpfr_erf:                              Special Functions.   (line 175)
+* mpfr_erfc:                             Special Functions.   (line 176)
+* mpfr_exp:                              Special Functions.   (line  24)
+* mpfr_exp10:                            Special Functions.   (line  26)
+* mpfr_exp2:                             Special Functions.   (line  25)
+* mpfr_expm1:                            Special Functions.   (line 130)
+* mpfr_fac_ui:                           Special Functions.   (line 122)
 * mpfr_fits_intmax_p:                    Conversion Functions.
-                                                              (line 129)
+                                                              (line 128)
 * mpfr_fits_sint_p:                      Conversion Functions.
-                                                              (line 125)
+                                                              (line 124)
 * mpfr_fits_slong_p:                     Conversion Functions.
-                                                              (line 123)
+                                                              (line 122)
 * mpfr_fits_sshort_p:                    Conversion Functions.
+                                                              (line 126)
+* mpfr_fits_uintmax_p:                   Conversion Functions.
                                                               (line 127)
 * mpfr_fits_uint_p:                      Conversion Functions.
-                                                              (line 124)
-* mpfr_fits_uintmax_p:                   Conversion Functions.
-                                                              (line 128)
+                                                              (line 123)
 * mpfr_fits_ulong_p:                     Conversion Functions.
-                                                              (line 122)
+                                                              (line 121)
 * mpfr_fits_ushort_p:                    Conversion Functions.
-                                                              (line 126)
+                                                              (line 125)
 * mpfr_floor:                            Integer Related Functions.
-                                                              (line   9)
-* mpfr_fma:                              Special Functions.   (line 223)
+                                                              (line   8)
+* mpfr_fma:                              Special Functions.   (line 201)
 * mpfr_fmod:                             Integer Related Functions.
-                                                              (line  79)
-* mpfr_fms:                              Special Functions.   (line 225)
+                                                              (line  77)
+* mpfr_fms:                              Special Functions.   (line 203)
 * mpfr_fprintf:                          Formatted Output Functions.
-                                                              (line 158)
+                                                              (line 157)
 * mpfr_frac:                             Integer Related Functions.
-                                                              (line  62)
-* mpfr_free_cache:                       Special Functions.   (line 264)
+                                                              (line  61)
+* mpfr_free_cache:                       Special Functions.   (line 242)
 * mpfr_free_str:                         Conversion Functions.
-                                                              (line 116)
-* mpfr_gamma:                            Special Functions.   (line 167)
+                                                              (line 115)
+* mpfr_gamma:                            Special Functions.   (line 146)
 * mpfr_get_d:                            Conversion Functions.
-                                                              (line   8)
-* mpfr_get_d_2exp:                       Conversion Functions.
-                                                              (line  34)
+                                                              (line   7)
 * mpfr_get_decimal64:                    Conversion Functions.
-                                                              (line  10)
+                                                              (line   9)
 * mpfr_get_default_prec:                 Initialization Functions.
-                                                              (line 110)
+                                                              (line 105)
 * mpfr_get_default_rounding_mode:        Rounding Related Functions.
-                                                              (line  11)
+                                                              (line  10)
+* mpfr_get_d_2exp:                       Conversion Functions.
+                                                              (line  32)
 * mpfr_get_emax:                         Exception Related Functions.
-                                                              (line   8)
+                                                              (line   7)
 * mpfr_get_emax_max:                     Exception Related Functions.
-                                                              (line  31)
-* mpfr_get_emax_min:                     Exception Related Functions.
                                                               (line  30)
+* mpfr_get_emax_min:                     Exception Related Functions.
+                                                              (line  29)
 * mpfr_get_emin:                         Exception Related Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpfr_get_emin_max:                     Exception Related Functions.
-                                                              (line  29)
-* mpfr_get_emin_min:                     Exception Related Functions.
                                                               (line  28)
+* mpfr_get_emin_min:                     Exception Related Functions.
+                                                              (line  27)
 * mpfr_get_exp:                          Miscellaneous Functions.
-                                                              (line  56)
+                                                              (line  55)
 * mpfr_get_f:                            Conversion Functions.
-                                                              (line  64)
+                                                              (line  63)
 * mpfr_get_flt:                          Conversion Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpfr_get_ld:                           Conversion Functions.
-                                                              (line   9)
+                                                              (line   8)
 * mpfr_get_ld_2exp:                      Conversion Functions.
-                                                              (line  36)
+                                                              (line  34)
 * mpfr_get_patches:                      Miscellaneous Functions.
-                                                              (line 115)
+                                                              (line 114)
 * mpfr_get_prec:                         Initialization Functions.
-                                                              (line 142)
+                                                              (line 137)
 * mpfr_get_si:                           Conversion Functions.
-                                                              (line  20)
+                                                              (line  19)
 * mpfr_get_sj:                           Conversion Functions.
-                                                              (line  22)
+                                                              (line  21)
 * mpfr_get_str:                          Conversion Functions.
-                                                              (line  70)
+                                                              (line  68)
 * mpfr_get_ui:                           Conversion Functions.
-                                                              (line  21)
+                                                              (line  20)
 * mpfr_get_uj:                           Conversion Functions.
-                                                              (line  23)
+                                                              (line  22)
 * mpfr_get_version:                      Miscellaneous Functions.
-                                                              (line  84)
+                                                              (line  83)
 * mpfr_get_z:                            Conversion Functions.
-                                                              (line  59)
+                                                              (line  58)
 * mpfr_get_z_2exp:                       Conversion Functions.
-                                                              (line  46)
-* mpfr_greater_p:                        Comparison Functions.
-                                                              (line  57)
+                                                              (line  45)
 * mpfr_greaterequal_p:                   Comparison Functions.
-                                                              (line  58)
-* mpfr_hypot:                            Special Functions.   (line 239)
+                                                              (line  56)
+* mpfr_greater_p:                        Comparison Functions.
+                                                              (line  55)
+* mpfr_hypot:                            Special Functions.   (line 216)
 * mpfr_inexflag_p:                       Exception Related Functions.
-                                                              (line 132)
+                                                              (line 131)
 * mpfr_inf_p:                            Comparison Functions.
-                                                              (line  42)
+                                                              (line  40)
 * mpfr_init:                             Initialization Functions.
-                                                              (line  54)
+                                                              (line  53)
 * mpfr_init2:                            Initialization Functions.
-                                                              (line  11)
+                                                              (line  10)
+* mpfr_inits:                            Initialization Functions.
+                                                              (line  62)
+* mpfr_inits2:                           Initialization Functions.
+                                                              (line  22)
 * mpfr_init_set:                         Combined Initialization and Assignment Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpfr_init_set_d:                       Combined Initialization and Assignment Functions.
-                                                              (line  12)
+                                                              (line  11)
 * mpfr_init_set_f:                       Combined Initialization and Assignment Functions.
-                                                              (line  17)
+                                                              (line  16)
 * mpfr_init_set_ld:                      Combined Initialization and Assignment Functions.
-                                                              (line  14)
+                                                              (line  12)
 * mpfr_init_set_q:                       Combined Initialization and Assignment Functions.
-                                                              (line  16)
+                                                              (line  15)
 * mpfr_init_set_si:                      Combined Initialization and Assignment Functions.
-                                                              (line  11)
+                                                              (line   9)
 * mpfr_init_set_str:                     Combined Initialization and Assignment Functions.
-                                                              (line  23)
+                                                              (line  21)
 * mpfr_init_set_ui:                      Combined Initialization and Assignment Functions.
-                                                              (line   9)
+                                                              (line   7)
 * mpfr_init_set_z:                       Combined Initialization and Assignment Functions.
-                                                              (line  15)
-* mpfr_inits:                            Initialization Functions.
-                                                              (line  63)
-* mpfr_inits2:                           Initialization Functions.
-                                                              (line  23)
+                                                              (line  14)
 * mpfr_inp_str:                          Input and Output Functions.
-                                                              (line  33)
+                                                              (line  31)
 * mpfr_integer_p:                        Integer Related Functions.
-                                                              (line 105)
-* mpfr_j0:                               Special Functions.   (line 201)
-* mpfr_j1:                               Special Functions.   (line 202)
-* mpfr_jn:                               Special Functions.   (line 204)
-* mpfr_less_p:                           Comparison Functions.
-                                                              (line  59)
+                                                              (line 104)
+* mpfr_j0:                               Special Functions.   (line 180)
+* mpfr_j1:                               Special Functions.   (line 181)
+* mpfr_jn:                               Special Functions.   (line 182)
 * mpfr_lessequal_p:                      Comparison Functions.
-                                                              (line  60)
+                                                              (line  58)
 * mpfr_lessgreater_p:                    Comparison Functions.
-                                                              (line  66)
-* mpfr_lgamma:                           Special Functions.   (line 177)
-* mpfr_li2:                              Special Functions.   (line 162)
-* mpfr_lngamma:                          Special Functions.   (line 171)
-* mpfr_log:                              Special Functions.   (line  18)
-* mpfr_log10:                            Special Functions.   (line  20)
-* mpfr_log1p:                            Special Functions.   (line 147)
-* mpfr_log2:                             Special Functions.   (line  19)
+                                                              (line  64)
+* mpfr_less_p:                           Comparison Functions.
+                                                              (line  57)
+* mpfr_lgamma:                           Special Functions.   (line 155)
+* mpfr_li2:                              Special Functions.   (line 141)
+* mpfr_lngamma:                          Special Functions.   (line 150)
+* mpfr_log:                              Special Functions.   (line  17)
+* mpfr_log10:                            Special Functions.   (line  19)
+* mpfr_log1p:                            Special Functions.   (line 126)
+* mpfr_log2:                             Special Functions.   (line  18)
 * mpfr_max:                              Miscellaneous Functions.
-                                                              (line  24)
-* mpfr_min:                              Miscellaneous Functions.
                                                               (line  22)
+* mpfr_min:                              Miscellaneous Functions.
+                                                              (line  20)
 * mpfr_min_prec:                         Rounding Related Functions.
                                                               (line  59)
 * mpfr_modf:                             Integer Related Functions.
-                                                              (line  69)
+                                                              (line  67)
 * mpfr_mul:                              Basic Arithmetic Functions.
-                                                              (line  51)
-* mpfr_mul_2exp:                         Compatibility with MPF.
                                                               (line  49)
+* mpfr_mul_2exp:                         Compatibility with MPF.
+                                                              (line  47)
 * mpfr_mul_2si:                          Basic Arithmetic Functions.
-                                                              (line 188)
+                                                              (line 172)
 * mpfr_mul_2ui:                          Basic Arithmetic Functions.
-                                                              (line 186)
+                                                              (line 170)
 * mpfr_mul_d:                            Basic Arithmetic Functions.
-                                                              (line  57)
+                                                              (line  55)
 * mpfr_mul_q:                            Basic Arithmetic Functions.
-                                                              (line  61)
+                                                              (line  59)
 * mpfr_mul_si:                           Basic Arithmetic Functions.
-                                                              (line  55)
-* mpfr_mul_ui:                           Basic Arithmetic Functions.
                                                               (line  53)
+* mpfr_mul_ui:                           Basic Arithmetic Functions.
+                                                              (line  51)
 * mpfr_mul_z:                            Basic Arithmetic Functions.
-                                                              (line  59)
-* mpfr_nan_p:                            Comparison Functions.
-                                                              (line  41)
+                                                              (line  57)
 * mpfr_nanflag_p:                        Exception Related Functions.
-                                                              (line 131)
+                                                              (line 130)
+* mpfr_nan_p:                            Comparison Functions.
+                                                              (line  39)
 * mpfr_neg:                              Basic Arithmetic Functions.
-                                                              (line 172)
+                                                              (line 157)
 * mpfr_nextabove:                        Miscellaneous Functions.
-                                                              (line  16)
+                                                              (line  15)
 * mpfr_nextbelow:                        Miscellaneous Functions.
-                                                              (line  17)
+                                                              (line  16)
 * mpfr_nexttoward:                       Miscellaneous Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpfr_number_p:                         Comparison Functions.
-                                                              (line  43)
+                                                              (line  41)
 * mpfr_out_str:                          Input and Output Functions.
-                                                              (line  17)
+                                                              (line  15)
 * mpfr_overflow_p:                       Exception Related Functions.
-                                                              (line 130)
+                                                              (line 129)
 * mpfr_pow:                              Basic Arithmetic Functions.
-                                                              (line 116)
+                                                              (line 114)
 * mpfr_pow_si:                           Basic Arithmetic Functions.
-                                                              (line 120)
-* mpfr_pow_ui:                           Basic Arithmetic Functions.
                                                               (line 118)
+* mpfr_pow_ui:                           Basic Arithmetic Functions.
+                                                              (line 116)
 * mpfr_pow_z:                            Basic Arithmetic Functions.
-                                                              (line 122)
+                                                              (line 120)
 * mpfr_prec_round:                       Rounding Related Functions.
-                                                              (line  15)
+                                                              (line  13)
 * mpfr_prec_t:                           MPFR Basics.         (line  84)
+* mpfr_printf:                           Formatted Output Functions.
+                                                              (line 164)
 * mpfr_print_rnd_mode:                   Rounding Related Functions.
                                                               (line  66)
-* mpfr_printf:                           Formatted Output Functions.
-                                                              (line 165)
 * mpfr_rec_sqrt:                         Basic Arithmetic Functions.
-                                                              (line 102)
+                                                              (line 101)
 * mpfr_regular_p:                        Comparison Functions.
-                                                              (line  45)
+                                                              (line  43)
 * mpfr_reldiff:                          Compatibility with MPF.
-                                                              (line  41)
+                                                              (line  39)
 * mpfr_remainder:                        Integer Related Functions.
-                                                              (line  81)
+                                                              (line  79)
 * mpfr_remquo:                           Integer Related Functions.
-                                                              (line  83)
+                                                              (line  81)
 * mpfr_rint:                             Integer Related Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpfr_rint_ceil:                        Integer Related Functions.
-                                                              (line  38)
+                                                              (line  37)
 * mpfr_rint_floor:                       Integer Related Functions.
-                                                              (line  40)
+                                                              (line  38)
 * mpfr_rint_round:                       Integer Related Functions.
-                                                              (line  42)
+                                                              (line  40)
 * mpfr_rint_trunc:                       Integer Related Functions.
-                                                              (line  44)
+                                                              (line  42)
 * mpfr_rnd_t:                            MPFR Basics.         (line  98)
 * mpfr_root:                             Basic Arithmetic Functions.
-                                                              (line 109)
+                                                              (line 107)
 * mpfr_round:                            Integer Related Functions.
-                                                              (line  10)
-* mpfr_sec:                              Special Functions.   (line  47)
-* mpfr_sech:                             Special Functions.   (line 131)
+                                                              (line   9)
+* mpfr_sec:                              Special Functions.   (line  46)
+* mpfr_sech:                             Special Functions.   (line 110)
 * mpfr_set:                              Assignment Functions.
-                                                              (line  10)
+                                                              (line   9)
+* mpfr_setsign:                          Miscellaneous Functions.
+                                                              (line  70)
 * mpfr_set_d:                            Assignment Functions.
-                                                              (line  17)
+                                                              (line  16)
 * mpfr_set_decimal64:                    Assignment Functions.
-                                                              (line  21)
+                                                              (line  19)
 * mpfr_set_default_prec:                 Initialization Functions.
-                                                              (line 101)
+                                                              (line  97)
 * mpfr_set_default_rounding_mode:        Rounding Related Functions.
-                                                              (line   7)
+                                                              (line   6)
 * mpfr_set_emax:                         Exception Related Functions.
-                                                              (line  17)
-* mpfr_set_emin:                         Exception Related Functions.
                                                               (line  16)
+* mpfr_set_emin:                         Exception Related Functions.
+                                                              (line  15)
 * mpfr_set_erangeflag:                   Exception Related Functions.
-                                                              (line 122)
+                                                              (line 121)
 * mpfr_set_exp:                          Miscellaneous Functions.
-                                                              (line  61)
+                                                              (line  60)
 * mpfr_set_f:                            Assignment Functions.
-                                                              (line  24)
+                                                              (line  23)
 * mpfr_set_flt:                          Assignment Functions.
-                                                              (line  16)
+                                                              (line  15)
 * mpfr_set_inexflag:                     Exception Related Functions.
-                                                              (line 121)
+                                                              (line 120)
 * mpfr_set_inf:                          Assignment Functions.
-                                                              (line 139)
+                                                              (line 136)
 * mpfr_set_ld:                           Assignment Functions.
-                                                              (line  19)
+                                                              (line  17)
 * mpfr_set_nan:                          Assignment Functions.
-                                                              (line 138)
+                                                              (line 135)
 * mpfr_set_nanflag:                      Exception Related Functions.
-                                                              (line 120)
-* mpfr_set_overflow:                     Exception Related Functions.
                                                               (line 119)
+* mpfr_set_overflow:                     Exception Related Functions.
+                                                              (line 118)
 * mpfr_set_prec:                         Initialization Functions.
-                                                              (line 132)
+                                                              (line 127)
 * mpfr_set_prec_raw:                     Compatibility with MPF.
-                                                              (line  23)
+                                                              (line  22)
 * mpfr_set_q:                            Assignment Functions.
-                                                              (line  23)
+                                                              (line  22)
 * mpfr_set_si:                           Assignment Functions.
-                                                              (line  13)
+                                                              (line  12)
 * mpfr_set_si_2exp:                      Assignment Functions.
-                                                              (line  50)
+                                                              (line  47)
 * mpfr_set_sj:                           Assignment Functions.
-                                                              (line  15)
+                                                              (line  14)
 * mpfr_set_sj_2exp:                      Assignment Functions.
-                                                              (line  54)
+                                                              (line  51)
 * mpfr_set_str:                          Assignment Functions.
-                                                              (line  62)
+                                                              (line  59)
 * mpfr_set_ui:                           Assignment Functions.
-                                                              (line  12)
+                                                              (line  10)
 * mpfr_set_ui_2exp:                      Assignment Functions.
-                                                              (line  48)
+                                                              (line  45)
 * mpfr_set_uj:                           Assignment Functions.
-                                                              (line  14)
+                                                              (line  13)
 * mpfr_set_uj_2exp:                      Assignment Functions.
-                                                              (line  52)
+                                                              (line  49)
 * mpfr_set_underflow:                    Exception Related Functions.
-                                                              (line 118)
+                                                              (line 117)
 * mpfr_set_z:                            Assignment Functions.
-                                                              (line  22)
-* mpfr_set_z_2exp:                       Assignment Functions.
-                                                              (line  56)
+                                                              (line  21)
 * mpfr_set_zero:                         Assignment Functions.
-                                                              (line 140)
-* mpfr_setsign:                          Miscellaneous Functions.
-                                                              (line  72)
+                                                              (line 137)
+* mpfr_set_z_2exp:                       Assignment Functions.
+                                                              (line  53)
 * mpfr_sgn:                              Comparison Functions.
-                                                              (line  51)
+                                                              (line  49)
+* mpfr_signbit:                          Miscellaneous Functions.
+                                                              (line  66)
+* mpfr_sin:                              Special Functions.   (line  31)
+* mpfr_sinh:                             Special Functions.   (line  97)
+* mpfr_sinh_cosh:                        Special Functions.   (line 102)
+* mpfr_sin_cos:                          Special Functions.   (line  36)
 * mpfr_si_div:                           Basic Arithmetic Functions.
-                                                              (line  78)
+                                                              (line  76)
 * mpfr_si_sub:                           Basic Arithmetic Functions.
-                                                              (line  33)
-* mpfr_signbit:                          Miscellaneous Functions.
-                                                              (line  67)
-* mpfr_sin:                              Special Functions.   (line  32)
-* mpfr_sin_cos:                          Special Functions.   (line  38)
-* mpfr_sinh:                             Special Functions.   (line 117)
-* mpfr_sinh_cosh:                        Special Functions.   (line 123)
+                                                              (line  31)
 * mpfr_snprintf:                         Formatted Output Functions.
-                                                              (line 182)
+                                                              (line 180)
 * mpfr_sprintf:                          Formatted Output Functions.
-                                                              (line 171)
+                                                              (line 170)
 * mpfr_sqr:                              Basic Arithmetic Functions.
-                                                              (line  68)
+                                                              (line  67)
 * mpfr_sqrt:                             Basic Arithmetic Functions.
-                                                              (line  95)
+                                                              (line  94)
 * mpfr_sqrt_ui:                          Basic Arithmetic Functions.
-                                                              (line  97)
+                                                              (line  95)
 * mpfr_strtofr:                          Assignment Functions.
-                                                              (line  75)
+                                                              (line  72)
 * mpfr_sub:                              Basic Arithmetic Functions.
-                                                              (line  27)
+                                                              (line  25)
+* mpfr_subnormalize:                     Exception Related Functions.
+                                                              (line  60)
 * mpfr_sub_d:                            Basic Arithmetic Functions.
-                                                              (line  39)
+                                                              (line  37)
 * mpfr_sub_q:                            Basic Arithmetic Functions.
-                                                              (line  43)
+                                                              (line  41)
 * mpfr_sub_si:                           Basic Arithmetic Functions.
-                                                              (line  35)
+                                                              (line  33)
 * mpfr_sub_ui:                           Basic Arithmetic Functions.
-                                                              (line  31)
+                                                              (line  29)
 * mpfr_sub_z:                            Basic Arithmetic Functions.
-                                                              (line  41)
-* mpfr_subnormalize:                     Exception Related Functions.
-                                                              (line  61)
-* mpfr_sum:                              Special Functions.   (line 273)
+                                                              (line  39)
+* mpfr_sum:                              Special Functions.   (line 250)
 * mpfr_swap:                             Assignment Functions.
-                                                              (line 146)
+                                                              (line 143)
 * mpfr_t:                                MPFR Basics.         (line  70)
-* mpfr_tan:                              Special Functions.   (line  33)
-* mpfr_tanh:                             Special Functions.   (line 118)
+* mpfr_tan:                              Special Functions.   (line  32)
+* mpfr_tanh:                             Special Functions.   (line  98)
 * mpfr_trunc:                            Integer Related Functions.
-                                                              (line  11)
+                                                              (line  10)
 * mpfr_ui_div:                           Basic Arithmetic Functions.
-                                                              (line  74)
+                                                              (line  72)
 * mpfr_ui_pow:                           Basic Arithmetic Functions.
-                                                              (line 126)
-* mpfr_ui_pow_ui:                        Basic Arithmetic Functions.
                                                               (line 124)
+* mpfr_ui_pow_ui:                        Basic Arithmetic Functions.
+                                                              (line 122)
 * mpfr_ui_sub:                           Basic Arithmetic Functions.
-                                                              (line  29)
+                                                              (line  27)
 * mpfr_underflow_p:                      Exception Related Functions.
-                                                              (line 129)
+                                                              (line 128)
 * mpfr_unordered_p:                      Comparison Functions.
-                                                              (line  71)
+                                                              (line  69)
 * mpfr_urandom:                          Miscellaneous Functions.
-                                                              (line  46)
+                                                              (line  44)
 * mpfr_urandomb:                         Miscellaneous Functions.
-                                                              (line  30)
+                                                              (line  29)
 * mpfr_vasprintf:                        Formatted Output Functions.
-                                                              (line 196)
+                                                              (line 194)
 * MPFR_VERSION:                          Miscellaneous Functions.
-                                                              (line  87)
+                                                              (line  86)
 * MPFR_VERSION_MAJOR:                    Miscellaneous Functions.
-                                                              (line  88)
+                                                              (line  87)
 * MPFR_VERSION_MINOR:                    Miscellaneous Functions.
-                                                              (line  89)
+                                                              (line  88)
 * MPFR_VERSION_NUM:                      Miscellaneous Functions.
-                                                              (line 107)
+                                                              (line 106)
 * MPFR_VERSION_PATCHLEVEL:               Miscellaneous Functions.
-                                                              (line  90)
+                                                              (line  89)
 * MPFR_VERSION_STRING:                   Miscellaneous Functions.
-                                                              (line  91)
+                                                              (line  90)
 * mpfr_vfprintf:                         Formatted Output Functions.
-                                                              (line 160)
+                                                              (line 158)
 * mpfr_vprintf:                          Formatted Output Functions.
-                                                              (line 166)
+                                                              (line 165)
 * mpfr_vsnprintf:                        Formatted Output Functions.
-                                                              (line 184)
+                                                              (line 182)
 * mpfr_vsprintf:                         Formatted Output Functions.
-                                                              (line 173)
-* mpfr_y0:                               Special Functions.   (line 212)
-* mpfr_y1:                               Special Functions.   (line 213)
-* mpfr_yn:                               Special Functions.   (line 215)
+                                                              (line 171)
+* mpfr_y0:                               Special Functions.   (line 191)
+* mpfr_y1:                               Special Functions.   (line 192)
+* mpfr_yn:                               Special Functions.   (line 193)
 * mpfr_zero_p:                           Comparison Functions.
-                                                              (line  44)
-* mpfr_zeta:                             Special Functions.   (line 190)
-* mpfr_zeta_ui:                          Special Functions.   (line 192)
+                                                              (line  42)
+* mpfr_zeta:                             Special Functions.   (line 169)
+* mpfr_zeta_ui:                          Special Functions.   (line 170)
 
 
 
 Tag Table:
-Node: Top880
-Node: Copying2210
-Node: Introduction to MPFR3970
-Node: Installing MPFR6059
-Node: Reporting Bugs10798
-Node: MPFR Basics12593
-Node: MPFR Interface28132
-Node: Initialization Functions30228
-Node: Assignment Functions36901
-Node: Combined Initialization and Assignment Functions45248
-Node: Conversion Functions46541
-Node: Basic Arithmetic Functions54013
-Node: Comparison Functions62930
-Node: Special Functions66412
-Node: Input and Output Functions80001
-Node: Formatted Output Functions81924
-Node: Integer Related Functions91023
-Node: Rounding Related Functions96785
-Node: Miscellaneous Functions100391
-Node: Exception Related Functions106952
-Node: Compatibility with MPF113486
-Node: Custom Interface116174
-Node: Internals120419
-Node: API Compatibility121903
-Node: Type and Macro Changes123833
-Node: Added Functions126554
-Node: Changed Functions129075
-Node: Removed Functions132799
-Node: Other Changes133211
-Node: Contributors134385
-Node: References136705
-Node: GNU Free Documentation License138446
-Node: Concept Index160889
-Node: Function Index165827
+Node: Top878
+Node: Copying2204
+Node: Introduction to MPFR3967
+Node: Installing MPFR6079
+Node: Reporting Bugs11045
+Node: MPFR Basics12859
+Node: MPFR Interface28787
+Node: Initialization Functions30901
+Node: Assignment Functions37791
+Node: Combined Initialization and Assignment Functions46414
+Node: Conversion Functions47715
+Node: Basic Arithmetic Functions55316
+Node: Comparison Functions64390
+Node: Special Functions67877
+Node: Input and Output Functions81702
+Node: Formatted Output Functions83674
+Node: Integer Related Functions93433
+Node: Rounding Related Functions99302
+Node: Miscellaneous Functions102940
+Node: Exception Related Functions109581
+Node: Compatibility with MPF116179
+Node: Custom Interface118910
+Node: Internals123306
+Node: API Compatibility124850
+Node: Type and Macro Changes126779
+Node: Added Functions129628
+Node: Changed Functions132442
+Node: Removed Functions136282
+Node: Other Changes136710
+Node: Contributors137953
+Node: References140332
+Node: GNU Free Documentation License142086
+Node: Concept Index164679
+Node: Function Index169763
 
 End Tag Table
 
